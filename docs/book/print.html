<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>bbx_audio Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for the bbx_audio Rust audio DSP workspace">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex-76b91a01.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-a5c83966.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">bbx_audio Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/blackboxaudio/bbx_audio" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="bbx_audio"><a class="header" href="#bbx_audio">bbx_audio</a></h1>
<p>A Rust workspace for audio DSP with C FFI bindings for JUCE plugin integration.</p>
<blockquote>
<p><strong>Note</strong>: These crates are still in early development. Expect breaking changes in some releases.</p>
</blockquote>
<h2 id="what-is-bbx_audio"><a class="header" href="#what-is-bbx_audio">What is bbx_audio?</a></h2>
<p>bbx_audio is a collection of Rust crates designed for real-time audio digital signal processing (DSP). It provides a graph-based architecture for building audio processing chains, with first-class support for integrating Rust DSP code into C++ audio applications like JUCE plugins.</p>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="#bbx_core"><code>bbx_core</code></a></td><td>Error types and foundational utilities</td></tr>
<tr><td><a href="#bbx_dsp"><code>bbx_dsp</code></a></td><td>DSP graph system, blocks, and <code>PluginDsp</code> trait</td></tr>
<tr><td><a href="#bbx_plugin"><code>bbx_plugin</code></a></td><td>C FFI bindings for JUCE integration</td></tr>
<tr><td><a href="#bbx_file"><code>bbx_file</code></a></td><td>Audio file I/O (WAV)</td></tr>
<tr><td><a href="#bbx_midi"><code>bbx_midi</code></a></td><td>MIDI message parsing and streaming</td></tr>
</tbody>
</table>
</div>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<pre><code>bbx_core (foundational utilities)
    └── bbx_dsp (DSP graph system)
            ├── bbx_file (audio file I/O via hound/wavers)
            └── bbx_plugin (FFI bindings)
bbx_midi (MIDI streaming via midir, independent)
</code></pre>
<p>The core DSP system is built around a <strong>Graph</strong> of connected <strong>Blocks</strong>:</p>
<ul>
<li><strong><code>Block</code> trait</strong>: Defines the DSP processing interface with <code>process()</code>, input/output counts, and modulation outputs</li>
<li><strong><code>BlockType</code> enum</strong>: Wraps all concrete block implementations (oscillators, effects, I/O, modulators)</li>
<li><strong><code>Graph</code></strong>: Manages block connections, topological sorting for execution order, and buffer allocation</li>
<li><strong><code>GraphBuilder</code></strong>: Fluent API for constructing DSP graphs</li>
</ul>
<h2 id="who-is-this-documentation-for"><a class="header" href="#who-is-this-documentation-for">Who is this documentation for?</a></h2>
<h3 id="plugin-developers"><a class="header" href="#plugin-developers">Plugin Developers</a></h3>
<p>If you want to use Rust for your audio plugin DSP while keeping your UI and plugin framework in C++/JUCE, start with:</p>
<ol>
<li><a href="#quick-start">Quick Start</a> - Get a simple graph running</li>
<li><a href="#juce-plugin-integration-overview">JUCE Plugin Integration</a> - Full integration guide</li>
<li><a href="#parameter-system">Parameter System</a> - Managing plugin parameters</li>
</ol>
<h3 id="library-contributors"><a class="header" href="#library-contributors">Library Contributors</a></h3>
<p>If you want to contribute to bbx_audio or understand its internals:</p>
<ol>
<li><a href="#development-setup">Development Setup</a> - Set up your environment</li>
<li><a href="#dsp-graph-architecture">DSP Graph Architecture</a> - Understand the core design</li>
<li><a href="#adding-new-blocks">Adding New Blocks</a> - Extend the block library</li>
</ol>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{GraphBuilder, blocks::*};

// Build a simple oscillator -&gt; gain -&gt; output chain
let graph = GraphBuilder::new()
    .add_block(OscillatorBlock::new(440.0, Waveform::Sine))
    .add_block(GainBlock::new(-6.0))
    .add_block(OutputBlock::new(2))
    .connect(0, 0, 1, 0)?  // Oscillator -&gt; Gain
    .connect(1, 0, 2, 0)?  // Gain -&gt; Output
    .build()?;
<span class="boring">}</span></code></pre>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>bbx_audio is licensed under the MIT License. See <a href="https://github.com/blackboxaudio/bbx_audio/blob/develop/LICENSE">LICENSE</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="adding-bbx_audio-to-your-project"><a class="header" href="#adding-bbx_audio-to-your-project">Adding bbx_audio to Your Project</a></h2>
<p>Add the crates you need to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
bbx_dsp = "0.1"
bbx_core = "0.1"
</code></pre>
<p>For JUCE plugin integration, you’ll also need:</p>
<pre><code class="language-toml">[dependencies]
bbx_plugin = "0.1"
</code></pre>
<p>For audio file I/O:</p>
<pre><code class="language-toml">[dependencies]
bbx_file = "0.1"
</code></pre>
<p>For MIDI support:</p>
<pre><code class="language-toml">[dependencies]
bbx_midi = "0.1"
</code></pre>
<h2 id="using-git-dependencies"><a class="header" href="#using-git-dependencies">Using Git Dependencies</a></h2>
<p>To use the latest development version:</p>
<pre><code class="language-toml">[dependencies]
bbx_dsp = { git = "https://github.com/blackboxaudio/bbx_audio" }
bbx_plugin = { git = "https://github.com/blackboxaudio/bbx_audio" }
</code></pre>
<h2 id="platform-specific-setup"><a class="header" href="#platform-specific-setup">Platform-Specific Setup</a></h2>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>Install required packages for audio I/O:</p>
<pre><code class="language-bash">sudo apt install alsa libasound2-dev libssl-dev pkg-config
</code></pre>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>No additional dependencies required. CoreAudio is used automatically.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>No additional dependencies required. WASAPI is used automatically.</p>
<h2 id="local-development"><a class="header" href="#local-development">Local Development</a></h2>
<p>To develop against a local copy of bbx_audio, create <code>.cargo/config.toml</code> in your project:</p>
<pre><code class="language-toml">[patch."https://github.com/blackboxaudio/bbx_audio"]
bbx_core = { path = "/path/to/bbx_audio/bbx_core" }
bbx_dsp = { path = "/path/to/bbx_audio/bbx_dsp" }
bbx_plugin = { path = "/path/to/bbx_audio/bbx_plugin" }
bbx_midi = { path = "/path/to/bbx_audio/bbx_midi" }
</code></pre>
<p>This file should be added to your <code>.gitignore</code>.</p>
<h2 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying Installation</a></h2>
<p>Create a simple test to verify everything is working:</p>
<pre class="playground"><code class="language-rust">use bbx_dsp::GraphBuilder;

fn main() {
    let _graph = GraphBuilder::new();
    println!("bbx_audio installed successfully!");
}</code></pre>
<p>Run with:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>This guide walks you through creating your first DSP graph with bbx_audio.</p>
<h2 id="building-a-simple-synthesizer"><a class="header" href="#building-a-simple-synthesizer">Building a Simple Synthesizer</a></h2>
<p>Let’s create a sine wave oscillator with gain control:</p>
<pre class="playground"><code class="language-rust">use bbx_dsp::{
    Graph, GraphBuilder,
    blocks::{OscillatorBlock, GainBlock, OutputBlock, Waveform},
    context::DspContext,
};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create a DSP context
    let context = DspContext::new(44100.0, 512, 2);

    // Build the graph
    let mut graph = GraphBuilder::new()
        .add_block(OscillatorBlock::new(440.0, Waveform::Sine))  // Block 0
        .add_block(GainBlock::new(-6.0))                          // Block 1
        .add_block(OutputBlock::new(2))                           // Block 2
        .connect(0, 0, 1, 0)?  // Oscillator output -&gt; Gain input
        .connect(1, 0, 2, 0)?  // Gain output -&gt; Output block
        .build()?;

    // Prepare the graph
    graph.prepare(&amp;context);

    // Process audio
    let mut output = vec![vec![0.0f32; 512]; 2];
    let inputs: Vec&lt;&amp;[f32]&gt; = vec![];
    let mut outputs: Vec&lt;&amp;mut [f32]&gt; = output.iter_mut().map(|v| v.as_mut_slice()).collect();

    graph.process(&amp;inputs, &amp;mut outputs, &amp;context);

    // output now contains 512 samples of a 440Hz sine wave at -6dB
    println!("Generated {} samples", output[0].len());

    Ok(())
}</code></pre>
<h2 id="understanding-the-code"><a class="header" href="#understanding-the-code">Understanding the Code</a></h2>
<h3 id="dspcontext"><a class="header" href="#dspcontext">DspContext</a></h3>
<p>The <code>DspContext</code> holds audio processing parameters:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let context = DspContext::new(
    44100.0,  // Sample rate in Hz
    512,      // Buffer size in samples
    2,        // Number of channels
);
<span class="boring">}</span></code></pre>
<h3 id="graphbuilder"><a class="header" href="#graphbuilder">GraphBuilder</a></h3>
<p>The <code>GraphBuilder</code> provides a fluent API for constructing DSP graphs:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let graph = GraphBuilder::new()
    .add_block(/* block */)  // Returns block index
    .connect(from_block, from_port, to_block, to_port)?
    .build()?;
<span class="boring">}</span></code></pre>
<h3 id="connections"><a class="header" href="#connections">Connections</a></h3>
<p>Connections are made between block outputs and inputs using indices:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.connect(0, 0, 1, 0)?  // Block 0, output 0 -&gt; Block 1, input 0
<span class="boring">}</span></code></pre>
<h2 id="adding-effects"><a class="header" href="#adding-effects">Adding Effects</a></h2>
<p>Let’s add some effects to our oscillator:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::blocks::{PannerBlock, OverdriveBlock};

let mut graph = GraphBuilder::new()
    .add_block(OscillatorBlock::new(440.0, Waveform::Saw))   // 0: Oscillator
    .add_block(OverdriveBlock::new(0.7))                      // 1: Overdrive
    .add_block(GainBlock::new(-12.0))                         // 2: Gain
    .add_block(PannerBlock::new(0.0))                         // 3: Panner (center)
    .add_block(OutputBlock::new(2))                           // 4: Output
    .connect(0, 0, 1, 0)?  // Osc -&gt; Overdrive
    .connect(1, 0, 2, 0)?  // Overdrive -&gt; Gain
    .connect(2, 0, 3, 0)?  // Gain -&gt; Panner
    .connect(3, 0, 4, 0)?  // Panner L -&gt; Output
    .connect(3, 1, 4, 1)?  // Panner R -&gt; Output
    .build()?;
<span class="boring">}</span></code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="#creating-a-simple-oscillator">Creating a Simple Oscillator</a> - Explore oscillator waveforms</li>
<li><a href="#adding-effects-1">Adding Effects</a> - Learn about effect blocks</li>
<li><a href="#parameter-modulation-with-lfos">Parameter Modulation</a> - Use LFOs to modulate parameters</li>
<li><a href="#juce-plugin-integration-overview">JUCE Integration</a> - Integrate with JUCE plugins</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h1>
<p>This guide covers building bbx_audio from source for development or contribution.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="rust-toolchain"><a class="header" href="#rust-toolchain">Rust Toolchain</a></h3>
<p>bbx_audio requires Rust with the nightly toolchain for some development features:</p>
<pre><code class="language-bash"># Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Add nightly toolchain
rustup toolchain install nightly

# Verify installation
rustc --version
cargo --version
</code></pre>
<h3 id="platform-dependencies"><a class="header" href="#platform-dependencies">Platform Dependencies</a></h3>
<h4 id="linux-1"><a class="header" href="#linux-1">Linux</a></h4>
<pre><code class="language-bash">sudo apt install alsa libasound2-dev libssl-dev pkg-config
</code></pre>
<h4 id="macos--windows"><a class="header" href="#macos--windows">macOS / Windows</a></h4>
<p>No additional dependencies required.</p>
<h2 id="clone-and-build"><a class="header" href="#clone-and-build">Clone and Build</a></h2>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/blackboxaudio/bbx_audio.git
cd bbx_audio

# Build all crates
cargo build --workspace

# Build in release mode
cargo build --workspace --release
</code></pre>
<h2 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h2>
<pre><code class="language-bash"># Run all tests
cargo test --workspace --release
</code></pre>
<h2 id="code-quality"><a class="header" href="#code-quality">Code Quality</a></h2>
<h3 id="formatting"><a class="header" href="#formatting">Formatting</a></h3>
<p>bbx_audio uses the nightly formatter:</p>
<pre><code class="language-bash">cargo +nightly fmt
</code></pre>
<h3 id="linting"><a class="header" href="#linting">Linting</a></h3>
<p>Clippy is used for linting:</p>
<pre><code class="language-bash">cargo +nightly clippy
</code></pre>
<h2 id="running-examples"><a class="header" href="#running-examples">Running Examples</a></h2>
<p>The <code>bbx_sandbox</code> crate contains example programs:</p>
<pre><code class="language-bash"># List available examples
ls bbx_sandbox/examples/

# Run an example
cargo run --release --example &lt;example_name&gt; -p bbx_sandbox
</code></pre>
<h2 id="generating-documentation"><a class="header" href="#generating-documentation">Generating Documentation</a></h2>
<p>Generate rustdoc documentation:</p>
<pre><code class="language-bash">cargo doc --workspace --no-deps --open
</code></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<pre><code>bbx_audio/
├── bbx_core/       # Foundational utilities
├── bbx_dsp/        # DSP graph system
├── bbx_file/       # Audio file I/O
├── bbx_midi/       # MIDI handling
├── bbx_plugin/     # FFI bindings
├── bbx_sandbox/    # Examples
├── docs/           # This documentation
└── Cargo.toml      # Workspace manifest
</code></pre>
<h2 id="build-configuration"><a class="header" href="#build-configuration">Build Configuration</a></h2>
<p>The workspace uses Rust 2024 edition. Key settings in the root <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[workspace]
resolver = "2"
members = [
    "bbx_core",
    "bbx_dsp",
    "bbx_file",
    "bbx_midi",
    "bbx_plugin",
    "bbx_sandbox",
]
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="toolchain-not-found-error"><a class="header" href="#toolchain-not-found-error">“toolchain not found” Error</a></h3>
<p>Install the nightly toolchain:</p>
<pre><code class="language-bash">rustup toolchain install nightly
</code></pre>
<h3 id="audio-device-errors-on-linux"><a class="header" href="#audio-device-errors-on-linux">Audio Device Errors on Linux</a></h3>
<p>Ensure ALSA development packages are installed:</p>
<pre><code class="language-bash">sudo apt install alsa libasound2-dev
</code></pre>
<h3 id="slow-builds"><a class="header" href="#slow-builds">Slow Builds</a></h3>
<p>Use release mode for faster runtime performance:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>For faster compile times during development, use debug mode:</p>
<pre><code class="language-bash">cargo build
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="your-first-dsp-graph"><a class="header" href="#your-first-dsp-graph">Your First DSP Graph</a></h1>
<p>This tutorial walks you through creating your first audio processing graph with bbx_audio.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Add bbx_dsp to your project:</p>
<pre><code class="language-toml">[dependencies]
bbx_dsp = "0.1"
</code></pre>
<h2 id="creating-a-graph"><a class="header" href="#creating-a-graph">Creating a Graph</a></h2>
<p>DSP graphs in bbx_audio are built using <code>GraphBuilder</code>:</p>
<pre class="playground"><code class="language-rust">use bbx_dsp::graph::GraphBuilder;

fn main() {
    // Create a builder with:
    // - 44100 Hz sample rate
    // - 512 sample buffer size
    // - 2 channels (stereo)
    let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

    // Build the graph
    let graph = builder.build();
}</code></pre>
<h2 id="adding-an-oscillator"><a class="header" href="#adding-an-oscillator">Adding an Oscillator</a></h2>
<p>Let’s add a sine wave oscillator:</p>
<pre class="playground"><code class="language-rust">use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

fn main() {
    let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

    // Add a 440 Hz sine wave oscillator
    // The third parameter is an optional LFO for frequency modulation
    let osc = builder.add_oscillator(440.0, Waveform::Sine, None);

    let graph = builder.build();
}</code></pre>
<p>The <code>add_oscillator</code> method returns a <code>BlockId</code> that you can use to connect blocks.</p>
<h2 id="processing-audio"><a class="header" href="#processing-audio">Processing Audio</a></h2>
<p>Once you have a graph, you can process audio:</p>
<pre class="playground"><code class="language-rust">use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

fn main() {
    let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);
    let _osc = builder.add_oscillator(440.0, Waveform::Sine, None);
    let mut graph = builder.build();

    // Create output buffers
    let mut left = vec![0.0f32; 512];
    let mut right = vec![0.0f32; 512];

    // Process into the buffers
    let mut outputs: [&amp;mut [f32]; 2] = [&amp;mut left, &amp;mut right];
    graph.process_buffers(&amp;mut outputs);

    // left and right now contain 512 samples of a 440 Hz sine wave
    println!("First sample: {}", left[0]);
}</code></pre>
<h2 id="connecting-blocks"><a class="header" href="#connecting-blocks">Connecting Blocks</a></h2>
<p>Blocks are connected using the <code>connect</code> method:</p>
<pre class="playground"><code class="language-rust">use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

fn main() {
    let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

    // Add blocks
    let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
    let gain = builder.add_gain(-6.0);  // -6 dB

    // Connect oscillator output 0 to gain input 0
    builder.connect(osc, 0, gain, 0);

    let graph = builder.build();
}</code></pre>
<h2 id="understanding-block-ids"><a class="header" href="#understanding-block-ids">Understanding Block IDs</a></h2>
<p>Each block added to the graph gets a unique <code>BlockId</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let osc = builder.add_oscillator(440.0, Waveform::Sine, None);   // Block 0
let gain = builder.add_gain(-6.0);                                // Block 1
let pan = builder.add_panner(0.0);                                // Block 2
<span class="boring">}</span></code></pre>
<p>Use these IDs when connecting blocks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>builder.connect(from_block, from_port, to_block, to_port);
<span class="boring">}</span></code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<pre class="playground"><code class="language-rust">use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

fn main() {
    // Create builder
    let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

    // Build a simple synth chain
    let osc = builder.add_oscillator(440.0, Waveform::Saw, None);
    let gain = builder.add_gain(-12.0);
    let pan = builder.add_panner(0.25);  // Slightly right

    // Connect: Osc -&gt; Gain -&gt; Panner
    builder.connect(osc, 0, gain, 0);
    builder.connect(gain, 0, pan, 0);

    // Build the graph
    let mut graph = builder.build();

    // Process multiple buffers
    let mut left = vec![0.0f32; 512];
    let mut right = vec![0.0f32; 512];

    for _ in 0..100 {
        let mut outputs: [&amp;mut [f32]; 2] = [&amp;mut left, &amp;mut right];
        graph.process_buffers(&amp;mut outputs);

        // Do something with the audio...
    }
}</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><a href="#creating-a-simple-oscillator">Creating a Simple Oscillator</a> - Explore different waveforms</li>
<li><a href="#adding-effects-1">Adding Effects</a> - Add more processing blocks</li>
<li><a href="#parameter-modulation-with-lfos">Parameter Modulation</a> - Use LFOs to modulate parameters</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="creating-a-simple-oscillator"><a class="header" href="#creating-a-simple-oscillator">Creating a Simple Oscillator</a></h1>
<p>This tutorial explores the <code>OscillatorBlock</code> and its waveform options.</p>
<h2 id="available-waveforms"><a class="header" href="#available-waveforms">Available Waveforms</a></h2>
<p>bbx_audio provides several waveform types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::waveform::Waveform;

let waveform = Waveform::Sine;      // Pure sine wave
let waveform = Waveform::Square;    // Square wave (50% duty cycle)
let waveform = Waveform::Saw;       // Sawtooth wave
let waveform = Waveform::Triangle;  // Triangle wave
let waveform = Waveform::Pulse;     // Pulse wave (variable duty cycle)
let waveform = Waveform::Noise;     // White noise
<span class="boring">}</span></code></pre>
<h2 id="adding-oscillators"><a class="header" href="#adding-oscillators">Adding Oscillators</a></h2>
<p>Add an oscillator using <code>GraphBuilder</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// 440 Hz sine wave
let sine_osc = builder.add_oscillator(440.0, Waveform::Sine, None);

// 220 Hz sawtooth
let saw_osc = builder.add_oscillator(220.0, Waveform::Saw, None);
<span class="boring">}</span></code></pre>
<h2 id="waveform-characteristics"><a class="header" href="#waveform-characteristics">Waveform Characteristics</a></h2>
<h3 id="sine"><a class="header" href="#sine">Sine</a></h3>
<p>Pure sinusoidal wave. No harmonics - the most “pure” tone.</p>
<p><strong>Use for</strong>: Subharmonics, test tones, smooth modulation sources.</p>
<h3 id="square"><a class="header" href="#square">Square</a></h3>
<p>Equal time spent at maximum and minimum values. Contains only odd harmonics.</p>
<p><strong>Use for</strong>: Hollow/woody tones, classic synthesizer sounds.</p>
<h3 id="sawtooth"><a class="header" href="#sawtooth">Sawtooth</a></h3>
<p>Ramps from minimum to maximum, then resets. Contains all harmonics.</p>
<p><strong>Use for</strong>: Bright, buzzy sounds. Good starting point for subtractive synthesis.</p>
<h3 id="triangle"><a class="header" href="#triangle">Triangle</a></h3>
<p>Linear ramp up, linear ramp down. Contains only odd harmonics with steep rolloff.</p>
<p><strong>Use for</strong>: Softer tones than square, flute-like sounds.</p>
<h3 id="pulse"><a class="header" href="#pulse">Pulse</a></h3>
<p>Like square, but with variable duty cycle. The pulse width affects the harmonic content.</p>
<p><strong>Use for</strong>: Nasal, reedy sounds. Width modulation creates rich timbres.</p>
<h3 id="noise"><a class="header" href="#noise">Noise</a></h3>
<p>Random samples. Contains all frequencies equally.</p>
<p><strong>Use for</strong>: Percussion, wind sounds, adding texture.</p>
<h2 id="frequency-modulation"><a class="header" href="#frequency-modulation">Frequency Modulation</a></h2>
<p>Use an LFO to modulate the oscillator frequency:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Add an LFO for vibrato
let lfo = builder.add_lfo(5.0, Waveform::Sine);  // 5 Hz vibrato

// Oscillator with frequency modulation
// The LFO will modulate the frequency ±10%
let osc = builder.add_oscillator(440.0, Waveform::Sine, Some(lfo));

let graph = builder.build();
<span class="boring">}</span></code></pre>
<h2 id="polyphony"><a class="header" href="#polyphony">Polyphony</a></h2>
<p>Create multiple oscillators for polyphonic sounds:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// C major chord: C4, E4, G4
let c4 = builder.add_oscillator(261.63, Waveform::Sine, None);
let e4 = builder.add_oscillator(329.63, Waveform::Sine, None);
let g4 = builder.add_oscillator(392.00, Waveform::Sine, None);

// Mix them together with a gain block
let mixer = builder.add_gain(-9.0);  // -9 dB for headroom

builder.connect(c4, 0, mixer, 0);
builder.connect(e4, 0, mixer, 0);
builder.connect(g4, 0, mixer, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<h2 id="detuned-oscillators"><a class="header" href="#detuned-oscillators">Detuned Oscillators</a></h2>
<p>Create a thicker sound with detuned oscillators:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let base_freq = 440.0;
let detune_cents = 7.0;  // 7 cents detune

// Calculate detuned frequencies
let detune_factor = 2.0_f32.powf(detune_cents / 1200.0);
let freq_up = base_freq * detune_factor;
let freq_down = base_freq / detune_factor;

// Three oscillators: center, up, down
let osc_center = builder.add_oscillator(base_freq, Waveform::Saw, None);
let osc_up = builder.add_oscillator(freq_up, Waveform::Saw, None);
let osc_down = builder.add_oscillator(freq_down, Waveform::Saw, None);

let mixer = builder.add_gain(-9.0);
builder.connect(osc_center, 0, mixer, 0);
builder.connect(osc_up, 0, mixer, 0);
builder.connect(osc_down, 0, mixer, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<ul>
<li><a href="#adding-effects-1">Adding Effects</a> - Process oscillator output with effects</li>
<li><a href="#parameter-modulation-with-lfos">Parameter Modulation</a> - Animate parameters with LFOs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="adding-effects-1"><a class="header" href="#adding-effects-1">Adding Effects</a></h1>
<p>This tutorial covers the effect blocks available in bbx_audio.</p>
<h2 id="available-effects"><a class="header" href="#available-effects">Available Effects</a></h2>
<ul>
<li><code>GainBlock</code> - Level control in dB</li>
<li><code>PannerBlock</code> - Stereo panning</li>
<li><code>OverdriveBlock</code> - Soft-clipping distortion</li>
<li><code>DcBlockerBlock</code> - DC offset removal</li>
<li><code>ChannelRouterBlock</code> - Channel routing/manipulation</li>
</ul>
<h2 id="gainblock"><a class="header" href="#gainblock">GainBlock</a></h2>
<p>Control signal level in decibels:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let gain = builder.add_gain(-6.0);  // -6 dB (half amplitude)

builder.connect(osc, 0, gain, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<p>Common gain values:</p>
<ul>
<li><code>0.0</code> dB = unity (no change)</li>
<li><code>-6.0</code> dB = half amplitude</li>
<li><code>-12.0</code> dB = quarter amplitude</li>
<li><code>+6.0</code> dB = double amplitude (watch for clipping!)</li>
</ul>
<h2 id="pannerblock"><a class="header" href="#pannerblock">PannerBlock</a></h2>
<p>Position audio in the stereo field:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let pan = builder.add_panner(0.0);  // Center

builder.connect(osc, 0, pan, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<p>Pan values:</p>
<ul>
<li><code>-1.0</code> = Hard left</li>
<li><code>0.0</code> = Center</li>
<li><code>+1.0</code> = Hard right</li>
</ul>
<p>The panner uses constant-power panning for natural-sounding transitions.</p>
<h2 id="overdriveblock"><a class="header" href="#overdriveblock">OverdriveBlock</a></h2>
<p>Soft-clipping distortion for warmth and saturation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let osc = builder.add_oscillator(440.0, Waveform::Sine, None);

// Overdrive with drive amount, input gain, output gain
let overdrive = builder.add_overdrive(
    5.0,      // Drive amount (higher = more distortion)
    1.0,      // Input gain
    0.7,      // Output gain (compensate for level increase)
    44100.0   // Sample rate
);

builder.connect(osc, 0, overdrive, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<h2 id="dcblockerblock"><a class="header" href="#dcblockerblock">DcBlockerBlock</a></h2>
<p>Remove DC offset from signals:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let dc_blocker = builder.add_dc_blocker();

builder.connect(osc, 0, dc_blocker, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<p>Use DC blockers after:</p>
<ul>
<li>Distortion effects</li>
<li>Asymmetric waveforms</li>
<li>External audio input</li>
</ul>
<h2 id="building-effect-chains"><a class="header" href="#building-effect-chains">Building Effect Chains</a></h2>
<p>Chain multiple effects together:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Source
let osc = builder.add_oscillator(440.0, Waveform::Saw, None);

// Effect chain
let overdrive = builder.add_overdrive(3.0, 1.0, 0.8, 44100.0);
let dc_blocker = builder.add_dc_blocker();
let gain = builder.add_gain(-6.0);
let pan = builder.add_panner(0.0);

// Connect: Osc -&gt; Overdrive -&gt; DC Blocker -&gt; Gain -&gt; Pan
builder.connect(osc, 0, overdrive, 0);
builder.connect(overdrive, 0, dc_blocker, 0);
builder.connect(dc_blocker, 0, gain, 0);
builder.connect(gain, 0, pan, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<h2 id="parallel-effects"><a class="header" href="#parallel-effects">Parallel Effects</a></h2>
<p>Route signals to multiple effects in parallel:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let osc = builder.add_oscillator(440.0, Waveform::Saw, None);

// Two parallel paths
let clean_gain = builder.add_gain(-6.0);
let dirty_overdrive = builder.add_overdrive(8.0, 1.0, 0.5, 44100.0);

// Mix them back together
let mix = builder.add_gain(-3.0);

// Split to both paths
builder.connect(osc, 0, clean_gain, 0);
builder.connect(osc, 0, dirty_overdrive, 0);

// Merge at mix
builder.connect(clean_gain, 0, mix, 0);
builder.connect(dirty_overdrive, 0, mix, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<h2 id="effect-order-matters"><a class="header" href="#effect-order-matters">Effect Order Matters</a></h2>
<p>The order of effects changes the sound:</p>
<pre><code>Osc -&gt; Overdrive -&gt; Gain    // Distort first, then control level
Osc -&gt; Gain -&gt; Overdrive    // Control level into distortion (changes character)
</code></pre>
<p>General guidelines:</p>
<ol>
<li><strong>Gain staging</strong> - Control levels before distortion</li>
<li><strong>Distortion</strong> - Apply saturation</li>
<li><strong>DC blocking</strong> - Remove offset after distortion</li>
<li><strong>EQ/Filtering</strong> - Shape the tone (when available)</li>
<li><strong>Panning</strong> - Position in stereo field</li>
<li><strong>Final gain</strong> - Set output level</li>
</ol>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li><a href="#parameter-modulation-with-lfos">Parameter Modulation</a> - Animate effect parameters</li>
<li><a href="#working-with-audio-files">Working with Audio Files</a> - Process real audio</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="parameter-modulation-with-lfos"><a class="header" href="#parameter-modulation-with-lfos">Parameter Modulation with LFOs</a></h1>
<p>This tutorial covers using LFOs and envelopes to modulate block parameters.</p>
<h2 id="low-frequency-oscillators-lfos"><a class="header" href="#low-frequency-oscillators-lfos">Low-Frequency Oscillators (LFOs)</a></h2>
<p>LFOs generate control signals for modulating parameters like pitch, volume, and filter cutoff.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Create an LFO at 4 Hz with sine waveform
let lfo = builder.add_lfo(4.0, Waveform::Sine);
<span class="boring">}</span></code></pre>
<h2 id="vibrato-pitch-modulation"><a class="header" href="#vibrato-pitch-modulation">Vibrato (Pitch Modulation)</a></h2>
<p>Modulate oscillator frequency for vibrato:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// LFO for vibrato
let vibrato_lfo = builder.add_lfo(5.0, Waveform::Sine);

// Oscillator with frequency modulation
let osc = builder.add_oscillator(440.0, Waveform::Sine, Some(vibrato_lfo));

let graph = builder.build();
<span class="boring">}</span></code></pre>
<p>Typical vibrato settings:</p>
<ul>
<li><strong>Rate</strong>: 4-7 Hz</li>
<li><strong>Waveform</strong>: Sine or Triangle</li>
<li><strong>Depth</strong>: Subtle (a few cents)</li>
</ul>
<h2 id="tremolo-amplitude-modulation"><a class="header" href="#tremolo-amplitude-modulation">Tremolo (Amplitude Modulation)</a></h2>
<p>Modulate gain for tremolo effect:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let osc = builder.add_oscillator(440.0, Waveform::Sine, None);

// LFO for tremolo
let tremolo_lfo = builder.add_lfo(6.0, Waveform::Sine);

// Gain block (LFO modulates the level)
let gain = builder.add_gain_with_modulation(-6.0, Some(tremolo_lfo));

builder.connect(osc, 0, gain, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<h2 id="lfo-waveforms"><a class="header" href="#lfo-waveforms">LFO Waveforms</a></h2>
<p>Different waveforms create different modulation characters:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Waveform</th><th>Effect</th></tr>
</thead>
<tbody>
<tr><td>Sine</td><td>Smooth, natural modulation</td></tr>
<tr><td>Triangle</td><td>Linear sweep, similar to sine</td></tr>
<tr><td>Square</td><td>Abrupt on/off switching</td></tr>
<tr><td>Saw</td><td>Ramp up, sudden reset</td></tr>
<tr><td>Pulse</td><td>Variable duty cycle switching</td></tr>
</tbody>
</table>
</div>
<h2 id="envelope-generator"><a class="header" href="#envelope-generator">Envelope Generator</a></h2>
<p>ADSR envelopes control how parameters change over time:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Create an ADSR envelope
// Attack, Decay, Sustain (level), Release (all in seconds except sustain)
let envelope = builder.add_envelope(
    0.01,   // Attack: 10ms
    0.1,    // Decay: 100ms
    0.7,    // Sustain: 70%
    0.3,    // Release: 300ms
);
<span class="boring">}</span></code></pre>
<h2 id="combining-modulation-sources"><a class="header" href="#combining-modulation-sources">Combining Modulation Sources</a></h2>
<p>Layer multiple modulation sources:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Slow LFO for overall movement
let slow_lfo = builder.add_lfo(0.5, Waveform::Sine);

// Fast LFO for vibrato
let fast_lfo = builder.add_lfo(5.0, Waveform::Sine);

// Use slow LFO to modulate the fast LFO rate (complex modulation)
// Note: This requires connecting modulation outputs
<span class="boring">}</span></code></pre>
<h2 id="modulation-depth"><a class="header" href="#modulation-depth">Modulation Depth</a></h2>
<p>Control modulation intensity by adjusting the modulator’s output level or the target’s modulation sensitivity:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Subtle vibrato: low-amplitude LFO
let subtle_lfo = builder.add_lfo(5.0, Waveform::Sine);

// The modulation depth is controlled by the LFO's amplitude setting
// and how the receiving block interprets the modulation signal
<span class="boring">}</span></code></pre>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="wobble-bass"><a class="header" href="#wobble-bass">Wobble Bass</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Sub bass oscillator
let osc = builder.add_oscillator(55.0, Waveform::Saw, None);

// Slow LFO for filter wobble (when filter is available)
let wobble_lfo = builder.add_lfo(2.0, Waveform::Sine);

// For now, use amplitude modulation
let gain = builder.add_gain_with_modulation(-6.0, Some(wobble_lfo));

builder.connect(osc, 0, gain, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<h3 id="auto-pan"><a class="header" href="#auto-pan">Auto-Pan</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let osc = builder.add_oscillator(440.0, Waveform::Sine, None);

// LFO for pan position
let pan_lfo = builder.add_lfo(0.25, Waveform::Sine);  // Slow sweep

// Panner with modulation (when supported)
let pan = builder.add_panner_with_modulation(0.0, Some(pan_lfo));

builder.connect(osc, 0, pan, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li><a href="#working-with-audio-files">Working with Audio Files</a> - Apply modulation to file playback</li>
<li><a href="#midi-integration">MIDI Integration</a> - Trigger envelopes with MIDI</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="working-with-audio-files"><a class="header" href="#working-with-audio-files">Working with Audio Files</a></h1>
<p>This tutorial covers reading and writing audio files with bbx_audio.</p>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>Add bbx_file to your project:</p>
<pre><code class="language-toml">[dependencies]
bbx_dsp = "0.1"
bbx_file = "0.1"
</code></pre>
<h2 id="supported-formats"><a class="header" href="#supported-formats">Supported Formats</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Read</th><th>Write</th></tr>
</thead>
<tbody>
<tr><td>WAV</td><td>Yes</td><td>Yes</td></tr>
</tbody>
</table>
</div>
<h2 id="reading-wav-files"><a class="header" href="#reading-wav-files">Reading WAV Files</a></h2>
<h3 id="creating-a-file-reader"><a class="header" href="#creating-a-file-reader">Creating a File Reader</a></h3>
<pre class="playground"><code class="language-rust">use bbx_file::readers::wav::WavFileReader;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let reader = WavFileReader::from_path("audio/sample.wav")?;

    // Get file information
    println!("Sample rate: {}", reader.sample_rate());
    println!("Channels: {}", reader.num_channels());
    println!("Duration: {} seconds", reader.duration_seconds());

    Ok(())
}</code></pre>
<h3 id="using-fileinputblock"><a class="header" href="#using-fileinputblock">Using FileInputBlock</a></h3>
<p>Add a file input to your DSP graph:</p>
<pre class="playground"><code class="language-rust">use bbx_dsp::graph::GraphBuilder;
use bbx_file::readers::wav::WavFileReader;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

    // Create the reader
    let reader = WavFileReader::from_path("audio/sample.wav")?;

    // Add to graph
    let file_input = builder.add_file_input(Box::new(reader));

    // Connect to effects
    let gain = builder.add_gain(-6.0);
    builder.connect(file_input, 0, gain, 0);

    let graph = builder.build();
    Ok(())
}</code></pre>
<h2 id="writing-wav-files"><a class="header" href="#writing-wav-files">Writing WAV Files</a></h2>
<h3 id="creating-a-file-writer"><a class="header" href="#creating-a-file-writer">Creating a File Writer</a></h3>
<pre class="playground"><code class="language-rust">use bbx_file::writers::wav::WavFileWriter;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let writer = WavFileWriter::new(
        "output.wav",
        44100,  // Sample rate
        2,      // Channels
        16,     // Bits per sample
    )?;

    Ok(())
}</code></pre>
<h3 id="using-fileoutputblock"><a class="header" href="#using-fileoutputblock">Using FileOutputBlock</a></h3>
<p>Add a file output to your DSP graph:</p>
<pre class="playground"><code class="language-rust">use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};
use bbx_file::writers::wav::WavFileWriter;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

    // Add oscillator
    let osc = builder.add_oscillator(440.0, Waveform::Sine, None);

    // Create writer
    let writer = WavFileWriter::new("output.wav", 44100, 2, 16)?;

    // Add file output block
    let file_output = builder.add_file_output(Box::new(writer));

    // Connect oscillator to file output
    builder.connect(osc, 0, file_output, 0);

    let mut graph = builder.build();

    // Process and write audio
    let mut left = vec![0.0f32; 512];
    let mut right = vec![0.0f32; 512];

    // Write 5 seconds of audio
    let num_buffers = (5.0 * 44100.0 / 512.0) as usize;
    for _ in 0..num_buffers {
        let mut outputs: [&amp;mut [f32]; 2] = [&amp;mut left, &amp;mut right];
        graph.process_buffers(&amp;mut outputs);
    }

    // Finalize the file
    graph.finalize();

    Ok(())
}</code></pre>
<h2 id="processing-audio-files"><a class="header" href="#processing-audio-files">Processing Audio Files</a></h2>
<p>Combine file input and output for offline processing:</p>
<pre class="playground"><code class="language-rust">use bbx_dsp::graph::GraphBuilder;
use bbx_file::{
    readers::wav::WavFileReader,
    writers::wav::WavFileWriter,
};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Open input file
    let reader = WavFileReader::from_path("input.wav")?;
    let sample_rate = reader.sample_rate();
    let num_channels = reader.num_channels();

    // Create graph
    let mut builder = GraphBuilder::&lt;f32&gt;::new(sample_rate, 512, num_channels);

    // File input
    let file_in = builder.add_file_input(Box::new(reader));

    // Process: add some effects
    let gain = builder.add_gain(-3.0);
    let pan = builder.add_panner(0.25);

    builder.connect(file_in, 0, gain, 0);
    builder.connect(gain, 0, pan, 0);

    // File output
    let writer = WavFileWriter::new("output.wav", sample_rate as u32, num_channels, 16)?;
    let file_out = builder.add_file_output(Box::new(writer));

    builder.connect(pan, 0, file_out, 0);

    let mut graph = builder.build();

    // Process entire file
    let mut outputs = vec![vec![0.0f32; 512]; num_channels];

    loop {
        let mut output_refs: Vec&lt;&amp;mut [f32]&gt; = outputs.iter_mut()
            .map(|v| v.as_mut_slice())
            .collect();

        graph.process_buffers(&amp;mut output_refs);

        // Check if file input is exhausted
        // (implementation depends on your needs)
        break;  // Placeholder
    }

    graph.finalize();
    Ok(())
}</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>Handle common file errors:</p>
<pre class="playground"><code class="language-rust">use bbx_file::readers::wav::WavFileReader;

fn main() {
    match WavFileReader::from_path("nonexistent.wav") {
        Ok(reader) =&gt; {
            println!("Loaded: {} channels, {} Hz",
                reader.num_channels(),
                reader.sample_rate());
        }
        Err(e) =&gt; {
            eprintln!("Failed to load audio file: {}", e);
        }
    }
}</code></pre>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<ol>
<li><strong>Buffer size</strong>: Use larger buffers for file processing (2048+ samples)</li>
<li><strong>Non-blocking I/O</strong>: <code>FileOutputBlock</code> uses non-blocking I/O internally</li>
<li><strong>Memory</strong>: Large files are streamed, not loaded entirely into memory</li>
<li><strong>Finalization</strong>: Always call <code>finalize()</code> to flush buffers and close files</li>
</ol>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li><a href="#midi-integration">MIDI Integration</a> - Control playback with MIDI</li>
<li><a href="#juce-plugin-integration-overview">JUCE Integration</a> - Use in a plugin</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="midi-integration"><a class="header" href="#midi-integration">MIDI Integration</a></h1>
<p>This tutorial covers MIDI message handling with bbx_audio.</p>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<p>Add bbx_midi to your project:</p>
<pre><code class="language-toml">[dependencies]
bbx_midi = "0.1"
</code></pre>
<h2 id="midi-message-types"><a class="header" href="#midi-message-types">MIDI Message Types</a></h2>
<p>bbx_midi supports standard MIDI messages:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Message Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>NoteOn</td><td>Key pressed</td></tr>
<tr><td>NoteOff</td><td>Key released</td></tr>
<tr><td>ControlChange</td><td>CC messages (knobs, sliders)</td></tr>
<tr><td>PitchWheel</td><td>Pitch bend</td></tr>
<tr><td>ProgramChange</td><td>Preset selection</td></tr>
<tr><td>PolyphonicAftertouch</td><td>Per-key pressure</td></tr>
<tr><td>ChannelAftertouch</td><td>Channel-wide pressure</td></tr>
</tbody>
</table>
</div>
<h2 id="parsing-midi-messages"><a class="header" href="#parsing-midi-messages">Parsing MIDI Messages</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_midi::message::{MidiMessage, MidiMessageStatus};

fn handle_midi(data: &amp;[u8]) {
    if let Some(message) = MidiMessage::from_bytes(data) {
        match message.status() {
            MidiMessageStatus::NoteOn =&gt; {
                let note = message.note();
                let velocity = message.velocity();
                println!("Note On: {} vel {}", note, velocity);
            }
            MidiMessageStatus::NoteOff =&gt; {
                let note = message.note();
                println!("Note Off: {}", note);
            }
            MidiMessageStatus::ControlChange =&gt; {
                let cc = message.controller();
                let value = message.value();
                println!("CC {}: {}", cc, value);
            }
            MidiMessageStatus::PitchWheel =&gt; {
                let bend = message.pitch_bend();
                println!("Pitch Bend: {}", bend);
            }
            _ =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="message-buffer"><a class="header" href="#message-buffer">Message Buffer</a></h2>
<p>Use <code>MidiMessageBuffer</code> for real-time message collection:</p>
<pre class="playground"><code class="language-rust">use bbx_midi::buffer::MidiMessageBuffer;
use bbx_midi::message::MidiMessage;

fn main() {
    // Create a buffer with capacity for 128 messages
    let mut buffer = MidiMessageBuffer::new(128);

    // Add messages (typically from MIDI input callback)
    buffer.push(MidiMessage::note_on(0, 60, 100));
    buffer.push(MidiMessage::note_on(0, 64, 100));
    buffer.push(MidiMessage::note_on(0, 67, 100));

    // Process messages
    for message in buffer.iter() {
        println!("{:?}", message);
    }

    // Clear for next audio block
    buffer.clear();
}</code></pre>
<h2 id="midi-to-frequency"><a class="header" href="#midi-to-frequency">MIDI to Frequency</a></h2>
<p>Convert MIDI note numbers to frequency:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn midi_to_freq(note: u8) -&gt; f32 {
    440.0 * 2.0_f32.powf((note as f32 - 69.0) / 12.0)
}

// Examples:
// midi_to_freq(60) = 261.63 Hz (Middle C)
// midi_to_freq(69) = 440.00 Hz (A4)
// midi_to_freq(72) = 523.25 Hz (C5)
<span class="boring">}</span></code></pre>
<h2 id="velocity-scaling"><a class="header" href="#velocity-scaling">Velocity Scaling</a></h2>
<p>Convert velocity to amplitude:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn velocity_to_amplitude(velocity: u8) -&gt; f32 {
    // Linear scaling
    velocity as f32 / 127.0
}

fn velocity_to_amplitude_curve(velocity: u8) -&gt; f32 {
    // Logarithmic curve for more natural response
    let normalized = velocity as f32 / 127.0;
    normalized * normalized  // Square for exponential feel
}
<span class="boring">}</span></code></pre>
<h2 id="simple-midi-synth"><a class="header" href="#simple-midi-synth">Simple MIDI Synth</a></h2>
<p>Combine MIDI with oscillators:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};
use bbx_midi::message::{MidiMessage, MidiMessageStatus};

struct Voice {
    note: u8,
    frequency: f32,
    velocity: f32,
    active: bool,
}

impl Voice {
    fn new() -&gt; Self {
        Self {
            note: 0,
            frequency: 440.0,
            velocity: 0.0,
            active: false,
        }
    }

    fn note_on(&amp;mut self, note: u8, velocity: u8) {
        self.note = note;
        self.frequency = 440.0 * 2.0_f32.powf((note as f32 - 69.0) / 12.0);
        self.velocity = velocity as f32 / 127.0;
        self.active = true;
    }

    fn note_off(&amp;mut self, note: u8) {
        if self.note == note {
            self.active = false;
        }
    }
}

fn process_midi(voice: &amp;mut Voice, message: &amp;MidiMessage) {
    match message.status() {
        MidiMessageStatus::NoteOn =&gt; {
            if message.velocity() &gt; 0 {
                voice.note_on(message.note(), message.velocity());
            } else {
                voice.note_off(message.note());
            }
        }
        MidiMessageStatus::NoteOff =&gt; {
            voice.note_off(message.note());
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre>
<h2 id="control-change-mapping"><a class="header" href="#control-change-mapping">Control Change Mapping</a></h2>
<p>Map CC messages to parameters:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_midi::message::{MidiMessage, MidiMessageStatus};

// Standard CC numbers
const CC_MOD_WHEEL: u8 = 1;
const CC_VOLUME: u8 = 7;
const CC_PAN: u8 = 10;
const CC_EXPRESSION: u8 = 11;
const CC_SUSTAIN: u8 = 64;

struct SynthParams {
    volume: f32,
    pan: f32,
    mod_depth: f32,
    sustain: bool,
}

fn handle_cc(params: &amp;mut SynthParams, message: &amp;MidiMessage) {
    if message.status() != MidiMessageStatus::ControlChange {
        return;
    }

    let cc = message.controller();
    let value = message.value() as f32 / 127.0;

    match cc {
        CC_VOLUME =&gt; params.volume = value,
        CC_PAN =&gt; params.pan = (value * 2.0) - 1.0,  // -1 to +1
        CC_MOD_WHEEL =&gt; params.mod_depth = value,
        CC_SUSTAIN =&gt; params.sustain = message.value() &gt;= 64,
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre>
<h2 id="real-time-midi-input"><a class="header" href="#real-time-midi-input">Real-Time MIDI Input</a></h2>
<p>For real-time MIDI input, use the streaming API:</p>
<pre class="playground"><code class="language-rust">use bbx_midi::stream::MidiInputStream;

fn main() {
    // Create MIDI input stream
    // The callback runs on the MIDI thread
    let stream = MidiInputStream::new(vec![], |message| {
        println!("Received: {:?}", message);
    });

    // Initialize and start listening
    let handle = stream.init();

    // Keep running...
    std::thread::sleep(std::time::Duration::from_secs(60));

    // Clean up
    handle.join().unwrap();
}</code></pre>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li><a href="#juce-plugin-integration-overview">JUCE Integration</a> - Use MIDI in plugins</li>
<li><a href="#dsp-graph-architecture">DSP Graph Architecture</a> - Understand the system</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="juce-plugin-integration-overview"><a class="header" href="#juce-plugin-integration-overview">JUCE Plugin Integration Overview</a></h1>
<p>bbx_audio provides a complete solution for writing audio plugin DSP in Rust while using JUCE for the UI and plugin framework.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<pre><code>JUCE AudioProcessor (C++)
         |
         v
   +-----------+
   | bbx::Graph|  &lt;-- RAII C++ wrapper
   +-----------+
         |
         v  (C FFI calls)
   +------------+
   | bbx_ffi.h  |  &lt;-- Generated C header
   +------------+
         |
         v
   +-------------+
   | PluginGraph |  &lt;-- Your Rust DSP (implements PluginDsp)
   +-------------+
         |
         v
   +------------+
   | DSP Blocks |  &lt;-- Gain, Panner, Filters, etc.
   +------------+
</code></pre>
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<h3 id="rust-side"><a class="header" href="#rust-side">Rust Side</a></h3>
<ul>
<li><strong><code>PluginDsp</code> trait</strong> - Defines the interface your DSP must implement</li>
<li><strong><code>bbx_plugin_ffi!</code> macro</strong> - Generates all C FFI exports automatically</li>
<li><strong>Parameter system</strong> - Define parameters in JSON or Rust, generate indices for both languages</li>
</ul>
<h3 id="c-side"><a class="header" href="#c-side">C++ Side</a></h3>
<ul>
<li><strong><code>bbx_ffi.h</code></strong> - C header with FFI function declarations and error codes</li>
<li><strong><code>bbx_graph.h</code></strong> - Header-only C++ RAII wrapper class</li>
<li><strong>Parameter indices</strong> - Generated <code>#define</code> constants matching Rust indices</li>
</ul>
<h2 id="integration-steps"><a class="header" href="#integration-steps">Integration Steps</a></h2>
<ol>
<li><a href="#project-setup">Project Setup</a> - Create the Rust crate and CMake configuration</li>
<li><a href="#implementing-plugindsp">Implementing PluginDsp</a> - Write your DSP processing chain</li>
<li><a href="#parameter-system">Parameter System</a> - Define and manage plugin parameters</li>
<li><a href="#ffi-integration">FFI Integration</a> - Understand the C FFI layer</li>
<li><a href="#audioprocessor-integration">AudioProcessor Integration</a> - Connect to JUCE</li>
</ol>
<h2 id="benefits"><a class="header" href="#benefits">Benefits</a></h2>
<ul>
<li><strong>Type Safety</strong>: Rust’s type system prevents memory bugs in DSP code</li>
<li><strong>Performance</strong>: Zero-cost abstractions with no runtime overhead</li>
<li><strong>Separation</strong>: Clean boundary between DSP logic and UI/framework code</li>
<li><strong>Testability</strong>: DSP can be tested independently of the plugin framework</li>
<li><strong>Portability</strong>: Same DSP code works with any C++-compatible framework</li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li><strong>Build Complexity</strong>: Requires Rust toolchain in addition to C++ build</li>
<li><strong>Debug Boundaries</strong>: Debugging across FFI requires care</li>
<li><strong>No Hot Reload</strong>: DSP changes require full rebuild and plugin reload</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h1>
<p>This guide walks through setting up a JUCE plugin project with Rust DSP.</p>
<h2 id="directory-structure"><a class="header" href="#directory-structure">Directory Structure</a></h2>
<p>A typical project structure:</p>
<pre><code>my-plugin/
├── CMakeLists.txt
├── dsp/                      # Rust DSP crate
│   ├── Cargo.toml
│   ├── include/
│   │   ├── bbx_ffi.h        # C FFI header
│   │   └── bbx_graph.h      # C++ RAII wrapper
│   └── src/
│       └── lib.rs           # PluginDsp implementation
├── src/                      # JUCE plugin source
│   ├── PluginProcessor.cpp
│   ├── PluginProcessor.h
│   ├── PluginEditor.cpp
│   └── PluginEditor.h
└── vendor/
    └── corrosion/           # Git submodule
</code></pre>
<h2 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h2>
<ol>
<li><strong>Rust toolchain</strong> - Install from <a href="https://rustup.rs">rustup.rs</a></li>
<li><strong>CMake 3.15+</strong> - For building the plugin</li>
<li><strong>JUCE</strong> - Framework for the plugin</li>
<li><strong>Corrosion</strong> - CMake integration for Rust</li>
</ol>
<h3 id="adding-corrosion"><a class="header" href="#adding-corrosion">Adding Corrosion</a></h3>
<p>Add Corrosion as a git submodule:</p>
<pre><code class="language-bash">git submodule add https://github.com/corrosion-rs/corrosion.git vendor/corrosion
</code></pre>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li><a href="#rust-crate-configuration">Rust Crate Configuration</a> - Set up <code>Cargo.toml</code></li>
<li><a href="#cmake-with-corrosion">CMake with Corrosion</a> - Configure the build system</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust-crate-configuration"><a class="header" href="#rust-crate-configuration">Rust Crate Configuration</a></h1>
<p>Configure your Rust crate for FFI integration with JUCE.</p>
<h2 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h2>
<p>Create a <code>dsp/Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "dsp"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["staticlib", "cdylib"]

[dependencies]
bbx_plugin = "0.1"
</code></pre>
<h3 id="crate-types"><a class="header" href="#crate-types">Crate Types</a></h3>
<ul>
<li><strong><code>staticlib</code></strong> - Static library for linking into C++ (recommended)</li>
<li><strong><code>cdylib</code></strong> - Dynamic library (alternative approach)</li>
</ul>
<p>Using <code>staticlib</code> is recommended as it bundles all Rust code into a single library that links cleanly with the plugin.</p>
<h2 id="using-git-dependencies-1"><a class="header" href="#using-git-dependencies-1">Using Git Dependencies</a></h2>
<p>For the latest development version:</p>
<pre><code class="language-toml">[dependencies]
bbx_plugin = { git = "https://github.com/blackboxaudio/bbx_audio" }
</code></pre>
<h2 id="librs-structure"><a class="header" href="#librs-structure">lib.rs Structure</a></h2>
<p>Your <code>dsp/src/lib.rs</code> should:</p>
<ol>
<li>Import the necessary types</li>
<li>Define your DSP struct</li>
<li>Implement <code>PluginDsp</code></li>
<li>Call the FFI macro</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::{PluginDsp, DspContext, bbx_plugin_ffi};

pub struct PluginGraph {
    // Your DSP blocks
}

impl Default for PluginGraph {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl PluginDsp for PluginGraph {
    fn new() -&gt; Self {
        PluginGraph {
            // Initialize blocks
        }
    }

    fn prepare(&amp;mut self, context: &amp;DspContext) {
        // Called when audio specs change
    }

    fn reset(&amp;mut self) {
        // Clear DSP state
    }

    fn apply_parameters(&amp;mut self, params: &amp;[f32]) {
        // Map parameter values to blocks
    }

    fn process(
        &amp;mut self,
        inputs: &amp;[&amp;[f32]],
        outputs: &amp;mut [&amp;mut [f32]],
        context: &amp;DspContext,
    ) {
        // Process audio
    }
}

// Generate FFI exports
bbx_plugin_ffi!(PluginGraph);
<span class="boring">}</span></code></pre>
<h2 id="ffi-headers"><a class="header" href="#ffi-headers">FFI Headers</a></h2>
<p>Copy the following headers to <code>dsp/include/</code>:</p>
<ul>
<li><code>bbx_ffi.h</code> - From <code>bbx_plugin/include/bbx_ffi.h</code></li>
<li><code>bbx_graph.h</code> - From <code>bbx_plugin/include/bbx_graph.h</code></li>
</ul>
<p>These headers provide the C and C++ interfaces for your JUCE code.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cmake-with-corrosion"><a class="header" href="#cmake-with-corrosion">CMake with Corrosion</a></h1>
<p>Configure CMake to build and link your Rust DSP crate.</p>
<h2 id="cmakeliststxt"><a class="header" href="#cmakeliststxt">CMakeLists.txt</a></h2>
<p>Add these sections to your plugin’s <code>CMakeLists.txt</code>:</p>
<pre><code class="language-cmake"># Add Corrosion for Rust integration
add_subdirectory(vendor/corrosion)

# Import the Rust crate
corrosion_import_crate(MANIFEST_PATH dsp/Cargo.toml)

# Your plugin target (created by JUCE's juce_add_plugin)
# Replace ${PLUGIN_TARGET} with your actual target name

# Include the FFI headers
target_include_directories(${PLUGIN_TARGET} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/dsp/include)

# Link the Rust library
target_link_libraries(${PLUGIN_TARGET} PRIVATE dsp)
</code></pre>
<h2 id="full-example"><a class="header" href="#full-example">Full Example</a></h2>
<p>A complete <code>CMakeLists.txt</code> example:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.15)
project(MyPlugin VERSION 1.0.0)

# Add JUCE (adjust path as needed)
add_subdirectory(JUCE)

# Add Corrosion
add_subdirectory(vendor/corrosion)

# Import Rust crate
corrosion_import_crate(MANIFEST_PATH dsp/Cargo.toml)

# Define the plugin
juce_add_plugin(MyPlugin
    PLUGIN_MANUFACTURER_CODE Mfr1
    PLUGIN_CODE Plg1
    FORMATS AU VST3 Standalone
    PRODUCT_NAME "My Plugin")

# Add JUCE modules
target_link_libraries(MyPlugin PRIVATE
    juce::juce_audio_processors
    juce::juce_audio_utils)

# Include FFI headers
target_include_directories(MyPlugin PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/dsp/include)

# Link Rust library
target_link_libraries(MyPlugin PRIVATE dsp)
</code></pre>
<h2 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h2>
<h3 id="macos-1"><a class="header" href="#macos-1">macOS</a></h3>
<p>No additional configuration needed. Corrosion handles universal binary creation.</p>
<h3 id="windows-1"><a class="header" href="#windows-1">Windows</a></h3>
<p>Ensure Rust is in your PATH. You may need to specify the MSVC toolchain:</p>
<pre><code class="language-bash">rustup default stable-msvc
</code></pre>
<h3 id="linux-2"><a class="header" href="#linux-2">Linux</a></h3>
<p>Install required development packages:</p>
<pre><code class="language-bash">sudo apt install alsa libasound2-dev
</code></pre>
<h2 id="build-commands"><a class="header" href="#build-commands">Build Commands</a></h2>
<pre><code class="language-bash"># Configure
cmake -B build -DCMAKE_BUILD_TYPE=Release

# Build
cmake --build build --config Release
</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="cannot-find--ldsp"><a class="header" href="#cannot-find--ldsp">“Cannot find -ldsp”</a></h3>
<p>Ensure Corrosion successfully built the Rust crate. Check <code>build/cargo/</code> for build artifacts.</p>
<h3 id="linking-errors"><a class="header" href="#linking-errors">Linking Errors</a></h3>
<p>Verify the crate type in <code>Cargo.toml</code> is set to <code>staticlib</code>:</p>
<pre><code class="language-toml">[lib]
crate-type = ["staticlib"]
</code></pre>
<h3 id="header-not-found"><a class="header" href="#header-not-found">Header Not Found</a></h3>
<p>Check that <code>target_include_directories</code> points to the correct path containing <code>bbx_ffi.h</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implementing-plugindsp"><a class="header" href="#implementing-plugindsp">Implementing PluginDsp</a></h1>
<p>The <code>PluginDsp</code> trait defines the interface between your Rust DSP code and the FFI layer.</p>
<h2 id="the-plugindsp-trait"><a class="header" href="#the-plugindsp-trait">The PluginDsp Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PluginDsp: Default + Send + 'static {
    fn new() -&gt; Self;
    fn prepare(&amp;mut self, context: &amp;DspContext);
    fn reset(&amp;mut self);
    fn apply_parameters(&amp;mut self, params: &amp;[f32]);
    fn process(&amp;mut self, inputs: &amp;[&amp;[f32]], outputs: &amp;mut [&amp;mut [f32]], context: &amp;DspContext);
}
<span class="boring">}</span></code></pre>
<h2 id="trait-bounds"><a class="header" href="#trait-bounds">Trait Bounds</a></h2>
<ul>
<li><strong><code>Default</code></strong> - Required for the FFI layer to create instances</li>
<li><strong><code>Send</code></strong> - Allows transfer between threads (audio thread)</li>
<li><strong><code>'static</code></strong> - No borrowed references (owned data only)</li>
</ul>
<h2 id="method-reference"><a class="header" href="#method-reference">Method Reference</a></h2>
<h3 id="new"><a class="header" href="#new">new()</a></h3>
<p>Create a new instance with default configuration.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new() -&gt; Self {
    Self {
        gain: GainBlock::new(0.0),
        panner: PannerBlock::new(0.0),
    }
}
<span class="boring">}</span></code></pre>
<h3 id="prepare"><a class="header" href="#prepare">prepare()</a></h3>
<p>Called when audio specifications change. Initialize blocks with the new context.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prepare(&amp;mut self, context: &amp;DspContext) {
    // context.sample_rate - Sample rate in Hz
    // context.buffer_size - Samples per buffer
    // context.num_channels - Number of channels

    self.gain.prepare(context);
    self.panner.prepare(context);
}
<span class="boring">}</span></code></pre>
<h3 id="reset"><a class="header" href="#reset">reset()</a></h3>
<p>Clear all DSP state (filter histories, delay lines, oscillator phases).</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reset(&amp;mut self) {
    self.gain.reset();
    self.panner.reset();
}
<span class="boring">}</span></code></pre>
<h3 id="apply_parameters"><a class="header" href="#apply_parameters">apply_parameters()</a></h3>
<p>Map the flat parameter array to your DSP blocks.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_parameters(&amp;mut self, params: &amp;[f32]) {
    // Use generated constants for indices
    self.gain.level_db = params[PARAM_GAIN];
    self.panner.position = params[PARAM_PAN];
}
<span class="boring">}</span></code></pre>
<h3 id="process"><a class="header" href="#process">process()</a></h3>
<p>Process audio through your DSP chain.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process(
    &amp;mut self,
    inputs: &amp;[&amp;[f32]],
    outputs: &amp;mut [&amp;mut [f32]],
    context: &amp;DspContext,
) {
    // inputs[channel][sample] - Input audio
    // outputs[channel][sample] - Output audio (write here)

    // Example: copy input to output with gain
    for ch in 0..context.num_channels {
        for i in 0..context.buffer_size {
            outputs[ch][i] = inputs[ch][i] * self.gain.multiplier();
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::{PluginDsp, DspContext, bbx_plugin_ffi};
use bbx_plugin::blocks::{GainBlock, PannerBlock, DcBlockerBlock};

// Parameter indices (generated or manual)
const PARAM_GAIN: usize = 0;
const PARAM_PAN: usize = 1;
const PARAM_DC_BLOCK: usize = 2;

pub struct PluginGraph {
    gain: GainBlock&lt;f32&gt;,
    panner: PannerBlock&lt;f32&gt;,
    dc_blocker: DcBlockerBlock&lt;f32&gt;,
    dc_block_enabled: bool,
}

impl Default for PluginGraph {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl PluginDsp for PluginGraph {
    fn new() -&gt; Self {
        Self {
            gain: GainBlock::new(0.0),
            panner: PannerBlock::new(0.0),
            dc_blocker: DcBlockerBlock::new(),
            dc_block_enabled: false,
        }
    }

    fn prepare(&amp;mut self, context: &amp;DspContext) {
        self.dc_blocker.prepare(context);
    }

    fn reset(&amp;mut self) {
        self.dc_blocker.reset();
    }

    fn apply_parameters(&amp;mut self, params: &amp;[f32]) {
        self.gain.level_db = params[PARAM_GAIN];
        self.panner.position = params[PARAM_PAN];
        self.dc_block_enabled = params[PARAM_DC_BLOCK] &gt; 0.5;
    }

    fn process(
        &amp;mut self,
        inputs: &amp;[&amp;[f32]],
        outputs: &amp;mut [&amp;mut [f32]],
        context: &amp;DspContext,
    ) {
        let num_channels = context.num_channels.min(inputs.len()).min(outputs.len());
        let num_samples = context.buffer_size;

        for ch in 0..num_channels {
            for i in 0..num_samples {
                let mut sample = inputs[ch][i];

                // Apply gain
                sample *= self.gain.multiplier();

                // Apply DC blocker if enabled
                if self.dc_block_enabled {
                    sample = self.dc_blocker.process_sample(sample, ch);
                }

                outputs[ch][i] = sample;
            }
        }

        // Apply panning (modifies stereo field)
        self.panner.process_stereo(outputs, num_samples);
    }
}

// Generate FFI exports
bbx_plugin_ffi!(PluginGraph);
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="parameter-system"><a class="header" href="#parameter-system">Parameter System</a></h1>
<p>bbx_audio provides two approaches for defining plugin parameters, both capable of generating code for Rust and C++.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Parameters are passed from C++ to Rust as a flat <code>float</code> array. You need a consistent way to map array indices to parameter meanings on both sides of the FFI boundary.</p>
<pre><code>C++ (JUCE)                    Rust (bbx_plugin)
-----------                   ------------------
params[0] = gainValue    --&gt;  params[PARAM_GAIN]
params[1] = panValue     --&gt;  params[PARAM_PAN]
</code></pre>
<h2 id="two-approaches"><a class="header" href="#two-approaches">Two Approaches</a></h2>
<h3 id="1-json-based-recommended"><a class="header" href="#1-json-based-recommended">1. JSON-Based (Recommended)</a></h3>
<p>Define parameters in a <code>parameters.json</code> file. This is ideal when:</p>
<ul>
<li>Your DAW/framework also reads parameter definitions</li>
<li>You want a single source of truth</li>
<li>Parameters are configured at build time</li>
</ul>
<p>See <a href="#parametersjson-format">parameters.json Format</a> for details.</p>
<h3 id="2-programmatic"><a class="header" href="#2-programmatic">2. Programmatic</a></h3>
<p>Define parameters as Rust <code>const</code> arrays. This is ideal when:</p>
<ul>
<li>Parameters are known at compile time</li>
<li>You want maximum compile-time verification</li>
<li>JSON parsing is unnecessary</li>
</ul>
<p>See <a href="#programmatic-parameter-definition">Programmatic Definition</a> for details.</p>
<h2 id="code-generation"><a class="header" href="#code-generation">Code Generation</a></h2>
<p>Both approaches can generate:</p>
<ul>
<li><strong>Rust constants</strong>: <code>pub const PARAM_GAIN: usize = 0;</code></li>
<li><strong>C header defines</strong>: <code>#define PARAM_GAIN 0</code></li>
</ul>
<p>See <a href="#parameter-code-generation">Code Generation</a> for integration details.</p>
<h2 id="parameter-types"><a class="header" href="#parameter-types">Parameter Types</a></h2>
<p>Both approaches support these parameter types:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th><th>Value Range</th></tr>
</thead>
<tbody>
<tr><td><code>boolean</code></td><td>On/off toggle</td><td>0.0 = off, 1.0 = on</td></tr>
<tr><td><code>float</code></td><td>Continuous value</td><td>min to max</td></tr>
<tr><td><code>choice</code></td><td>Discrete options</td><td>0.0, 1.0, 2.0, …</td></tr>
</tbody>
</table>
</div>
<h2 id="accessing-parameters-in-rust"><a class="header" href="#accessing-parameters-in-rust">Accessing Parameters in Rust</a></h2>
<p>In your <code>apply_parameters()</code> method:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_parameters(&amp;mut self, params: &amp;[f32]) {
    // Boolean: compare to 0.5
    self.mono_enabled = params[PARAM_MONO] &gt; 0.5;

    // Float: use directly
    self.gain.level_db = params[PARAM_GAIN];

    // Choice: convert to integer
    let mode = params[PARAM_MODE] as usize;
    self.routing_mode = match mode {
        0 =&gt; RoutingMode::Stereo,
        1 =&gt; RoutingMode::Left,
        2 =&gt; RoutingMode::Right,
        _ =&gt; RoutingMode::Stereo,
    };
}
<span class="boring">}</span></code></pre>
<h2 id="passing-parameters-from-juce"><a class="header" href="#passing-parameters-from-juce">Passing Parameters from JUCE</a></h2>
<p>In your <code>processBlock()</code>:</p>
<pre><code class="language-cpp">// Gather current parameter values
m_paramBuffer[PARAM_GAIN] = *gainParam;
m_paramBuffer[PARAM_PAN] = *panParam;
m_paramBuffer[PARAM_MONO] = *monoParam ? 1.0f : 0.0f;

// Pass to Rust DSP
m_rustDsp.Process(
    inputs, outputs,
    numChannels, numSamples,
    m_paramBuffer.data(),
    static_cast&lt;uint32_t&gt;(m_paramBuffer.size()));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="parametersjson-format"><a class="header" href="#parametersjson-format">parameters.json Format</a></h1>
<p>Define plugin parameters in a JSON file for cross-language code generation.</p>
<h2 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h2>
<pre><code class="language-json">{
  "parameters": [
    {
      "id": "GAIN",
      "name": "Gain",
      "type": "float",
      "min": -60.0,
      "max": 30.0,
      "defaultValue": 0.0,
      "unit": "dB"
    },
    {
      "id": "PAN",
      "name": "Pan",
      "type": "float",
      "min": -100.0,
      "max": 100.0,
      "defaultValue": 0.0
    },
    {
      "id": "MONO",
      "name": "Mono",
      "type": "boolean",
      "defaultValue": false
    },
    {
      "id": "MODE",
      "name": "Routing Mode",
      "type": "choice",
      "choices": ["Stereo", "Left", "Right", "Swap"],
      "defaultValueIndex": 0
    }
  ]
}
</code></pre>
<h2 id="field-reference"><a class="header" href="#field-reference">Field Reference</a></h2>
<h3 id="required-fields"><a class="header" href="#required-fields">Required Fields</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>id</code></td><td>string</td><td>Parameter identifier (uppercase, used in code generation)</td></tr>
<tr><td><code>name</code></td><td>string</td><td>Display name for UI</td></tr>
<tr><td><code>type</code></td><td>string</td><td><code>"boolean"</code>, <code>"float"</code>, or <code>"choice"</code></td></tr>
</tbody>
</table>
</div>
<h3 id="boolean-parameters"><a class="header" href="#boolean-parameters">Boolean Parameters</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>defaultValue</code></td><td>boolean</td><td>Default state (<code>true</code> or <code>false</code>)</td></tr>
</tbody>
</table>
</div>
<h3 id="float-parameters"><a class="header" href="#float-parameters">Float Parameters</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>min</code></td><td>number</td><td>Minimum value</td></tr>
<tr><td><code>max</code></td><td>number</td><td>Maximum value</td></tr>
<tr><td><code>defaultValue</code></td><td>number</td><td>Default value</td></tr>
<tr><td><code>unit</code></td><td>string</td><td>Optional unit label (e.g., “dB”, “Hz”, “%”)</td></tr>
<tr><td><code>midpoint</code></td><td>number</td><td>Optional midpoint for skewed ranges</td></tr>
<tr><td><code>interval</code></td><td>number</td><td>Optional step interval</td></tr>
<tr><td><code>fractionDigits</code></td><td>integer</td><td>Optional decimal places to display</td></tr>
</tbody>
</table>
</div>
<h3 id="choice-parameters"><a class="header" href="#choice-parameters">Choice Parameters</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>choices</code></td><td>string[]</td><td>Array of option labels</td></tr>
<tr><td><code>defaultValueIndex</code></td><td>integer</td><td>Index of default choice (0-based)</td></tr>
</tbody>
</table>
</div>
<h2 id="complete-example-2"><a class="header" href="#complete-example-2">Complete Example</a></h2>
<pre><code class="language-json">{
  "parameters": [
    {
      "id": "INVERT_LEFT",
      "name": "Invert Left",
      "type": "boolean",
      "defaultValue": false
    },
    {
      "id": "INVERT_RIGHT",
      "name": "Invert Right",
      "type": "boolean",
      "defaultValue": false
    },
    {
      "id": "CHANNEL_MODE",
      "name": "Channel Mode",
      "type": "choice",
      "choices": ["Stereo", "Left", "Right", "Swap"],
      "defaultValueIndex": 0
    },
    {
      "id": "MONO",
      "name": "Sum to Mono",
      "type": "boolean",
      "defaultValue": false
    },
    {
      "id": "GAIN",
      "name": "Gain",
      "type": "float",
      "min": -60.0,
      "max": 30.0,
      "defaultValue": 0.0,
      "unit": "dB",
      "fractionDigits": 1
    },
    {
      "id": "PAN",
      "name": "Pan",
      "type": "float",
      "min": -100.0,
      "max": 100.0,
      "defaultValue": 0.0,
      "interval": 1.0
    },
    {
      "id": "DC_OFFSET",
      "name": "DC Offset Removal",
      "type": "boolean",
      "defaultValue": false
    }
  ]
}
</code></pre>
<h2 id="parsing-in-rust"><a class="header" href="#parsing-in-rust">Parsing in Rust</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::ParamsFile;

fn load_parameters() -&gt; ParamsFile {
    let json = include_str!("../parameters.json");
    ParamsFile::from_json(json).expect("Failed to parse parameters.json")
}
<span class="boring">}</span></code></pre>
<h2 id="generated-output"><a class="header" href="#generated-output">Generated Output</a></h2>
<p>From the above JSON, code generation produces:</p>
<p><strong>Rust:</strong></p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const PARAM_INVERT_LEFT: usize = 0;
pub const PARAM_INVERT_RIGHT: usize = 1;
pub const PARAM_CHANNEL_MODE: usize = 2;
pub const PARAM_MONO: usize = 3;
pub const PARAM_GAIN: usize = 4;
pub const PARAM_PAN: usize = 5;
pub const PARAM_DC_OFFSET: usize = 6;
pub const PARAM_COUNT: usize = 7;
<span class="boring">}</span></code></pre>
<p><strong>C Header:</strong></p>
<pre><code class="language-c">#define PARAM_INVERT_LEFT 0
#define PARAM_INVERT_RIGHT 1
#define PARAM_CHANNEL_MODE 2
#define PARAM_MONO 3
#define PARAM_GAIN 4
#define PARAM_PAN 5
#define PARAM_DC_OFFSET 6
#define PARAM_COUNT 7
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="programmatic-parameter-definition"><a class="header" href="#programmatic-parameter-definition">Programmatic Parameter Definition</a></h1>
<p>Define parameters as Rust <code>const</code> arrays for compile-time verification.</p>
<h2 id="defining-parameters"><a class="header" href="#defining-parameters">Defining Parameters</a></h2>
<p>Use <code>ParamDef</code> constructors to define parameters:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::{ParamDef, ParamType};

const PARAMETERS: &amp;[ParamDef] = &amp;[
    ParamDef::float("GAIN", "Gain", -60.0, 30.0, 0.0),
    ParamDef::float("PAN", "Pan", -100.0, 100.0, 0.0),
    ParamDef::bool("MONO", "Mono", false),
    ParamDef::choice("MODE", "Mode", &amp;["Stereo", "Left", "Right"], 0),
];
<span class="boring">}</span></code></pre>
<h2 id="paramdef-constructors"><a class="header" href="#paramdef-constructors">ParamDef Constructors</a></h2>
<h3 id="boolean"><a class="header" href="#boolean">Boolean</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ParamDef::bool(id, name, default)
<span class="boring">}</span></code></pre>
<ul>
<li><code>id</code> - Parameter identifier (e.g., <code>"MONO"</code>)</li>
<li><code>name</code> - Display name (e.g., <code>"Mono"</code>)</li>
<li><code>default</code> - Default value (<code>true</code> or <code>false</code>)</li>
</ul>
<h3 id="float"><a class="header" href="#float">Float</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ParamDef::float(id, name, min, max, default)
<span class="boring">}</span></code></pre>
<ul>
<li><code>id</code> - Parameter identifier</li>
<li><code>name</code> - Display name</li>
<li><code>min</code> - Minimum value</li>
<li><code>max</code> - Maximum value</li>
<li><code>default</code> - Default value</li>
</ul>
<h3 id="choice"><a class="header" href="#choice">Choice</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ParamDef::choice(id, name, choices, default_index)
<span class="boring">}</span></code></pre>
<ul>
<li><code>id</code> - Parameter identifier</li>
<li><code>name</code> - Display name</li>
<li><code>choices</code> - Static slice of option labels</li>
<li><code>default_index</code> - Index of default choice</li>
</ul>
<h2 id="paramtype-enum"><a class="header" href="#paramtype-enum">ParamType Enum</a></h2>
<p>For more control, use <code>ParamType</code> directly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::{ParamDef, ParamType};

const CUSTOM_PARAM: ParamDef = ParamDef {
    id: "FREQ",
    name: "Frequency",
    param_type: ParamType::Float {
        min: 20.0,
        max: 20000.0,
        default: 440.0,
    },
};
<span class="boring">}</span></code></pre>
<h2 id="generating-code"><a class="header" href="#generating-code">Generating Code</a></h2>
<p>Generate Rust constants:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::generate_rust_indices_from_defs;

let rust_code = generate_rust_indices_from_defs(PARAMETERS);
// Output:
// pub const PARAM_GAIN: usize = 0;
// pub const PARAM_PAN: usize = 1;
// pub const PARAM_MONO: usize = 2;
// pub const PARAM_MODE: usize = 3;
// pub const PARAM_COUNT: usize = 4;
<span class="boring">}</span></code></pre>
<p>Generate C header:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::generate_c_header_from_defs;

let c_header = generate_c_header_from_defs(PARAMETERS);
// Output:
// #define PARAM_GAIN 0
// #define PARAM_PAN 1
// #define PARAM_MONO 2
// #define PARAM_MODE 3
// #define PARAM_COUNT 4
<span class="boring">}</span></code></pre>
<h2 id="manual-constants"><a class="header" href="#manual-constants">Manual Constants</a></h2>
<p>For simple cases, you can define constants manually:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manual parameter indices
pub const PARAM_GAIN: usize = 0;
pub const PARAM_PAN: usize = 1;
pub const PARAM_MONO: usize = 2;
pub const PARAM_COUNT: usize = 3;
<span class="boring">}</span></code></pre>
<p>And corresponding C header:</p>
<pre><code class="language-c">#define PARAM_GAIN 0
#define PARAM_PAN 1
#define PARAM_MONO 2
#define PARAM_COUNT 3
</code></pre>
<p>This approach is simpler but requires manual synchronization between Rust and C++.</p>
<h2 id="when-to-use-programmatic-definition"><a class="header" href="#when-to-use-programmatic-definition">When to Use Programmatic Definition</a></h2>
<ul>
<li>Parameters are fixed at compile time</li>
<li>No need for JSON parsing overhead</li>
<li>Maximum type safety and compile-time checks</li>
<li>Simple plugins with few parameters</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="parameter-code-generation"><a class="header" href="#parameter-code-generation">Parameter Code Generation</a></h1>
<p>Generate consistent parameter indices for Rust and C++ from a single source.</p>
<h2 id="build-script-integration"><a class="header" href="#build-script-integration">Build Script Integration</a></h2>
<p>The recommended approach is to generate code at build time using a <code>build.rs</code> script.</p>
<h3 id="using-parametersjson"><a class="header" href="#using-parametersjson">Using parameters.json</a></h3>
<pre class="playground"><code class="language-rust">// build.rs
use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();

    // Read parameters.json
    let json = fs::read_to_string("parameters.json")
        .expect("Failed to read parameters.json");

    let params: serde_json::Value = serde_json::from_str(&amp;json)
        .expect("Failed to parse parameters.json");

    // Generate Rust constants
    let mut rust_code = String::from("// Auto-generated - DO NOT EDIT\n\n");
    if let Some(parameters) = params["parameters"].as_array() {
        for (index, param) in parameters.iter().enumerate() {
            let id = param["id"].as_str().unwrap();
            rust_code.push_str(&amp;format!("pub const PARAM_{}: usize = {};\n", id, index));
        }
        rust_code.push_str(&amp;format!("\npub const PARAM_COUNT: usize = {};\n", parameters.len()));
    }

    // Write to OUT_DIR
    let dest_path = Path::new(&amp;out_dir).join("params.rs");
    fs::write(&amp;dest_path, rust_code).unwrap();

    // Generate C header (prefer using ParamsFile API instead - see below)
    let mut c_header = String::from("/* Auto-generated - DO NOT EDIT */\n\n");
    c_header.push_str("#ifndef BBX_PARAMS_H\n#define BBX_PARAMS_H\n\n");
    if let Some(parameters) = params["parameters"].as_array() {
        for (index, param) in parameters.iter().enumerate() {
            let id = param["id"].as_str().unwrap();
            c_header.push_str(&amp;format!("#define PARAM_{} {}\n", id, index));
        }
        c_header.push_str(&amp;format!("\n#define PARAM_COUNT {}\n\n", parameters.len()));

        // Generate PARAM_IDS array for dynamic iteration
        c_header.push_str("static const char* PARAM_IDS[PARAM_COUNT] = {\n");
        for (i, param) in parameters.iter().enumerate() {
            let id = param["id"].as_str().unwrap();
            let comma = if i &lt; parameters.len() - 1 { "," } else { "" };
            c_header.push_str(&amp;format!("    \"{}\"{}\n", id, comma));
        }
        c_header.push_str("};\n");
    }
    c_header.push_str("\n#endif /* BBX_PARAMS_H */\n");

    // Write to include directory
    fs::write("include/bbx_params.h", c_header).unwrap();

    println!("cargo:rerun-if-changed=parameters.json");
}</code></pre>
<h3 id="including-generated-code"><a class="header" href="#including-generated-code">Including Generated Code</a></h3>
<p>In your <code>lib.rs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Include the generated parameter constants
include!(concat!(env!("OUT_DIR"), "/params.rs"));
<span class="boring">}</span></code></pre>
<h3 id="using-paramsfile-api"><a class="header" href="#using-paramsfile-api">Using ParamsFile API</a></h3>
<p>Alternatively, use the built-in API:</p>
<pre class="playground"><code class="language-rust">// build.rs
use bbx_plugin::ParamsFile;
use std::fs;

fn main() {
    let json = fs::read_to_string("parameters.json").unwrap();
    let params = ParamsFile::from_json(&amp;json).unwrap();

    // Generate Rust code
    let rust_code = params.generate_rust_indices();
    fs::write(format!("{}/params.rs", std::env::var("OUT_DIR").unwrap()), rust_code).unwrap();

    // Generate C header
    let c_header = params.generate_c_header();
    fs::write("include/bbx_params.h", c_header).unwrap();

    println!("cargo:rerun-if-changed=parameters.json");
}</code></pre>
<h2 id="using-programmatic-definitions"><a class="header" href="#using-programmatic-definitions">Using Programmatic Definitions</a></h2>
<p>For compile-time definitions:</p>
<pre class="playground"><code class="language-rust">// build.rs
use bbx_plugin::{ParamDef, generate_rust_indices_from_defs, generate_c_header_from_defs};
use std::fs;

const PARAMETERS: &amp;[ParamDef] = &amp;[
    ParamDef::float("GAIN", "Gain", -60.0, 30.0, 0.0),
    ParamDef::bool("MONO", "Mono", false),
];

fn main() {
    let rust_code = generate_rust_indices_from_defs(PARAMETERS);
    fs::write(format!("{}/params.rs", std::env::var("OUT_DIR").unwrap()), rust_code).unwrap();

    let c_header = generate_c_header_from_defs(PARAMETERS);
    fs::write("include/bbx_params.h", c_header).unwrap();
}</code></pre>
<h2 id="cmake-integration"><a class="header" href="#cmake-integration">CMake Integration</a></h2>
<p>Include the generated header in CMake:</p>
<pre><code class="language-cmake"># Ensure Rust build runs first (Corrosion handles this)
corrosion_import_crate(MANIFEST_PATH dsp/Cargo.toml)

# Include the generated header directory
target_include_directories(${PLUGIN_TARGET} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/dsp/include)
</code></pre>
<h2 id="using-param_ids-in-c"><a class="header" href="#using-param_ids-in-c">Using PARAM_IDS in C++</a></h2>
<p>The generated header includes a <code>PARAM_IDS</code> array for dynamic parameter iteration:</p>
<pre><code class="language-cpp">// Generated header contains:
// static const char* PARAM_IDS[PARAM_COUNT] = { "GAIN", "MONO", ... };
</code></pre>
<h3 id="caching-parameter-pointers"><a class="header" href="#caching-parameter-pointers">Caching Parameter Pointers</a></h3>
<p>Cache atomic pointers once in the constructor:</p>
<pre><code class="language-cpp">// In processor.h
std::array&lt;std::atomic&lt;float&gt;*, PARAM_COUNT&gt; m_paramPointers {};

// In processor.cpp constructor
for (size_t i = 0; i &lt; PARAM_COUNT; ++i) {
    m_paramPointers[i] = m_parameters.getRawParameterValue(juce::String(PARAM_IDS[i]));
}
</code></pre>
<h3 id="loading-parameters-in-processblock"><a class="header" href="#loading-parameters-in-processblock">Loading Parameters in processBlock</a></h3>
<p>Replace manual per-parameter loading with a loop:</p>
<pre><code class="language-cpp">// Instead of:
// auto* gain = m_parameters.getRawParameterValue("GAIN");
// m_paramBuffer[PARAM_GAIN] = gain ? gain-&gt;load() : 0.0f;
// ... repeated for each parameter

// Use:
for (size_t i = 0; i &lt; PARAM_COUNT; ++i) {
    m_paramBuffer[i] = m_paramPointers[i] ? m_paramPointers[i]-&gt;load() : 0.0f;
}
</code></pre>
<p>This eliminates manual C++ updates when adding parameters.</p>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>Add a test to verify Rust and C++ constants match:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_param_indices_match() {
    // If this compiles, indices are in sync
    assert_eq!(PARAM_COUNT, 7);
    assert!(PARAM_GAIN &lt; PARAM_COUNT);
    assert!(PARAM_PAN &lt; PARAM_COUNT);
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ffi-integration"><a class="header" href="#ffi-integration">FFI Integration</a></h1>
<p>The FFI (Foreign Function Interface) layer bridges Rust DSP code with C++ JUCE code.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>bbx_audio uses a C FFI for maximum compatibility:</p>
<pre><code>Rust                     C FFI                    C++
-----                    -----                    ---
PluginDsp impl    --&gt;    bbx_ffi.h    --&gt;    bbx::Graph wrapper
</code></pre>
<h2 id="key-components-1"><a class="header" href="#key-components-1">Key Components</a></h2>
<h3 id="rust-side-1"><a class="header" href="#rust-side-1">Rust Side</a></h3>
<ul>
<li><strong><code>bbx_plugin_ffi!</code> macro</strong> - Generates all FFI exports</li>
<li><strong><code>BbxGraph</code> handle</strong> - Opaque pointer type for C</li>
<li><strong><code>BbxError</code> enum</strong> - Error codes for FFI returns</li>
</ul>
<h3 id="cc-side"><a class="header" href="#cc-side">C/C++ Side</a></h3>
<ul>
<li><strong><code>bbx_ffi.h</code></strong> - C header with function declarations</li>
<li><strong><code>bbx_graph.h</code></strong> - C++ RAII wrapper class</li>
</ul>
<h2 id="generated-functions"><a class="header" href="#generated-functions">Generated Functions</a></h2>
<p>The <code>bbx_plugin_ffi!</code> macro generates these extern “C” functions:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>bbx_graph_create()</code></td><td>Allocate and return a new DSP handle</td></tr>
<tr><td><code>bbx_graph_destroy()</code></td><td>Free the DSP handle and its resources</td></tr>
<tr><td><code>bbx_graph_prepare()</code></td><td>Initialize for given sample rate/buffer size</td></tr>
<tr><td><code>bbx_graph_reset()</code></td><td>Clear all DSP state</td></tr>
<tr><td><code>bbx_graph_process()</code></td><td>Process a block of audio</td></tr>
</tbody>
</table>
</div>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>FFI functions return <code>BbxError</code> codes:</p>
<pre><code class="language-c">typedef enum BbxError {
    BBX_ERROR_OK = 0,
    BBX_ERROR_NULL_POINTER = 1,
    BBX_ERROR_INVALID_PARAMETER = 2,
    BBX_ERROR_INVALID_BUFFER_SIZE = 3,
    BBX_ERROR_GRAPH_NOT_PREPARED = 4,
    BBX_ERROR_ALLOCATION_FAILED = 5,
} BbxError;
</code></pre>
<p>Check return values in C++:</p>
<pre><code class="language-cpp">BbxError err = bbx_graph_prepare(handle, sampleRate, bufferSize, numChannels);
if (err != BBX_ERROR_OK) {
    // Handle error
}
</code></pre>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<ul>
<li><strong>Allocation</strong>: <code>bbx_graph_create()</code> allocates Rust memory</li>
<li><strong>Ownership</strong>: The handle owns the Rust struct</li>
<li><strong>Deallocation</strong>: <code>bbx_graph_destroy()</code> frees all Rust memory</li>
<li><strong>Null Safety</strong>: Functions are safe to call with NULL handles</li>
</ul>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<ul>
<li>The DSP handle is <code>Send</code> (can be transferred between threads)</li>
<li>Audio processing is single-threaded (call from audio thread only)</li>
<li>Do not share handles between threads without synchronization</li>
</ul>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="#c-ffi-header-reference">C FFI Header Reference</a> - Complete <code>bbx_ffi.h</code> documentation</li>
<li><a href="#c-raii-wrapper">C++ RAII Wrapper</a> - Using <code>bbx::Graph</code> in JUCE</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="c-ffi-header-reference"><a class="header" href="#c-ffi-header-reference">C FFI Header Reference</a></h1>
<p>Complete reference for <code>bbx_ffi.h</code>.</p>
<h2 id="header-overview"><a class="header" href="#header-overview">Header Overview</a></h2>
<pre><code class="language-c">#ifndef BBX_FFI_H
#define BBX_FFI_H

#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stddef.h&gt;

#ifdef __cplusplus
extern "C" {
#endif

// Types and functions...

#ifdef __cplusplus
}
#endif

#endif  /* BBX_FFI_H */
</code></pre>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<h3 id="bbxerror"><a class="header" href="#bbxerror">BbxError</a></h3>
<p>Error codes for FFI operations:</p>
<pre><code class="language-c">typedef enum BbxError {
    BBX_ERROR_OK = 0,
    BBX_ERROR_NULL_POINTER = 1,
    BBX_ERROR_INVALID_PARAMETER = 2,
    BBX_ERROR_INVALID_BUFFER_SIZE = 3,
    BBX_ERROR_GRAPH_NOT_PREPARED = 4,
    BBX_ERROR_ALLOCATION_FAILED = 5,
} BbxError;
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Error</th><th>Value</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>BBX_ERROR_OK</code></td><td>0</td><td>Operation succeeded</td></tr>
<tr><td><code>BBX_ERROR_NULL_POINTER</code></td><td>1</td><td>Handle was NULL</td></tr>
<tr><td><code>BBX_ERROR_INVALID_PARAMETER</code></td><td>2</td><td>Invalid parameter value</td></tr>
<tr><td><code>BBX_ERROR_INVALID_BUFFER_SIZE</code></td><td>3</td><td>Buffer size was 0</td></tr>
<tr><td><code>BBX_ERROR_GRAPH_NOT_PREPARED</code></td><td>4</td><td>Graph not prepared before processing</td></tr>
<tr><td><code>BBX_ERROR_ALLOCATION_FAILED</code></td><td>5</td><td>Memory allocation failed</td></tr>
</tbody>
</table>
</div>
<h3 id="bbxgraph"><a class="header" href="#bbxgraph">BbxGraph</a></h3>
<p>Opaque handle to the Rust DSP:</p>
<pre><code class="language-c">typedef struct BbxGraph BbxGraph;
</code></pre>
<p>Never dereference or inspect this pointer - it’s an opaque handle.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="bbx_graph_create"><a class="header" href="#bbx_graph_create">bbx_graph_create</a></h3>
<pre><code class="language-c">BbxGraph* bbx_graph_create(void);
</code></pre>
<p>Create a new DSP effects chain.</p>
<p><strong>Returns</strong>: Handle to the effects chain, or <code>NULL</code> if allocation fails.</p>
<p><strong>Usage</strong>:</p>
<pre><code class="language-c">BbxGraph* handle = bbx_graph_create();
if (handle == NULL) {
    // Allocation failed
}
</code></pre>
<h3 id="bbx_graph_destroy"><a class="header" href="#bbx_graph_destroy">bbx_graph_destroy</a></h3>
<pre><code class="language-c">void bbx_graph_destroy(BbxGraph* handle);
</code></pre>
<p>Destroy a DSP effects chain and free all resources.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>handle</code> - Effects chain handle (safe to call with <code>NULL</code>)</li>
</ul>
<p><strong>Usage</strong>:</p>
<pre><code class="language-c">bbx_graph_destroy(handle);
handle = NULL;  // Avoid dangling pointer
</code></pre>
<h3 id="bbx_graph_prepare"><a class="header" href="#bbx_graph_prepare">bbx_graph_prepare</a></h3>
<pre><code class="language-c">BbxError bbx_graph_prepare(
    BbxGraph* handle,
    double sample_rate,
    uint32_t buffer_size,
    uint32_t num_channels
);
</code></pre>
<p>Prepare the effects chain for playback.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>handle</code> - Effects chain handle</li>
<li><code>sample_rate</code> - Sample rate in Hz (e.g., 44100.0, 48000.0)</li>
<li><code>buffer_size</code> - Number of samples per buffer</li>
<li><code>num_channels</code> - Number of audio channels</li>
</ul>
<p><strong>Returns</strong>: <code>BBX_ERROR_OK</code> on success, or an error code.</p>
<p><strong>Usage</strong>:</p>
<pre><code class="language-c">BbxError err = bbx_graph_prepare(handle, 44100.0, 512, 2);
if (err != BBX_ERROR_OK) {
    // Handle error
}
</code></pre>
<h3 id="bbx_graph_reset"><a class="header" href="#bbx_graph_reset">bbx_graph_reset</a></h3>
<pre><code class="language-c">BbxError bbx_graph_reset(BbxGraph* handle);
</code></pre>
<p>Reset the effects chain state (clear filters, delay lines, etc.).</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>handle</code> - Effects chain handle</li>
</ul>
<p><strong>Returns</strong>: <code>BBX_ERROR_OK</code> on success.</p>
<p><strong>Usage</strong>:</p>
<pre><code class="language-c">bbx_graph_reset(handle);
</code></pre>
<h3 id="bbx_graph_process"><a class="header" href="#bbx_graph_process">bbx_graph_process</a></h3>
<pre><code class="language-c">void bbx_graph_process(
    BbxGraph* handle,
    const float* const* inputs,
    float* const* outputs,
    uint32_t num_channels,
    uint32_t num_samples,
    const float* params,
    uint32_t num_params
);
</code></pre>
<p>Process a block of audio.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>handle</code> - Effects chain handle</li>
<li><code>inputs</code> - Array of input channel pointers</li>
<li><code>outputs</code> - Array of output channel pointers</li>
<li><code>num_channels</code> - Number of audio channels</li>
<li><code>num_samples</code> - Number of samples per channel</li>
<li><code>params</code> - Pointer to flat array of parameter values</li>
<li><code>num_params</code> - Number of parameters</li>
</ul>
<p><strong>Usage</strong>:</p>
<pre><code class="language-c">float params[PARAM_COUNT] = { gainValue, panValue, ... };

bbx_graph_process(
    handle,
    inputPtrs,
    outputPtrs,
    numChannels,
    numSamples,
    params,
    PARAM_COUNT
);
</code></pre>
<p>Note: Parameter index constants (<code>PARAM_*</code>) are defined in the generated <code>bbx_params.h</code> header, not in <code>bbx_ffi.h</code>. See <a href="#parameter-code-generation">Parameter Code Generation</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="c-raii-wrapper"><a class="header" href="#c-raii-wrapper">C++ RAII Wrapper</a></h1>
<p><code>bbx_graph.h</code> provides a header-only C++ wrapper for safe resource management.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The <code>bbx::Graph</code> class wraps the C FFI with RAII semantics:</p>
<ul>
<li>Constructor calls <code>bbx_graph_create()</code></li>
<li>Destructor calls <code>bbx_graph_destroy()</code></li>
<li>Move semantics prevent accidental copies</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Include the header:</p>
<pre><code class="language-cpp">#include &lt;bbx_graph.h&gt;
</code></pre>
<p>Create and use a graph:</p>
<pre><code class="language-cpp">bbx::Graph dsp;  // Automatically creates handle

if (dsp.IsValid()) {
    dsp.Prepare(sampleRate, bufferSize, numChannels);
    dsp.Process(inputs, outputs, numChannels, numSamples, params, numParams);
}
</code></pre>
<h2 id="class-reference"><a class="header" href="#class-reference">Class Reference</a></h2>
<h3 id="constructor"><a class="header" href="#constructor">Constructor</a></h3>
<pre><code class="language-cpp">Graph();
</code></pre>
<p>Creates a new DSP graph. Check <code>IsValid()</code> to verify allocation succeeded.</p>
<h3 id="destructor"><a class="header" href="#destructor">Destructor</a></h3>
<pre><code class="language-cpp">~Graph();
</code></pre>
<p>Destroys the graph and frees all resources.</p>
<h3 id="move-operations"><a class="header" href="#move-operations">Move Operations</a></h3>
<pre><code class="language-cpp">Graph(Graph&amp;&amp; other) noexcept;
Graph&amp; operator=(Graph&amp;&amp; other) noexcept;
</code></pre>
<p>The class is movable but not copyable:</p>
<pre><code class="language-cpp">bbx::Graph a;
bbx::Graph b = std::move(a);  // OK - a is now invalid
// bbx::Graph c = b;          // Error - not copyable
</code></pre>
<h3 id="prepare-1"><a class="header" href="#prepare-1">Prepare</a></h3>
<pre><code class="language-cpp">BbxError Prepare(double sampleRate, uint32_t bufferSize, uint32_t numChannels);
</code></pre>
<p>Prepare for playback. Call from <code>prepareToPlay()</code>.</p>
<h3 id="reset-1"><a class="header" href="#reset-1">Reset</a></h3>
<pre><code class="language-cpp">BbxError Reset();
</code></pre>
<p>Reset DSP state. Call from <code>releaseResources()</code>.</p>
<h3 id="process-1"><a class="header" href="#process-1">Process</a></h3>
<pre><code class="language-cpp">void Process(
    const float* const* inputs,
    float* const* outputs,
    uint32_t numChannels,
    uint32_t numSamples,
    const float* params,
    uint32_t numParams
);
</code></pre>
<p>Process audio. Call from <code>processBlock()</code>.</p>
<h3 id="isvalid"><a class="header" href="#isvalid">IsValid</a></h3>
<pre><code class="language-cpp">bool IsValid() const;
</code></pre>
<p>Returns <code>true</code> if the handle is valid.</p>
<h3 id="handle"><a class="header" href="#handle">handle</a></h3>
<pre><code class="language-cpp">BbxGraph* handle();
const BbxGraph* handle() const;
</code></pre>
<p>Access the raw handle for advanced use.</p>
<h2 id="complete-header"><a class="header" href="#complete-header">Complete Header</a></h2>
<pre><code class="language-cpp">#pragma once

#include "bbx_ffi.h"

namespace bbx {

class Graph {
public:
    Graph()
        : m_handle(bbx_graph_create())
    {
    }

    ~Graph()
    {
        if (m_handle) {
            bbx_graph_destroy(m_handle);
        }
    }

    // Non-copyable
    Graph(const Graph&amp;) = delete;
    Graph&amp; operator=(const Graph&amp;) = delete;

    // Movable
    Graph(Graph&amp;&amp; other) noexcept
        : m_handle(other.m_handle)
    {
        other.m_handle = nullptr;
    }

    Graph&amp; operator=(Graph&amp;&amp; other) noexcept
    {
        if (this != &amp;other) {
            if (m_handle) {
                bbx_graph_destroy(m_handle);
            }
            m_handle = other.m_handle;
            other.m_handle = nullptr;
        }
        return *this;
    }

    BbxError Prepare(double sampleRate, uint32_t bufferSize, uint32_t numChannels)
    {
        if (!m_handle) {
            return BBX_ERROR_NULL_POINTER;
        }
        return bbx_graph_prepare(m_handle, sampleRate, bufferSize, numChannels);
    }

    BbxError Reset()
    {
        if (!m_handle) {
            return BBX_ERROR_NULL_POINTER;
        }
        return bbx_graph_reset(m_handle);
    }

    void Process(const float* const* inputs,
        float* const* outputs,
        uint32_t numChannels,
        uint32_t numSamples,
        const float* params,
        uint32_t numParams)
    {
        if (m_handle) {
            bbx_graph_process(m_handle, inputs, outputs, numChannels, numSamples, params, numParams);
        }
    }

    bool IsValid() const { return m_handle != nullptr; }

    BbxGraph* handle() { return m_handle; }
    const BbxGraph* handle() const { return m_handle; }

private:
    BbxGraph* m_handle { nullptr };
};

} // namespace bbx
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="audioprocessor-integration"><a class="header" href="#audioprocessor-integration">AudioProcessor Integration</a></h1>
<p>Integrate <code>bbx::Graph</code> with your JUCE AudioProcessor.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>The integration pattern:</p>
<ol>
<li>Store <code>bbx::Graph</code> as a member</li>
<li>Call <code>Prepare()</code> in <code>prepareToPlay()</code></li>
<li>Call <code>Reset()</code> in <code>releaseResources()</code></li>
<li>Call <code>Process()</code> in <code>processBlock()</code></li>
</ol>
<h2 id="processor-header"><a class="header" href="#processor-header">Processor Header</a></h2>
<pre><code class="language-cpp">#pragma once

#include &lt;juce_audio_processors/juce_audio_processors.h&gt;
#include &lt;bbx_graph.h&gt;
#include &lt;bbx_params.h&gt;
#include &lt;array&gt;
#include &lt;atomic&gt;
#include &lt;vector&gt;

class PluginAudioProcessor : public juce::AudioProcessor {
public:
    PluginAudioProcessor();
    ~PluginAudioProcessor() override;

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock(juce::AudioBuffer&lt;float&gt;&amp;, juce::MidiBuffer&amp;) override;

    // ... other AudioProcessor methods

private:
    juce::AudioProcessorValueTreeState m_parameters;

    bbx::Graph m_rustDsp;
    std::vector&lt;float&gt; m_paramBuffer;
    std::array&lt;std::atomic&lt;float&gt;*, PARAM_COUNT&gt; m_paramPointers {};

    // Pointer arrays for FFI
    static constexpr size_t MAX_CHANNELS = 8;
    std::array&lt;const float*, MAX_CHANNELS&gt; m_inputPtrs {};
    std::array&lt;float*, MAX_CHANNELS&gt; m_outputPtrs {};
};
</code></pre>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="constructor-1"><a class="header" href="#constructor-1">Constructor</a></h3>
<pre><code class="language-cpp">PluginAudioProcessor::PluginAudioProcessor()
    : AudioProcessor(/* bus layout */)
    , m_parameters(*this, nullptr, "Parameters", createParameterLayout())
{
    // Allocate parameter buffer
    m_paramBuffer.resize(PARAM_COUNT);

    // Cache parameter pointers for efficient access in processBlock
    for (size_t i = 0; i &lt; PARAM_COUNT; ++i) {
        m_paramPointers[i] = m_parameters.getRawParameterValue(juce::String(PARAM_IDS[i]));
    }
}
</code></pre>
<h3 id="preparetoplay"><a class="header" href="#preparetoplay">prepareToPlay</a></h3>
<pre><code class="language-cpp">void PluginAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    BbxError err = m_rustDsp.Prepare(
        sampleRate,
        static_cast&lt;uint32_t&gt;(samplesPerBlock),
        static_cast&lt;uint32_t&gt;(getTotalNumOutputChannels())
    );

    if (err != BBX_ERROR_OK) {
        DBG("Failed to prepare Rust DSP: " + juce::String(static_cast&lt;int&gt;(err)));
    }
}
</code></pre>
<h3 id="releaseresources"><a class="header" href="#releaseresources">releaseResources</a></h3>
<pre><code class="language-cpp">void PluginAudioProcessor::releaseResources()
{
    m_rustDsp.Reset();
}
</code></pre>
<h3 id="processblock"><a class="header" href="#processblock">processBlock</a></h3>
<pre><code class="language-cpp">void PluginAudioProcessor::processBlock(juce::AudioBuffer&lt;float&gt;&amp; buffer,
                                         juce::MidiBuffer&amp; midiMessages)
{
    juce::ScopedNoDenormals noDenormals;

    auto numChannels = static_cast&lt;uint32_t&gt;(buffer.getNumChannels());
    auto numSamples = static_cast&lt;uint32_t&gt;(buffer.getNumSamples());

    // Clamp to max supported channels
    numChannels = std::min(numChannels, static_cast&lt;uint32_t&gt;(MAX_CHANNELS));

    // Load parameter values from cached atomic pointers
    for (size_t i = 0; i &lt; PARAM_COUNT; ++i) {
        m_paramBuffer[i] = m_paramPointers[i] ? m_paramPointers[i]-&gt;load() : 0.0f;
    }

    // Build pointer arrays
    for (uint32_t ch = 0; ch &lt; numChannels; ++ch) {
        m_inputPtrs[ch] = buffer.getReadPointer(static_cast&lt;int&gt;(ch));
        m_outputPtrs[ch] = buffer.getWritePointer(static_cast&lt;int&gt;(ch));
    }

    // Process through Rust DSP
    m_rustDsp.Process(
        m_inputPtrs.data(),
        m_outputPtrs.data(),
        numChannels,
        numSamples,
        m_paramBuffer.data(),
        static_cast&lt;uint32_t&gt;(m_paramBuffer.size())
    );
}
</code></pre>
<h2 id="parameter-integration"><a class="header" href="#parameter-integration">Parameter Integration</a></h2>
<p>The recommended approach uses <code>PARAM_IDS</code> from the generated header for dynamic iteration:</p>
<pre><code class="language-cpp">// In constructor - cache all parameter pointers
for (size_t i = 0; i &lt; PARAM_COUNT; ++i) {
    m_paramPointers[i] = m_parameters.getRawParameterValue(juce::String(PARAM_IDS[i]));
}

// In processBlock - load all values dynamically
for (size_t i = 0; i &lt; PARAM_COUNT; ++i) {
    m_paramBuffer[i] = m_paramPointers[i] ? m_paramPointers[i]-&gt;load() : 0.0f;
}
</code></pre>
<p>This eliminates per-parameter boilerplate. When adding new parameters, only update <code>parameters.json</code> and the Rust <code>apply_parameters()</code> method.</p>
<h3 id="parameter-layout"><a class="header" href="#parameter-layout">Parameter Layout</a></h3>
<p>Create the layout from JSON using <code>cortex::ParameterManager</code> or manually:</p>
<pre><code class="language-cpp">juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout()
{
    // Option 1: Load from embedded JSON (recommended)
    juce::String json = juce::String::createStringFromData(
        PluginData::parameters_json, PluginData::parameters_jsonSize);
    auto params = cortex::ParameterManager::LoadParametersFromJson(json);
    return cortex::ParameterManager::CreateParameterLayout(params);

    // Option 2: Manual definition
    std::vector&lt;std::unique_ptr&lt;juce::RangedAudioParameter&gt;&gt; params;
    params.push_back(std::make_unique&lt;juce::AudioParameterFloat&gt;(
        "GAIN", "Gain",
        juce::NormalisableRange&lt;float&gt;(-60.0f, 30.0f, 0.1f),
        0.0f));
    // ... more parameters
    return { params.begin(), params.end() };
}
</code></pre>
<h2 id="thread-safety-notes"><a class="header" href="#thread-safety-notes">Thread Safety Notes</a></h2>
<ul>
<li><code>processBlock()</code> runs on the audio thread</li>
<li>Parameter reads should use atomics</li>
<li>Never allocate memory in <code>processBlock()</code></li>
<li>The <code>bbx::Graph</code> is already designed for audio thread use</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="complete-example-walkthrough"><a class="header" href="#complete-example-walkthrough">Complete Example Walkthrough</a></h1>
<p>A complete example of integrating Rust DSP with a JUCE plugin.</p>
<h2 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h2>
<pre><code>my-utility-plugin/
├── CMakeLists.txt
├── dsp/
│   ├── Cargo.toml
│   ├── parameters.json
│   ├── include/
│   │   ├── bbx_ffi.h
│   │   └── bbx_graph.h
│   └── src/
│       └── lib.rs
├── src/
│   ├── PluginProcessor.cpp
│   ├── PluginProcessor.h
│   ├── PluginEditor.cpp
│   └── PluginEditor.h
└── vendor/
    └── corrosion/
</code></pre>
<h2 id="step-1-define-parameters"><a class="header" href="#step-1-define-parameters">Step 1: Define Parameters</a></h2>
<p><code>dsp/parameters.json</code>:</p>
<pre><code class="language-json">{
  "parameters": [
    {
      "id": "GAIN",
      "name": "Gain",
      "type": "float",
      "min": -60.0,
      "max": 30.0,
      "defaultValue": 0.0,
      "unit": "dB"
    },
    {
      "id": "PAN",
      "name": "Pan",
      "type": "float",
      "min": -100.0,
      "max": 100.0,
      "defaultValue": 0.0
    },
    {
      "id": "MONO",
      "name": "Mono",
      "type": "boolean",
      "defaultValue": false
    }
  ]
}
</code></pre>
<h2 id="step-2-rust-dsp-implementation"><a class="header" href="#step-2-rust-dsp-implementation">Step 2: Rust DSP Implementation</a></h2>
<p><code>dsp/Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "dsp"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["staticlib"]

[dependencies]
bbx_plugin = "0.1"
</code></pre>
<p><code>dsp/src/lib.rs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::{
    PluginDsp, DspContext, bbx_plugin_ffi,
    blocks::{GainBlock, PannerBlock},
};

// Parameter indices
const PARAM_GAIN: usize = 0;
const PARAM_PAN: usize = 1;
const PARAM_MONO: usize = 2;

pub struct PluginGraph {
    gain: GainBlock&lt;f32&gt;,
    panner: PannerBlock&lt;f32&gt;,
    mono: bool,
}

impl Default for PluginGraph {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl PluginDsp for PluginGraph {
    fn new() -&gt; Self {
        Self {
            gain: GainBlock::new(0.0),
            panner: PannerBlock::new(0.0),
            mono: false,
        }
    }

    fn prepare(&amp;mut self, _context: &amp;DspContext) {
        // Nothing to prepare for these simple blocks
    }

    fn reset(&amp;mut self) {
        // Nothing to reset
    }

    fn apply_parameters(&amp;mut self, params: &amp;[f32]) {
        self.gain.level_db = params[PARAM_GAIN];
        self.panner.position = params[PARAM_PAN];
        self.mono = params[PARAM_MONO] &gt; 0.5;
    }

    fn process(
        &amp;mut self,
        inputs: &amp;[&amp;[f32]],
        outputs: &amp;mut [&amp;mut [f32]],
        context: &amp;DspContext,
    ) {
        let num_samples = context.buffer_size;
        let multiplier = self.gain.multiplier();

        // Apply gain
        for ch in 0..inputs.len().min(outputs.len()) {
            for i in 0..num_samples {
                outputs[ch][i] = inputs[ch][i] * multiplier;
            }
        }

        // Apply mono summing if enabled
        if self.mono &amp;&amp; outputs.len() &gt;= 2 {
            for i in 0..num_samples {
                let sum = (outputs[0][i] + outputs[1][i]) * 0.5;
                outputs[0][i] = sum;
                outputs[1][i] = sum;
            }
        }

        // Apply panning
        if outputs.len() &gt;= 2 {
            let (left_gain, right_gain) = self.panner.gains();
            for i in 0..num_samples {
                outputs[0][i] *= left_gain;
                outputs[1][i] *= right_gain;
            }
        }
    }
}

bbx_plugin_ffi!(PluginGraph);
<span class="boring">}</span></code></pre>
<h2 id="step-3-cmake-configuration"><a class="header" href="#step-3-cmake-configuration">Step 3: CMake Configuration</a></h2>
<p><code>CMakeLists.txt</code>:</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.15)
project(MyUtilityPlugin VERSION 1.0.0)

add_subdirectory(JUCE)
add_subdirectory(vendor/corrosion)

corrosion_import_crate(MANIFEST_PATH dsp/Cargo.toml)

juce_add_plugin(MyUtilityPlugin
    PLUGIN_MANUFACTURER_CODE Bbxa
    PLUGIN_CODE Util
    FORMATS AU VST3 Standalone
    PRODUCT_NAME "My Utility Plugin")

target_sources(MyUtilityPlugin PRIVATE
    src/PluginProcessor.cpp
    src/PluginEditor.cpp)

target_link_libraries(MyUtilityPlugin PRIVATE
    juce::juce_audio_processors
    juce::juce_audio_utils
    dsp)

target_include_directories(MyUtilityPlugin PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/dsp/include)
</code></pre>
<h2 id="step-4-juce-processor"><a class="header" href="#step-4-juce-processor">Step 4: JUCE Processor</a></h2>
<p><code>src/PluginProcessor.h</code>:</p>
<pre><code class="language-cpp">#pragma once

#include &lt;juce_audio_processors/juce_audio_processors.h&gt;
#include &lt;bbx_graph.h&gt;
#include &lt;bbx_ffi.h&gt;
#include &lt;array&gt;
#include &lt;vector&gt;

class PluginAudioProcessor : public juce::AudioProcessor {
public:
    PluginAudioProcessor();
    ~PluginAudioProcessor() override = default;

    void prepareToPlay(double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;
    void processBlock(juce::AudioBuffer&lt;float&gt;&amp;, juce::MidiBuffer&amp;) override;

    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override { return true; }

    const juce::String getName() const override { return "My Utility Plugin"; }
    bool acceptsMidi() const override { return false; }
    bool producesMidi() const override { return false; }
    double getTailLengthSeconds() const override { return 0.0; }

    int getNumPrograms() override { return 1; }
    int getCurrentProgram() override { return 0; }
    void setCurrentProgram(int) override {}
    const juce::String getProgramName(int) override { return {}; }
    void changeProgramName(int, const juce::String&amp;) override {}

    void getStateInformation(juce::MemoryBlock&amp; destData) override;
    void setStateInformation(const void* data, int sizeInBytes) override;

    juce::AudioProcessorValueTreeState parameters;

private:
    juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();

    bbx::Graph m_rustDsp;
    std::vector&lt;float&gt; m_paramBuffer;

    std::atomic&lt;float&gt;* gainParam = nullptr;
    std::atomic&lt;float&gt;* panParam = nullptr;
    std::atomic&lt;float&gt;* monoParam = nullptr;

    static constexpr size_t MAX_CHANNELS = 8;
    std::array&lt;const float*, MAX_CHANNELS&gt; m_inputPtrs {};
    std::array&lt;float*, MAX_CHANNELS&gt; m_outputPtrs {};
};
</code></pre>
<p><code>src/PluginProcessor.cpp</code>:</p>
<pre><code class="language-cpp">#include "PluginProcessor.h"
#include "PluginEditor.h"

PluginAudioProcessor::PluginAudioProcessor()
    : AudioProcessor(BusesProperties()
        .withInput("Input", juce::AudioChannelSet::stereo(), true)
        .withOutput("Output", juce::AudioChannelSet::stereo(), true))
    , parameters(*this, nullptr, "Parameters", createParameterLayout())
{
    gainParam = parameters.getRawParameterValue("gain");
    panParam = parameters.getRawParameterValue("pan");
    monoParam = parameters.getRawParameterValue("mono");

    m_paramBuffer.resize(PARAM_COUNT);
}

juce::AudioProcessorValueTreeState::ParameterLayout
PluginAudioProcessor::createParameterLayout()
{
    std::vector&lt;std::unique_ptr&lt;juce::RangedAudioParameter&gt;&gt; params;

    params.push_back(std::make_unique&lt;juce::AudioParameterFloat&gt;(
        "gain", "Gain",
        juce::NormalisableRange&lt;float&gt;(-60.0f, 30.0f, 0.1f),
        0.0f));

    params.push_back(std::make_unique&lt;juce::AudioParameterFloat&gt;(
        "pan", "Pan",
        juce::NormalisableRange&lt;float&gt;(-100.0f, 100.0f, 1.0f),
        0.0f));

    params.push_back(std::make_unique&lt;juce::AudioParameterBool&gt;(
        "mono", "Mono", false));

    return { params.begin(), params.end() };
}

void PluginAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
    m_rustDsp.Prepare(
        sampleRate,
        static_cast&lt;uint32_t&gt;(samplesPerBlock),
        static_cast&lt;uint32_t&gt;(getTotalNumOutputChannels()));
}

void PluginAudioProcessor::releaseResources()
{
    m_rustDsp.Reset();
}

void PluginAudioProcessor::processBlock(juce::AudioBuffer&lt;float&gt;&amp; buffer,
                                         juce::MidiBuffer&amp;)
{
    juce::ScopedNoDenormals noDenormals;

    auto numChannels = static_cast&lt;uint32_t&gt;(buffer.getNumChannels());
    auto numSamples = static_cast&lt;uint32_t&gt;(buffer.getNumSamples());
    numChannels = std::min(numChannels, static_cast&lt;uint32_t&gt;(MAX_CHANNELS));

    m_paramBuffer[PARAM_GAIN] = gainParam-&gt;load();
    m_paramBuffer[PARAM_PAN] = panParam-&gt;load();
    m_paramBuffer[PARAM_MONO] = monoParam-&gt;load();

    for (uint32_t ch = 0; ch &lt; numChannels; ++ch) {
        m_inputPtrs[ch] = buffer.getReadPointer(static_cast&lt;int&gt;(ch));
        m_outputPtrs[ch] = buffer.getWritePointer(static_cast&lt;int&gt;(ch));
    }

    m_rustDsp.Process(
        m_inputPtrs.data(),
        m_outputPtrs.data(),
        numChannels,
        numSamples,
        m_paramBuffer.data(),
        static_cast&lt;uint32_t&gt;(m_paramBuffer.size()));
}

juce::AudioProcessorEditor* PluginAudioProcessor::createEditor()
{
    return new PluginEditor(*this);
}

void PluginAudioProcessor::getStateInformation(juce::MemoryBlock&amp; destData)
{
    auto state = parameters.copyState();
    std::unique_ptr&lt;juce::XmlElement&gt; xml(state.createXml());
    copyXmlToBinary(*xml, destData);
}

void PluginAudioProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    std::unique_ptr&lt;juce::XmlElement&gt; xmlState(getXmlFromBinary(data, sizeInBytes));
    if (xmlState &amp;&amp; xmlState-&gt;hasTagName(parameters.state.getType()))
        parameters.replaceState(juce::ValueTree::fromXml(*xmlState));
}

juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new PluginAudioProcessor();
}
</code></pre>
<h2 id="step-5-build"><a class="header" href="#step-5-build">Step 5: Build</a></h2>
<pre><code class="language-bash"># Configure
cmake -B build -DCMAKE_BUILD_TYPE=Release

# Build
cmake --build build --config Release
</code></pre>
<p>The plugin will be in <code>build/MyUtilityPlugin_artefacts/</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bbx_core"><a class="header" href="#bbx_core">bbx_core</a></h1>
<p>Foundational utilities and data structures for the bbx_audio workspace.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>bbx_core provides low-level utilities designed for real-time audio applications:</p>
<ul>
<li>Denormal handling to prevent CPU slowdowns</li>
<li>Lock-free data structures for inter-thread communication</li>
<li>Stack-allocated containers to avoid heap allocations</li>
<li>Fast random number generation</li>
</ul>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<pre><code class="language-toml">[dependencies]
bbx_core = "0.1"
</code></pre>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="#denormal-handling">Denormal Handling</a></td><td>Flush denormal floats to zero</td></tr>
<tr><td><a href="#spsc-ring-buffer">SPSC Ring Buffer</a></td><td>Lock-free producer-consumer queue</td></tr>
<tr><td><a href="#stack-vector">Stack Vector</a></td><td>Fixed-capacity heap-free vector</td></tr>
<tr><td><a href="#random-number-generation">Random</a></td><td>Fast XorShift RNG</td></tr>
<tr><td><a href="#error-types">Error Types</a></td><td>Unified error handling</td></tr>
</tbody>
</table>
</div>
<h2 id="quick-example-1"><a class="header" href="#quick-example-1">Quick Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::{StackVec, flush_denormal_f32};

// Stack-allocated buffer for audio processing
let mut samples: StackVec&lt;f32, 256&gt; = StackVec::new();

// Process samples, flushing denormals
for sample in &amp;mut samples {
    *sample = flush_denormal_f32(*sample);
}
<span class="boring">}</span></code></pre>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<h3 id="no-heap-allocations"><a class="header" href="#no-heap-allocations">No Heap Allocations</a></h3>
<p>All data structures are designed to work without heap allocation during audio processing. Buffers are pre-allocated and reused.</p>
<h3 id="lock-free"><a class="header" href="#lock-free">Lock-Free</a></h3>
<p>The SPSC ring buffer uses atomic operations instead of mutexes, ensuring consistent performance.</p>
<h3 id="minimal-dependencies"><a class="header" href="#minimal-dependencies">Minimal Dependencies</a></h3>
<p>bbx_core has minimal external dependencies, keeping compile times low and reducing potential issues.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="denormal-handling"><a class="header" href="#denormal-handling">Denormal Handling</a></h1>
<p>Utilities for flushing denormal (subnormal) floating-point values to zero.</p>
<h2 id="why-denormals-matter"><a class="header" href="#why-denormals-matter">Why Denormals Matter</a></h2>
<p>Denormal numbers are very small floating-point values near zero. Processing them can cause significant CPU slowdowns (10-100x slower) on many processors.</p>
<p>In audio processing, denormals commonly occur:</p>
<ul>
<li>In filter feedback paths as signals decay</li>
<li>After gain reduction to very low levels</li>
<li>In reverb/delay tail-off</li>
</ul>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<h3 id="flush_denormal_f32"><a class="header" href="#flush_denormal_f32">flush_denormal_f32</a></h3>
<p>Flush a 32-bit float to zero if denormal:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::flush_denormal_f32;

let small_value = 1.0e-40_f32;  // Denormal
let result = flush_denormal_f32(small_value);
assert_eq!(result, 0.0);

let normal_value = 0.5_f32;
let result = flush_denormal_f32(normal_value);
assert_eq!(result, 0.5);
<span class="boring">}</span></code></pre>
<h3 id="flush_denormal_f64"><a class="header" href="#flush_denormal_f64">flush_denormal_f64</a></h3>
<p>Flush a 64-bit float to zero if denormal:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::flush_denormal_f64;

let small_value = 1.0e-310_f64;  // Denormal
let result = flush_denormal_f64(small_value);
assert_eq!(result, 0.0);
<span class="boring">}</span></code></pre>
<h2 id="usage-patterns"><a class="header" href="#usage-patterns">Usage Patterns</a></h2>
<h3 id="in-feedback-loops"><a class="header" href="#in-feedback-loops">In Feedback Loops</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::flush_denormal_f32;

fn process_filter(input: f32, state: &amp;mut f32, coefficient: f32) -&gt; f32 {
    let output = input + *state * coefficient;
    *state = flush_denormal_f32(output);  // Prevent denormal accumulation
    output
}
<span class="boring">}</span></code></pre>
<h3 id="block-processing"><a class="header" href="#block-processing">Block Processing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::flush_denormal_f32;

fn process_block(samples: &amp;mut [f32]) {
    for sample in samples {
        *sample = flush_denormal_f32(*sample);
    }
}
<span class="boring">}</span></code></pre>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>The flush functions use bit manipulation, not branching:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Conceptually (actual implementation may differ):
fn flush_denormal_f32(x: f32) -&gt; f32 {
    let bits = x.to_bits();
    let exponent = (bits &gt;&gt; 23) &amp; 0xFF;
    if exponent == 0 &amp;&amp; (bits &amp; 0x007FFFFF) != 0 {
        0.0  // Denormal
    } else {
        x    // Normal
    }
}
<span class="boring">}</span></code></pre>
<p>This is typically faster than relying on FPU denormal handling.</p>
<h2 id="hardware-ftzdaz-mode"><a class="header" href="#hardware-ftzdaz-mode">Hardware FTZ/DAZ Mode</a></h2>
<p>For maximum performance, bbx_core provides the <code>ftz-daz</code> Cargo feature that enables hardware-level denormal handling on x86/x86_64 processors.</p>
<h3 id="enabling-the-feature"><a class="header" href="#enabling-the-feature">Enabling the Feature</a></h3>
<pre><code class="language-toml">[dependencies]
bbx_core = { version = "...", features = ["ftz-daz"] }
</code></pre>
<h3 id="enable_ftz_daz"><a class="header" href="#enable_ftz_daz">enable_ftz_daz</a></h3>
<p>When the feature is enabled, call <code>enable_ftz_daz()</code> once at the start of each audio processing thread:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::denormal::enable_ftz_daz;

fn audio_thread_init() {
    enable_ftz_daz();
    // All subsequent float operations on this thread will auto-flush denormals
}
<span class="boring">}</span></code></pre>
<p>This sets two CPU flags:</p>
<ul>
<li><strong>FTZ (Flush-To-Zero)</strong>: Denormal results are flushed to zero</li>
<li><strong>DAZ (Denormals-Are-Zero)</strong>: Denormal inputs are treated as zero</li>
</ul>
<h3 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h3>
<ul>
<li><strong>x86/x86_64</strong>: Full support via MXCSR register</li>
<li><strong>Other architectures</strong>: No-op (use the software flush functions instead)</li>
</ul>
<h3 id="bbx_plugin-integration"><a class="header" href="#bbx_plugin-integration">bbx_plugin Integration</a></h3>
<p>When using <code>bbx_plugin</code> with the <code>ftz-daz</code> feature enabled, <code>enable_ftz_daz()</code> is called automatically during <code>prepare()</code>:</p>
<pre><code class="language-toml">[dependencies]
bbx_plugin = { version = "...", features = ["ftz-daz"] }
</code></pre>
<p>This is the recommended approach for audio plugins.</p>
<h2 id="software-vs-hardware-approach"><a class="header" href="#software-vs-hardware-approach">Software vs Hardware Approach</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Approach</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><code>flush_denormal_*</code> functions</td><td>Cross-platform, targeted flushing in specific code paths</td></tr>
<tr><td><code>enable_ftz_daz()</code></td><td>Maximum performance on x86/x86_64, affects all operations</td></tr>
</tbody>
</table>
</div>
<p>For production audio plugins on desktop platforms, enabling the <code>ftz-daz</code> feature is recommended. The software flush functions remain useful for cross-platform code or when you need fine-grained control over which values are flushed.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="spsc-ring-buffer"><a class="header" href="#spsc-ring-buffer">SPSC Ring Buffer</a></h1>
<p>A lock-free single-producer single-consumer ring buffer for inter-thread communication.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>The SPSC (Single-Producer Single-Consumer) ring buffer enables safe communication between two threads without locks. This is ideal for audio applications where:</p>
<ul>
<li>The audio thread produces samples</li>
<li>The UI thread consumes visualization data</li>
<li>Or vice versa</li>
</ul>
<h2 id="api-1"><a class="header" href="#api-1">API</a></h2>
<h3 id="creating-a-buffer"><a class="header" href="#creating-a-buffer">Creating a Buffer</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::SpscRingBuffer;

// Create a buffer with capacity for 1024 samples
let (producer, consumer) = SpscRingBuffer::new::&lt;f32&gt;(1024);
<span class="boring">}</span></code></pre>
<p>The returned <code>producer</code> and <code>consumer</code> can be sent to different threads.</p>
<h3 id="producer-operations"><a class="header" href="#producer-operations">Producer Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Try to push a single item (non-blocking)
if producer.try_push(sample).is_ok() {
    // Sample was added
} else {
    // Buffer was full
}

// Push multiple items
let samples = [0.1, 0.2, 0.3];
let pushed = producer.try_push_slice(&amp;samples);
// pushed = number of items actually added
<span class="boring">}</span></code></pre>
<h3 id="consumer-operations"><a class="header" href="#consumer-operations">Consumer Operations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Try to pop a single item (non-blocking)
if let Some(sample) = consumer.try_pop() {
    // Process sample
} else {
    // Buffer was empty
}

// Pop multiple items into a buffer
let mut output = [0.0f32; 256];
let popped = consumer.try_pop_slice(&amp;mut output);
// popped = number of items actually read
<span class="boring">}</span></code></pre>
<h3 id="checking-capacity"><a class="header" href="#checking-capacity">Checking Capacity</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let available = consumer.len();     // Items ready to read
let space = producer.capacity() - producer.len();  // Space for writing
<span class="boring">}</span></code></pre>
<h2 id="usage-patterns-1"><a class="header" href="#usage-patterns-1">Usage Patterns</a></h2>
<h3 id="audio-thread-to-ui-thread"><a class="header" href="#audio-thread-to-ui-thread">Audio Thread to UI Thread</a></h3>
<pre class="playground"><code class="language-rust">use bbx_core::SpscRingBuffer;
use std::thread;

fn main() {
    let (producer, consumer) = SpscRingBuffer::new::&lt;f32&gt;(4096);

    // Audio thread
    let audio_handle = thread::spawn(move || {
        loop {
            let sample = generate_audio();
            let _ = producer.try_push(sample);
        }
    });

    // UI thread
    loop {
        while let Some(sample) = consumer.try_pop() {
            update_waveform_display(sample);
        }
    }
}</code></pre>
<h3 id="midi-message-queue"><a class="header" href="#midi-message-queue">MIDI Message Queue</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::SpscRingBuffer;
use bbx_midi::MidiMessage;

let (midi_producer, midi_consumer) = SpscRingBuffer::new::&lt;MidiMessage&gt;(256);

// MIDI input callback
fn on_midi_message(msg: MidiMessage) {
    let _ = midi_producer.try_push(msg);
}

// Audio thread
fn process_audio() {
    while let Some(msg) = midi_consumer.try_pop() {
        handle_midi(msg);
    }
}
<span class="boring">}</span></code></pre>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="memory-ordering"><a class="header" href="#memory-ordering">Memory Ordering</a></h3>
<p>The buffer uses atomic operations with appropriate memory ordering:</p>
<ul>
<li><code>Relaxed</code> for capacity checks</li>
<li><code>Acquire</code>/<code>Release</code> for actual data transfer</li>
<li>Ensures proper synchronization across threads</li>
</ul>
<h3 id="cache-efficiency"><a class="header" href="#cache-efficiency">Cache Efficiency</a></h3>
<p>The producer and consumer indices are padded to avoid false sharing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(align(64))]  // Cache line alignment
struct Producer&lt;T&gt; {
    write_index: AtomicUsize,
    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="wait-free"><a class="header" href="#wait-free">Wait-Free</a></h3>
<p>Both push and pop operations are wait-free - they complete in bounded time regardless of what the other thread is doing.</p>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<ul>
<li><strong>Single producer only</strong>: Multiple producers require external synchronization</li>
<li><strong>Single consumer only</strong>: Multiple consumers require external synchronization</li>
<li><strong>Fixed capacity</strong>: Size is set at creation, cannot grow</li>
<li><strong>Power of two</strong>: Capacity is rounded up to nearest power of two</li>
</ul>
<p>For multiple producers or consumers, use a different data structure or add external synchronization.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="stack-vector"><a class="header" href="#stack-vector">Stack Vector</a></h1>
<p>A fixed-capacity vector that stores elements on the stack, avoiding heap allocations.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p><code>StackVec</code> is a vector-like container with:</p>
<ul>
<li>Fixed maximum capacity (compile-time constant)</li>
<li>No heap allocations</li>
<li>Safe push/pop operations</li>
<li>Panic-free overflow handling</li>
</ul>
<h2 id="api-2"><a class="header" href="#api-2">API</a></h2>
<h3 id="creating-a-stackvec"><a class="header" href="#creating-a-stackvec">Creating a StackVec</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::StackVec;

// Create an empty stack vector with capacity for 8 f32s
let mut vec: StackVec&lt;f32, 8&gt; = StackVec::new();

// Create from an array
let vec = StackVec::from([1.0, 2.0, 3.0]);
<span class="boring">}</span></code></pre>
<h3 id="adding-elements"><a class="header" href="#adding-elements">Adding Elements</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::StackVec;

let mut vec: StackVec&lt;f32, 4&gt; = StackVec::new();

// Push returns Ok if there's space
assert!(vec.push(1.0).is_ok());
assert!(vec.push(2.0).is_ok());

// Or use try_push for fallible insertion
if vec.try_push(3.0).is_some() {
    // Element was added
}
<span class="boring">}</span></code></pre>
<h3 id="removing-elements"><a class="header" href="#removing-elements">Removing Elements</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::StackVec;

let mut vec: StackVec&lt;f32, 4&gt; = StackVec::from([1.0, 2.0, 3.0]);

// Pop from the end
assert_eq!(vec.pop(), Some(3.0));
assert_eq!(vec.pop(), Some(2.0));

// Clear all elements
vec.clear();
assert!(vec.is_empty());
<span class="boring">}</span></code></pre>
<h3 id="accessing-elements"><a class="header" href="#accessing-elements">Accessing Elements</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::StackVec;

let mut vec: StackVec&lt;f32, 4&gt; = StackVec::from([1.0, 2.0, 3.0]);

// Index access
assert_eq!(vec[0], 1.0);

// Safe access with get
if let Some(value) = vec.get(1) {
    println!("Second element: {}", value);
}

// Mutable access
vec[0] = 10.0;
<span class="boring">}</span></code></pre>
<h3 id="iteration"><a class="header" href="#iteration">Iteration</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::StackVec;

let vec: StackVec&lt;f32, 4&gt; = StackVec::from([1.0, 2.0, 3.0]);

// Immutable iteration
for value in &amp;vec {
    println!("{}", value);
}

// Mutable iteration
let mut vec = vec;
for value in &amp;mut vec {
    *value *= 2.0;
}
<span class="boring">}</span></code></pre>
<h2 id="usage-in-audio-processing"><a class="header" href="#usage-in-audio-processing">Usage in Audio Processing</a></h2>
<h3 id="per-block-buffers"><a class="header" href="#per-block-buffers">Per-Block Buffers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::StackVec;

const MAX_INPUTS: usize = 8;

fn collect_inputs(inputs: &amp;[f32]) -&gt; StackVec&lt;f32, MAX_INPUTS&gt; {
    let mut result = StackVec::new();
    for &amp;input in inputs.iter().take(MAX_INPUTS) {
        let _ = result.push(input);
    }
    result
}
<span class="boring">}</span></code></pre>
<h3 id="modulation-value-collection"><a class="header" href="#modulation-value-collection">Modulation Value Collection</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::StackVec;

const MAX_MODULATORS: usize = 4;

struct ModulationContext {
    values: StackVec&lt;f32, MAX_MODULATORS&gt;,
}

impl ModulationContext {
    fn add_modulator(&amp;mut self, value: f32) {
        let _ = self.values.push(value);
    }

    fn total_modulation(&amp;self) -&gt; f32 {
        self.values.iter().sum()
    }
}
<span class="boring">}</span></code></pre>
<h2 id="comparison-with-other-types"><a class="header" href="#comparison-with-other-types">Comparison with Other Types</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Heap Allocation</th><th>Fixed Size</th><th>Growable</th></tr>
</thead>
<tbody>
<tr><td><code>Vec&lt;T&gt;</code></td><td>Yes</td><td>No</td><td>Yes</td></tr>
<tr><td><code>[T; N]</code></td><td>No</td><td>Yes</td><td>No</td></tr>
<tr><td><code>StackVec&lt;T, N&gt;</code></td><td>No</td><td>Yes (max)</td><td>Yes (up to N)</td></tr>
<tr><td><code>ArrayVec&lt;T, N&gt;</code></td><td>No</td><td>Yes (max)</td><td>Yes (up to N)</td></tr>
</tbody>
</table>
</div>
<p><code>StackVec</code> is similar to <code>arrayvec::ArrayVec</code> but is part of bbx_core with no external dependencies.</p>
<h2 id="limitations-2"><a class="header" href="#limitations-2">Limitations</a></h2>
<ul>
<li>Maximum capacity is fixed at compile time</li>
<li>Capacity is part of the type (<code>StackVec&lt;T, 4&gt;</code> vs <code>StackVec&lt;T, 8&gt;</code>)</li>
<li>Not suitable for large or unknown-size collections</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="random-number-generation"><a class="header" href="#random-number-generation">Random Number Generation</a></h1>
<p>A fast XorShift64 random number generator suitable for audio applications.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p><code>XorShiftRng</code> provides:</p>
<ul>
<li>Fast pseudo-random number generation</li>
<li>Deterministic output (given the same seed)</li>
<li>Audio-range output methods (-1.0 to 1.0)</li>
</ul>
<h2 id="api-3"><a class="header" href="#api-3">API</a></h2>
<h3 id="creating-an-rng"><a class="header" href="#creating-an-rng">Creating an RNG</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::random::XorShiftRng;

// Create with a seed
let mut rng = XorShiftRng::new(42);

// Create with a different seed for different sequences
let mut rng2 = XorShiftRng::new(12345);
<span class="boring">}</span></code></pre>
<h3 id="generating-numbers"><a class="header" href="#generating-numbers">Generating Numbers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::random::XorShiftRng;

let mut rng = XorShiftRng::new(42);

// Raw u64 value
let raw = rng.next_u64();

// Floating-point 0.0 to 1.0
let normalized = rng.next_f32();  // or next_f64()

// Audio sample -1.0 to 1.0
let sample = rng.next_noise_sample();
<span class="boring">}</span></code></pre>
<h2 id="usage-in-audio"><a class="header" href="#usage-in-audio">Usage in Audio</a></h2>
<h3 id="white-noise-generator"><a class="header" href="#white-noise-generator">White Noise Generator</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::random::XorShiftRng;

struct NoiseGenerator {
    rng: XorShiftRng,
}

impl NoiseGenerator {
    fn new(seed: u64) -&gt; Self {
        Self {
            rng: XorShiftRng::new(seed),
        }
    }

    fn process(&amp;mut self, output: &amp;mut [f32]) {
        for sample in output {
            *sample = self.rng.next_noise_sample();
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="randomized-modulation"><a class="header" href="#randomized-modulation">Randomized Modulation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::random::XorShiftRng;

struct RandomLfo {
    rng: XorShiftRng,
    current_value: f32,
    target_value: f32,
    smoothing: f32,
}

impl RandomLfo {
    fn new(seed: u64, smoothing: f32) -&gt; Self {
        let mut rng = XorShiftRng::new(seed);
        let initial = rng.next_noise_sample();
        Self {
            rng,
            current_value: initial,
            target_value: initial,
            smoothing,
        }
    }

    fn process(&amp;mut self) -&gt; f32 {
        // Occasionally pick a new target
        if self.rng.next_f32() &lt; 0.001 {
            self.target_value = self.rng.next_noise_sample();
        }

        // Smooth toward target
        self.current_value += (self.target_value - self.current_value) * self.smoothing;
        self.current_value
    }
}
<span class="boring">}</span></code></pre>
<h2 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h2>
<p>XorShift64 is a simple but effective pseudo-random number generator:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn next_u64(&amp;mut self) -&gt; u64 {
    let mut x = self.state;
    x ^= x &lt;&lt; 13;
    x ^= x &gt;&gt; 7;
    x ^= x &lt;&lt; 17;
    self.state = x;
    x
}
<span class="boring">}</span></code></pre>
<p>Properties:</p>
<ul>
<li>Period: 2^64 - 1</li>
<li>Fast: ~3 CPU cycles per number</li>
<li>Good statistical properties for audio use</li>
<li>Not cryptographically secure</li>
</ul>
<h2 id="seeding"><a class="header" href="#seeding">Seeding</a></h2>
<p>Different seeds produce completely different sequences:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::random::XorShiftRng;

let mut rng1 = XorShiftRng::new(1);
let mut rng2 = XorShiftRng::new(2);

// Completely different sequences
assert_ne!(rng1.next_u64(), rng2.next_u64());
<span class="boring">}</span></code></pre>
<p>For reproducible results (e.g., testing), use a fixed seed.</p>
<p>For unique sequences each run, use a time-based seed:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::random::XorShiftRng;
use std::time::{SystemTime, UNIX_EPOCH};

let seed = SystemTime::now()
    .duration_since(UNIX_EPOCH)
    .unwrap()
    .as_nanos() as u64;

let mut rng = XorShiftRng::new(seed);
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="error-types"><a class="header" href="#error-types">Error Types</a></h1>
<p>Unified error handling across the bbx_audio workspace.</p>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>bbx_core provides common error types used throughout the workspace:</p>
<ul>
<li><code>BbxError</code> - Main error enum</li>
<li><code>Result&lt;T&gt;</code> - Type alias for <code>Result&lt;T, BbxError&gt;</code></li>
</ul>
<h2 id="bbxerror-1"><a class="header" href="#bbxerror-1">BbxError</a></h2>
<p>The main error type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::BbxError;

pub enum BbxError {
    /// Generic error with message
    Generic(String),

    /// I/O error wrapper
    Io(std::io::Error),

    /// Invalid parameter value
    InvalidParameter(String),

    /// Resource not found
    NotFound(String),

    /// Operation failed
    OperationFailed(String),

    /// Null pointer in FFI context
    NullPointer,

    /// Invalid buffer size
    InvalidBufferSize,

    /// Graph not prepared for processing
    GraphNotPrepared,

    /// Memory allocation failed
    AllocationFailed,
}
<span class="boring">}</span></code></pre>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<h3 id="creating-errors"><a class="header" href="#creating-errors">Creating Errors</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::BbxError;

fn validate_sample_rate(rate: f64) -&gt; Result&lt;(), BbxError&gt; {
    if rate &lt;= 0.0 {
        return Err(BbxError::InvalidParameter(
            format!("Sample rate must be positive, got {}", rate)
        ));
    }
    Ok(())
}
<span class="boring">}</span></code></pre>
<h3 id="using-result-type-alias"><a class="header" href="#using-result-type-alias">Using Result Type Alias</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::{BbxError, Result};

fn load_audio(path: &amp;str) -&gt; Result&lt;Vec&lt;f32&gt;&gt; {
    // ... implementation
    Ok(vec![])
}
<span class="boring">}</span></code></pre>
<h3 id="error-propagation"><a class="header" href="#error-propagation">Error Propagation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::Result;

fn process() -&gt; Result&lt;()&gt; {
    let audio = load_audio("input.wav")?;  // Propagate errors with ?
    save_audio("output.wav", &amp;audio)?;
    Ok(())
}
<span class="boring">}</span></code></pre>
<h2 id="ffi-error-codes"><a class="header" href="#ffi-error-codes">FFI Error Codes</a></h2>
<p>For C FFI, errors are represented as integers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub enum BbxErrorCode {
    Ok = 0,
    NullPointer = 1,
    InvalidParameter = 2,
    InvalidBufferSize = 3,
    GraphNotPrepared = 4,
    AllocationFailed = 5,
}
<span class="boring">}</span></code></pre>
<p>Convert between error types:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::BbxError;

impl From&lt;BbxError&gt; for BbxErrorCode {
    fn from(err: BbxError) -&gt; Self {
        match err {
            BbxError::NullPointer =&gt; BbxErrorCode::NullPointer,
            BbxError::InvalidParameter(_) =&gt; BbxErrorCode::InvalidParameter,
            BbxError::InvalidBufferSize =&gt; BbxErrorCode::InvalidBufferSize,
            BbxError::GraphNotPrepared =&gt; BbxErrorCode::GraphNotPrepared,
            BbxError::AllocationFailed =&gt; BbxErrorCode::AllocationFailed,
            _ =&gt; BbxErrorCode::InvalidParameter,
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="error-display"><a class="header" href="#error-display">Error Display</a></h2>
<p><code>BbxError</code> implements <code>Display</code> for human-readable messages:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::BbxError;

let err = BbxError::InvalidParameter("sample rate".to_string());
println!("{}", err);  // "Invalid parameter: sample rate"
<span class="boring">}</span></code></pre>
<h2 id="integration-with-stderrorerror"><a class="header" href="#integration-with-stderrorerror">Integration with std::error::Error</a></h2>
<p><code>BbxError</code> implements <code>std::error::Error</code>, allowing integration with standard error handling:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::BbxError;
use std::error::Error;

fn example() -&gt; std::result::Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let result = something_that_returns_bbx_result()?;
    Ok(())
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bbx_dsp"><a class="header" href="#bbx_dsp">bbx_dsp</a></h1>
<p>A block-based audio DSP system for building signal processing graphs.</p>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>bbx_dsp is the core DSP crate providing:</p>
<ul>
<li>Graph-based architecture for connecting DSP blocks</li>
<li>Automatic topological sorting for correct execution order</li>
<li>Real-time safe processing with stack-allocated buffers</li>
<li>Parameter modulation via LFOs and envelopes</li>
</ul>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<pre><code class="language-toml">[dependencies]
bbx_dsp = "0.1"
</code></pre>
<h2 id="features-1"><a class="header" href="#features-1">Features</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="#graph-and-graphbuilder">Graph</a></td><td>Block graph and builder</td></tr>
<tr><td><a href="#block-trait">Block Trait</a></td><td>Interface for DSP blocks</td></tr>
<tr><td><a href="#blocktype-enum">BlockType</a></td><td>Enum wrapping all blocks</td></tr>
<tr><td><a href="#sample-trait">Sample</a></td><td>Generic sample type trait</td></tr>
<tr><td><a href="#dspcontext-1">DspContext</a></td><td>Processing context</td></tr>
<tr><td><a href="#parameter-system-1">Parameters</a></td><td>Modulation system</td></tr>
</tbody>
</table>
</div>
<h2 id="quick-example-2"><a class="header" href="#quick-example-2">Quick Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

// Create a graph: 44.1kHz, 512 samples, stereo
let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Add blocks
let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let gain = builder.add_gain(-6.0);

// Connect: oscillator -&gt; gain
builder.connect(osc, 0, gain, 0);

// Build the graph
let mut graph = builder.build();

// Process audio
let mut left = vec![0.0f32; 512];
let mut right = vec![0.0f32; 512];
let mut outputs: [&amp;mut [f32]; 2] = [&amp;mut left, &amp;mut right];
graph.process_buffers(&amp;mut outputs);
<span class="boring">}</span></code></pre>
<h2 id="block-categories"><a class="header" href="#block-categories">Block Categories</a></h2>
<h3 id="generators"><a class="header" href="#generators">Generators</a></h3>
<p>Blocks that create audio signals:</p>
<ul>
<li><code>OscillatorBlock</code> - Waveform generator</li>
</ul>
<h3 id="effectors"><a class="header" href="#effectors">Effectors</a></h3>
<p>Blocks that process audio:</p>
<ul>
<li><code>GainBlock</code> - Level control</li>
<li><code>PannerBlock</code> - Stereo panning</li>
<li><code>OverdriveBlock</code> - Distortion</li>
<li><code>DcBlockerBlock</code> - DC removal</li>
<li><code>ChannelRouterBlock</code> - Channel routing</li>
</ul>
<h3 id="modulators"><a class="header" href="#modulators">Modulators</a></h3>
<p>Blocks that generate control signals:</p>
<ul>
<li><code>LfoBlock</code> - Low-frequency oscillator</li>
<li><code>EnvelopeBlock</code> - ADSR envelope</li>
</ul>
<h3 id="io"><a class="header" href="#io">I/O</a></h3>
<p>Blocks for input/output:</p>
<ul>
<li><code>FileInputBlock</code> - Audio file input</li>
<li><code>FileOutputBlock</code> - Audio file output</li>
<li><code>OutputBlock</code> - Graph output</li>
</ul>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<p>The DSP system uses a pull model:</p>
<ol>
<li><code>GraphBuilder</code> collects blocks and connections</li>
<li><code>build()</code> creates an optimized <code>Graph</code></li>
<li>Topological sorting determines execution order</li>
<li><code>process_buffers()</code> runs all blocks in order</li>
</ol>
<p>See <a href="#dsp-graph-architecture">DSP Graph Architecture</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="graph-and-graphbuilder"><a class="header" href="#graph-and-graphbuilder">Graph and GraphBuilder</a></h1>
<p>The core types for building and processing DSP graphs.</p>
<h2 id="graphbuilder-1"><a class="header" href="#graphbuilder-1">GraphBuilder</a></h2>
<p><code>GraphBuilder</code> provides a fluent API for constructing DSP graphs.</p>
<h3 id="creating-a-builder"><a class="header" href="#creating-a-builder">Creating a Builder</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;

let mut builder = GraphBuilder::&lt;f32&gt;::new(
    44100.0,  // sample rate
    512,      // buffer size
    2,        // channels
);
<span class="boring">}</span></code></pre>
<h3 id="adding-blocks"><a class="header" href="#adding-blocks">Adding Blocks</a></h3>
<p>Each <code>add_*</code> method returns a <code>BlockId</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let gain = builder.add_gain(-6.0);
let pan = builder.add_panner(0.0);
<span class="boring">}</span></code></pre>
<h3 id="connecting-blocks-1"><a class="header" href="#connecting-blocks-1">Connecting Blocks</a></h3>
<p>Connect block outputs to inputs:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// connect(from_block, from_port, to_block, to_port)
builder.connect(osc, 0, gain, 0);
builder.connect(gain, 0, pan, 0);
<span class="boring">}</span></code></pre>
<h3 id="building-the-graph"><a class="header" href="#building-the-graph">Building the Graph</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let graph = builder.build();
<span class="boring">}</span></code></pre>
<p>The build process:</p>
<ol>
<li>Validates all connections</li>
<li>Performs topological sorting</li>
<li>Allocates processing buffers</li>
<li>Returns an optimized <code>Graph</code></li>
</ol>
<h2 id="graph"><a class="header" href="#graph">Graph</a></h2>
<p><code>Graph</code> is the compiled, ready-to-process DSP graph.</p>
<h3 id="processing-audio-1"><a class="header" href="#processing-audio-1">Processing Audio</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut left = vec![0.0f32; 512];
let mut right = vec![0.0f32; 512];
let mut outputs: [&amp;mut [f32]; 2] = [&amp;mut left, &amp;mut right];

graph.process_buffers(&amp;mut outputs);
<span class="boring">}</span></code></pre>
<h3 id="preparing-for-playback"><a class="header" href="#preparing-for-playback">Preparing for Playback</a></h3>
<p>Call <code>prepare()</code> when audio specs change:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::context::DspContext;

let context = DspContext::new(48000.0, 1024, 2);
graph.prepare(&amp;context);
<span class="boring">}</span></code></pre>
<h3 id="resetting-state"><a class="header" href="#resetting-state">Resetting State</a></h3>
<p>Clear all DSP state (filters, delay lines, etc.):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>graph.reset();
<span class="boring">}</span></code></pre>
<h3 id="finalization"><a class="header" href="#finalization">Finalization</a></h3>
<p>For file output, call <code>finalize()</code> to flush buffers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>graph.finalize();
<span class="boring">}</span></code></pre>
<h2 id="blockid"><a class="header" href="#blockid">BlockId</a></h2>
<p>A handle to a block in the graph:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let osc: BlockId = builder.add_oscillator(440.0, Waveform::Sine, None);
<span class="boring">}</span></code></pre>
<p><code>BlockId</code> is used for:</p>
<ul>
<li>Connecting blocks</li>
<li>Referencing modulators</li>
<li>Accessing block state (if needed)</li>
</ul>
<h2 id="connection-rules"><a class="header" href="#connection-rules">Connection Rules</a></h2>
<ul>
<li>Each output can connect to multiple inputs</li>
<li>Each input can receive multiple connections (summed)</li>
<li>Cycles are not allowed (topological sorting will fail)</li>
<li>Unconnected blocks are still processed</li>
</ul>
<h2 id="example-complex-graph"><a class="header" href="#example-complex-graph">Example: Complex Graph</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Create two oscillators
let osc1 = builder.add_oscillator(440.0, Waveform::Saw, None);
let osc2 = builder.add_oscillator(441.0, Waveform::Saw, None);  // Slight detune

// Mix them
let mixer = builder.add_gain(-6.0);
builder.connect(osc1, 0, mixer, 0);
builder.connect(osc2, 0, mixer, 0);

// Add effects
let overdrive = builder.add_overdrive(3.0, 1.0, 0.8, 44100.0);
let dc_blocker = builder.add_dc_blocker();
let pan = builder.add_panner(0.0);

// Chain effects
builder.connect(mixer, 0, overdrive, 0);
builder.connect(overdrive, 0, dc_blocker, 0);
builder.connect(dc_blocker, 0, pan, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="block-trait"><a class="header" href="#block-trait">Block Trait</a></h1>
<p>The <code>Block</code> trait defines the interface for DSP processing blocks.</p>
<h2 id="trait-definition"><a class="header" href="#trait-definition">Trait Definition</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Block&lt;S: Sample&gt;: Send {
    /// Process audio through the block
    fn process(
        &amp;mut self,
        inputs: &amp;[&amp;[S]],
        outputs: &amp;mut [&amp;mut [S]],
        context: &amp;DspContext,
        modulation: &amp;[S],
    );

    /// Number of input ports
    fn num_inputs(&amp;self) -&gt; usize;

    /// Number of output ports
    fn num_outputs(&amp;self) -&gt; usize;

    /// Number of modulation outputs (for LFOs, envelopes)
    fn num_modulation_outputs(&amp;self) -&gt; usize {
        0  // Default: no modulation outputs
    }

    /// Prepare for playback with given context
    fn prepare(&amp;mut self, _context: &amp;DspContext) {}

    /// Reset DSP state
    fn reset(&amp;mut self) {}

    /// Finalize (for file output blocks)
    fn finalize(&amp;mut self) {}
}
<span class="boring">}</span></code></pre>
<h2 id="implementing-a-custom-block"><a class="header" href="#implementing-a-custom-block">Implementing a Custom Block</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{block::Block, context::DspContext, sample::Sample};

struct MyGainBlock&lt;S: Sample&gt; {
    gain: S,
}

impl&lt;S: Sample&gt; MyGainBlock&lt;S&gt; {
    fn new(gain_db: f64) -&gt; Self {
        let linear = (10.0_f64).powf(gain_db / 20.0);
        Self {
            gain: S::from_f64(linear),
        }
    }
}

impl&lt;S: Sample&gt; Block&lt;S&gt; for MyGainBlock&lt;S&gt; {
    fn process(
        &amp;mut self,
        inputs: &amp;[&amp;[S]],
        outputs: &amp;mut [&amp;mut [S]],
        context: &amp;DspContext,
        _modulation: &amp;[S],
    ) {
        for ch in 0..inputs.len().min(outputs.len()) {
            for i in 0..context.buffer_size {
                outputs[ch][i] = inputs[ch][i] * self.gain;
            }
        }
    }

    fn num_inputs(&amp;self) -&gt; usize { 1 }
    fn num_outputs(&amp;self) -&gt; usize { 1 }
}
<span class="boring">}</span></code></pre>
<h2 id="process-method"><a class="header" href="#process-method">Process Method</a></h2>
<p>The <code>process</code> method receives:</p>
<ul>
<li><code>inputs</code> - Slice of input channel buffers</li>
<li><code>outputs</code> - Mutable slice of output channel buffers</li>
<li><code>context</code> - Processing context (sample rate, buffer size)</li>
<li><code>modulation</code> - Values from connected modulator blocks</li>
</ul>
<h3 id="inputoutput-layout"><a class="header" href="#inputoutput-layout">Input/Output Layout</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process(
    &amp;mut self,
    inputs: &amp;[&amp;[S]],      // inputs[channel][sample]
    outputs: &amp;mut [&amp;mut [S]],  // outputs[channel][sample]
    context: &amp;DspContext,
    modulation: &amp;[S],
) {
    // inputs.len() = number of input channels
    // inputs[0].len() = number of samples per channel
}
<span class="boring">}</span></code></pre>
<h3 id="modulation-values"><a class="header" href="#modulation-values">Modulation Values</a></h3>
<p>For blocks that receive modulation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process(
    &amp;mut self,
    inputs: &amp;[&amp;[S]],
    outputs: &amp;mut [&amp;mut [S]],
    context: &amp;DspContext,
    modulation: &amp;[S],
) {
    // modulation[0] = value from first connected modulator
    // Use for per-block (not per-sample) modulation
    let mod_depth = modulation.get(0).copied().unwrap_or(S::ZERO);
}
<span class="boring">}</span></code></pre>
<h2 id="port-counts"><a class="header" href="#port-counts">Port Counts</a></h2>
<h3 id="num_inputs--num_outputs"><a class="header" href="#num_inputs--num_outputs">num_inputs / num_outputs</a></h3>
<p>Return the number of audio ports:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Mono effect
fn num_inputs(&amp;self) -&gt; usize { 1 }
fn num_outputs(&amp;self) -&gt; usize { 1 }

// Stereo panner
fn num_inputs(&amp;self) -&gt; usize { 1 }
fn num_outputs(&amp;self) -&gt; usize { 2 }

// Mixer (4 inputs, 1 output)
fn num_inputs(&amp;self) -&gt; usize { 4 }
fn num_outputs(&amp;self) -&gt; usize { 1 }
<span class="boring">}</span></code></pre>
<h3 id="num_modulation_outputs"><a class="header" href="#num_modulation_outputs">num_modulation_outputs</a></h3>
<p>For modulator blocks (LFO, envelope):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn num_modulation_outputs(&amp;self) -&gt; usize { 1 }
<span class="boring">}</span></code></pre>
<h2 id="lifecycle-methods"><a class="header" href="#lifecycle-methods">Lifecycle Methods</a></h2>
<h3 id="prepare-2"><a class="header" href="#prepare-2">prepare</a></h3>
<p>Called when audio specs change:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prepare(&amp;mut self, context: &amp;DspContext) {
    // Recalculate filter coefficients for new sample rate
    self.coefficient = calculate_coefficient(context.sample_rate);
}
<span class="boring">}</span></code></pre>
<h3 id="reset-2"><a class="header" href="#reset-2">reset</a></h3>
<p>Clear all state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reset(&amp;mut self) {
    self.filter_state = 0.0;
    self.delay_buffer.fill(0.0);
}
<span class="boring">}</span></code></pre>
<h3 id="finalize"><a class="header" href="#finalize">finalize</a></h3>
<p>For file output blocks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn finalize(&amp;mut self) {
    self.writer.flush().ok();
}
<span class="boring">}</span></code></pre>
<h2 id="thread-safety-1"><a class="header" href="#thread-safety-1">Thread Safety</a></h2>
<p>The <code>Send</code> bound ensures blocks can be sent to the audio thread. Blocks should:</p>
<ul>
<li>Avoid allocating memory in <code>process()</code></li>
<li>Use atomic operations for cross-thread communication</li>
<li>Never block or lock</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="blocktype-enum"><a class="header" href="#blocktype-enum">BlockType Enum</a></h1>
<p><code>BlockType</code> is an enum that wraps all concrete block implementations.</p>
<h2 id="overview-10"><a class="header" href="#overview-10">Overview</a></h2>
<p>The graph system uses <code>BlockType</code> to store heterogeneous blocks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum BlockType&lt;S: Sample&gt; {
    // Generators
    Oscillator(OscillatorBlock&lt;S&gt;),

    // Effectors
    Gain(GainBlock&lt;S&gt;),
    Panner(PannerBlock&lt;S&gt;),
    Overdrive(OverdriveBlock&lt;S&gt;),
    DcBlocker(DcBlockerBlock&lt;S&gt;),
    ChannelRouter(ChannelRouterBlock&lt;S&gt;),

    // Modulators
    Lfo(LfoBlock&lt;S&gt;),
    Envelope(EnvelopeBlock&lt;S&gt;),

    // I/O
    FileInput(FileInputBlock&lt;S&gt;),
    FileOutput(FileOutputBlock&lt;S&gt;),
    Output(OutputBlock&lt;S&gt;),
}
<span class="boring">}</span></code></pre>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p><code>BlockType</code> is primarily used internally by the graph system. Users interact with blocks through <code>GraphBuilder</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// These return BlockId, not BlockType
let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let gain = builder.add_gain(-6.0);
<span class="boring">}</span></code></pre>
<h2 id="block-trait-implementation"><a class="header" href="#block-trait-implementation">Block Trait Implementation</a></h2>
<p><code>BlockType</code> implements <code>Block</code> by delegating to the wrapped type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;S: Sample&gt; Block&lt;S&gt; for BlockType&lt;S&gt; {
    fn process(
        &amp;mut self,
        inputs: &amp;[&amp;[S]],
        outputs: &amp;mut [&amp;mut [S]],
        context: &amp;DspContext,
        modulation: &amp;[S],
    ) {
        match self {
            BlockType::Oscillator(b) =&gt; b.process(inputs, outputs, context, modulation),
            BlockType::Gain(b) =&gt; b.process(inputs, outputs, context, modulation),
            // ... etc
        }
    }

    fn num_inputs(&amp;self) -&gt; usize {
        match self {
            BlockType::Oscillator(b) =&gt; b.num_inputs(),
            BlockType::Gain(b) =&gt; b.num_inputs(),
            // ... etc
        }
    }

    // ... other methods
}
<span class="boring">}</span></code></pre>
<h2 id="adding-custom-blocks"><a class="header" href="#adding-custom-blocks">Adding Custom Blocks</a></h2>
<p>To add a custom block type, you would need to:</p>
<ol>
<li>Implement <code>Block&lt;S&gt;</code> for your block</li>
<li>Add a variant to <code>BlockType</code></li>
<li>Update all match arms in <code>BlockType</code>’s <code>Block</code> implementation</li>
<li>Add a builder method to <code>GraphBuilder</code></li>
</ol>
<p>For plugin development, consider using <code>PluginDsp</code> instead, which doesn’t require modifying <code>BlockType</code>.</p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>If you need to access the inner block type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::block::BlockType;

fn get_oscillator_frequency&lt;S: Sample&gt;(block: &amp;BlockType&lt;S&gt;) -&gt; Option&lt;f64&gt; {
    match block {
        BlockType::Oscillator(osc) =&gt; Some(osc.frequency()),
        _ =&gt; None,
    }
}
<span class="boring">}</span></code></pre>
<h2 id="block-categories-1"><a class="header" href="#block-categories-1">Block Categories</a></h2>
<p>Blocks are organized into categories:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Variants</th></tr>
</thead>
<tbody>
<tr><td>Generators</td><td><code>Oscillator</code></td></tr>
<tr><td>Effectors</td><td><code>Gain</code>, <code>Panner</code>, <code>Overdrive</code>, <code>DcBlocker</code>, <code>ChannelRouter</code></td></tr>
<tr><td>Modulators</td><td><code>Lfo</code>, <code>Envelope</code></td></tr>
<tr><td>I/O</td><td><code>FileInput</code>, <code>FileOutput</code>, <code>Output</code></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sample-trait"><a class="header" href="#sample-trait">Sample Trait</a></h1>
<p>The <code>Sample</code> trait abstracts over audio sample types (f32, f64).</p>
<h2 id="trait-definition-1"><a class="header" href="#trait-definition-1">Trait Definition</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Sample:
    Copy
    + Clone
    + Default
    + Send
    + Sync
    + PartialOrd
    + std::ops::Add&lt;Output = Self&gt;
    + std::ops::Sub&lt;Output = Self&gt;
    + std::ops::Mul&lt;Output = Self&gt;
    + std::ops::Div&lt;Output = Self&gt;
    + std::ops::AddAssign
    + std::ops::SubAssign
    + std::ops::MulAssign
    + std::ops::Neg&lt;Output = Self&gt;
    + 'static
{
    /// Zero value
    const ZERO: Self;

    /// One value
    const ONE: Self;

    /// Minimum representable value
    const MIN: Self;

    /// Maximum representable value
    const MAX: Self;

    /// Convert from f32
    fn from_f32(value: f32) -&gt; Self;

    /// Convert from f64
    fn from_f64(value: f64) -&gt; Self;

    /// Convert to f32
    fn to_f32(self) -&gt; f32;

    /// Convert to f64
    fn to_f64(self) -&gt; f64;

    /// Absolute value
    fn abs(self) -&gt; Self;

    /// Sine function
    fn sin(self) -&gt; Self;

    /// Cosine function
    fn cos(self) -&gt; Self;

    /// Power function
    fn powf(self, n: Self) -&gt; Self;

    /// Square root
    fn sqrt(self) -&gt; Self;

    /// Floor
    fn floor(self) -&gt; Self;

    /// Clamp to range
    fn clamp(self, min: Self, max: Self) -&gt; Self;
}
<span class="boring">}</span></code></pre>
<h2 id="implementations"><a class="header" href="#implementations">Implementations</a></h2>
<p>The trait is implemented for <code>f32</code> and <code>f64</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Sample for f32 {
    const ZERO: Self = 0.0;
    const ONE: Self = 1.0;
    const MIN: Self = f32::MIN;
    const MAX: Self = f32::MAX;

    fn from_f32(value: f32) -&gt; Self { value }
    fn from_f64(value: f64) -&gt; Self { value as f32 }
    fn to_f32(self) -&gt; f32 { self }
    fn to_f64(self) -&gt; f64 { self as f64 }
    // ... etc
}

impl Sample for f64 {
    const ZERO: Self = 0.0;
    const ONE: Self = 1.0;
    // ... etc
}
<span class="boring">}</span></code></pre>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<h3 id="generic-dsp-code"><a class="header" href="#generic-dsp-code">Generic DSP Code</a></h3>
<p>Write DSP code that works with any sample type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::sample::Sample;

fn apply_gain&lt;S: Sample&gt;(samples: &amp;mut [S], gain_db: f64) {
    let linear = S::from_f64((10.0_f64).powf(gain_db / 20.0));
    for sample in samples {
        *sample = *sample * linear;
    }
}

// Works with both f32 and f64
let mut samples_f32: Vec&lt;f32&gt; = vec![0.5, 0.3, 0.1];
let mut samples_f64: Vec&lt;f64&gt; = vec![0.5, 0.3, 0.1];

apply_gain(&amp;mut samples_f32, -6.0);
apply_gain(&amp;mut samples_f64, -6.0);
<span class="boring">}</span></code></pre>
<h3 id="using-constants"><a class="header" href="#using-constants">Using Constants</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::sample::Sample;

fn normalize&lt;S: Sample&gt;(samples: &amp;mut [S]) {
    let max = samples.iter()
        .map(|s| s.abs())
        .fold(S::ZERO, |a, b| if a &gt; b { a } else { b });

    if max &gt; S::ZERO {
        for sample in samples {
            *sample = *sample / max;
        }
    }
}
<span class="boring">}</span></code></pre>
<h3 id="converting-types"><a class="header" href="#converting-types">Converting Types</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::sample::Sample;

fn to_16bit&lt;S: Sample&gt;(sample: S) -&gt; i16 {
    let clamped = sample.clamp(S::from_f32(-1.0), S::from_f32(1.0));
    (clamped.to_f64() * 32767.0) as i16
}
<span class="boring">}</span></code></pre>
<h2 id="choosing-a-sample-type"><a class="header" href="#choosing-a-sample-type">Choosing a Sample Type</a></h2>
<h3 id="f32-recommended"><a class="header" href="#f32-recommended">f32 (Recommended)</a></h3>
<ul>
<li>Smaller memory footprint</li>
<li>Faster SIMD operations</li>
<li>Sufficient precision for most audio work</li>
<li>Standard for most audio APIs</li>
</ul>
<h3 id="f64"><a class="header" href="#f64">f64</a></h3>
<ul>
<li>Higher precision for:
<ul>
<li>Long delay lines</li>
<li>Accumulating filters</li>
<li>Scientific/measurement applications</li>
</ul>
</li>
<li>Common in offline processing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dspcontext-1"><a class="header" href="#dspcontext-1">DspContext</a></h1>
<p><code>DspContext</code> holds audio processing parameters passed to DSP blocks.</p>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DspContext {
    /// Sample rate in Hz
    pub sample_rate: f64,

    /// Number of samples per buffer
    pub buffer_size: usize,

    /// Number of audio channels
    pub num_channels: usize,
}
<span class="boring">}</span></code></pre>
<h2 id="creating-a-context"><a class="header" href="#creating-a-context">Creating a Context</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::context::DspContext;

let context = DspContext::new(44100.0, 512, 2);
<span class="boring">}</span></code></pre>
<h3 id="default-constants"><a class="header" href="#default-constants">Default Constants</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::context::{DEFAULT_SAMPLE_RATE, DEFAULT_BUFFER_SIZE};

// DEFAULT_SAMPLE_RATE = 44100.0
// DEFAULT_BUFFER_SIZE = 512
<span class="boring">}</span></code></pre>
<h2 id="usage-in-blocks"><a class="header" href="#usage-in-blocks">Usage in Blocks</a></h2>
<p>Context is passed to all block methods:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{block::Block, context::DspContext, sample::Sample};

impl&lt;S: Sample&gt; Block&lt;S&gt; for MyBlock&lt;S&gt; {
    fn process(
        &amp;mut self,
        inputs: &amp;[&amp;[S]],
        outputs: &amp;mut [&amp;mut [S]],
        context: &amp;DspContext,
        modulation: &amp;[S],
    ) {
        // Use context values
        let sample_rate = context.sample_rate;
        let buffer_size = context.buffer_size;

        for i in 0..buffer_size {
            // Process samples
        }
    }

    fn prepare(&amp;mut self, context: &amp;DspContext) {
        // Recalculate coefficients based on sample rate
        self.coefficient = self.calculate_coefficient(context.sample_rate);
    }
}
<span class="boring">}</span></code></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="sample-rate-dependent-calculations"><a class="header" href="#sample-rate-dependent-calculations">Sample Rate Dependent Calculations</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::context::DspContext;

fn calculate_filter_coefficient(cutoff_hz: f64, context: &amp;DspContext) -&gt; f64 {
    let normalized_freq = cutoff_hz / context.sample_rate;
    // Calculate coefficient...
    1.0 - (-2.0 * std::f64::consts::PI * normalized_freq).exp()
}
<span class="boring">}</span></code></pre>
<h3 id="time-based-parameters"><a class="header" href="#time-based-parameters">Time-Based Parameters</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::context::DspContext;

fn samples_for_milliseconds(ms: f64, context: &amp;DspContext) -&gt; usize {
    (ms * context.sample_rate / 1000.0) as usize
}

fn samples_for_seconds(seconds: f64, context: &amp;DspContext) -&gt; usize {
    (seconds * context.sample_rate) as usize
}
<span class="boring">}</span></code></pre>
<h3 id="phase-increment"><a class="header" href="#phase-increment">Phase Increment</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::context::DspContext;

fn phase_increment(frequency: f64, context: &amp;DspContext) -&gt; f64 {
    frequency / context.sample_rate
}
<span class="boring">}</span></code></pre>
<h2 id="context-changes"><a class="header" href="#context-changes">Context Changes</a></h2>
<p>When audio specs change (e.g., DAW sample rate changes):</p>
<ol>
<li><code>prepare()</code> is called on all blocks</li>
<li>Blocks should recalculate time-dependent values</li>
<li><code>reset()</code> may also be called to clear state</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prepare(&amp;mut self, context: &amp;DspContext) {
    // Sample rate changed - recalculate everything
    self.phase_increment = self.frequency / context.sample_rate;
    self.filter.recalculate_coefficients(context.sample_rate);

    // Resize buffers if needed
    if self.delay_buffer.len() != context.buffer_size {
        self.delay_buffer.resize(context.buffer_size, 0.0);
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="parameter-system-1"><a class="header" href="#parameter-system-1">Parameter System</a></h1>
<p>The bbx_dsp parameter system supports static values and modulation.</p>
<h2 id="parameter-type"><a class="header" href="#parameter-type">Parameter Type</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Parameter&lt;S: Sample&gt; {
    /// Static value
    Static(S),

    /// Modulated by a block (e.g., LFO)
    Modulated(BlockId),
}
<span class="boring">}</span></code></pre>
<h2 id="static-parameters"><a class="header" href="#static-parameters">Static Parameters</a></h2>
<p>Parameters with fixed values:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::parameter::Parameter;

let gain = Parameter::Static(-6.0_f32);
let frequency = Parameter::Static(440.0_f32);
<span class="boring">}</span></code></pre>
<h2 id="modulated-parameters"><a class="header" href="#modulated-parameters">Modulated Parameters</a></h2>
<p>Parameters controlled by modulator blocks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform, parameter::Parameter};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Create an LFO
let lfo = builder.add_lfo(5.0, Waveform::Sine);

// Use it to modulate oscillator frequency
let osc = builder.add_oscillator(440.0, Waveform::Sine, Some(lfo));
<span class="boring">}</span></code></pre>
<h2 id="modulation-flow"><a class="header" href="#modulation-flow">Modulation Flow</a></h2>
<ol>
<li>Modulator blocks (LFO, Envelope) output control values</li>
<li>These values are collected during graph processing</li>
<li>Target blocks receive values in the <code>modulation</code> parameter</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process(
    &amp;mut self,
    inputs: &amp;[&amp;[S]],
    outputs: &amp;mut [&amp;mut [S]],
    context: &amp;DspContext,
    modulation: &amp;[S],  // Modulation values from connected blocks
) {
    let mod_value = modulation.get(0).copied().unwrap_or(S::ZERO);
    // Use mod_value to affect processing
}
<span class="boring">}</span></code></pre>
<h2 id="modulation-depth-1"><a class="header" href="#modulation-depth-1">Modulation Depth</a></h2>
<p>Blocks interpret modulation values differently:</p>
<h3 id="frequency-modulation-1"><a class="header" href="#frequency-modulation-1">Frequency Modulation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// LFO range: -1.0 to 1.0
// Modulation depth scales this
let mod_range = 0.1;  // ±10% frequency change
let modulated_freq = base_freq * (1.0 + mod_value * mod_range);
<span class="boring">}</span></code></pre>
<h3 id="amplitude-modulation"><a class="header" href="#amplitude-modulation">Amplitude Modulation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// LFO directly scales amplitude
let modulated_amp = base_amp * (1.0 + mod_value);
<span class="boring">}</span></code></pre>
<h3 id="bipolar-vs-unipolar"><a class="header" href="#bipolar-vs-unipolar">Bipolar vs Unipolar</a></h3>
<p>Some modulators are bipolar (-1 to 1), others unipolar (0 to 1):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Convert bipolar to unipolar
let unipolar = (bipolar + 1.0) * 0.5;  // 0.0 to 1.0

// Convert unipolar to bipolar
let bipolar = unipolar * 2.0 - 1.0;  // -1.0 to 1.0
<span class="boring">}</span></code></pre>
<h2 id="example-tremolo"><a class="header" href="#example-tremolo">Example: Tremolo</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Audio source
let osc = builder.add_oscillator(440.0, Waveform::Sine, None);

// Tremolo LFO
let lfo = builder.add_lfo(6.0, Waveform::Sine);

// Gain with modulation
let gain = builder.add_gain_with_modulation(-6.0, Some(lfo));

builder.connect(osc, 0, gain, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<h2 id="example-vibrato"><a class="header" href="#example-vibrato">Example: Vibrato</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Vibrato LFO
let lfo = builder.add_lfo(5.0, Waveform::Sine);

// Oscillator with frequency modulation
let osc = builder.add_oscillator(440.0, Waveform::Sine, Some(lfo));

let graph = builder.build();
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bbx_plugin"><a class="header" href="#bbx_plugin">bbx_plugin</a></h1>
<p>Plugin integration crate for JUCE and other C/C++ frameworks.</p>
<h2 id="overview-11"><a class="header" href="#overview-11">Overview</a></h2>
<p>bbx_plugin provides:</p>
<ul>
<li>Re-exports of <code>bbx_dsp</code> for single-dependency usage</li>
<li><code>PluginDsp</code> trait for plugin DSP implementations</li>
<li><code>bbx_plugin_ffi!</code> macro for generating C FFI exports</li>
<li>Parameter definition and code generation utilities</li>
</ul>
<h2 id="installation-3"><a class="header" href="#installation-3">Installation</a></h2>
<pre><code class="language-toml">[package]
name = "my_plugin_dsp"
edition = "2024"

[lib]
crate-type = ["staticlib"]

[dependencies]
bbx_plugin = "0.1"
</code></pre>
<h2 id="features-2"><a class="header" href="#features-2">Features</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="#plugindsp-trait">PluginDsp Trait</a></td><td>Interface for plugin DSP</td></tr>
<tr><td><a href="#ffi-macro">FFI Macro</a></td><td>Generate C exports</td></tr>
<tr><td><a href="#parameter-definitions">Parameter Definitions</a></td><td>JSON and programmatic params</td></tr>
</tbody>
</table>
</div>
<h2 id="quick-example-3"><a class="header" href="#quick-example-3">Quick Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::{PluginDsp, DspContext, bbx_plugin_ffi};

pub struct MyPlugin {
    gain: f32,
}

impl Default for MyPlugin {
    fn default() -&gt; Self { Self::new() }
}

impl PluginDsp for MyPlugin {
    fn new() -&gt; Self {
        Self { gain: 1.0 }
    }

    fn prepare(&amp;mut self, _context: &amp;DspContext) {}

    fn reset(&amp;mut self) {}

    fn apply_parameters(&amp;mut self, params: &amp;[f32]) {
        self.gain = params.get(0).copied().unwrap_or(1.0);
    }

    fn process(
        &amp;mut self,
        inputs: &amp;[&amp;[f32]],
        outputs: &amp;mut [&amp;mut [f32]],
        context: &amp;DspContext,
    ) {
        for ch in 0..inputs.len().min(outputs.len()) {
            for i in 0..context.buffer_size {
                outputs[ch][i] = inputs[ch][i] * self.gain;
            }
        }
    }
}

// Generate FFI exports
bbx_plugin_ffi!(MyPlugin);
<span class="boring">}</span></code></pre>
<h2 id="re-exports"><a class="header" href="#re-exports">Re-exports</a></h2>
<p>bbx_plugin re-exports key types from bbx_dsp:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All available from bbx_plugin directly
use bbx_plugin::{
    PluginDsp,
    DspContext,
    blocks::{GainBlock, PannerBlock, OscillatorBlock},
    waveform::Waveform,
};
<span class="boring">}</span></code></pre>
<h2 id="juce-integration"><a class="header" href="#juce-integration">JUCE Integration</a></h2>
<p>For complete integration guide, see <a href="#juce-plugin-integration-overview">JUCE Plugin Integration</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="plugindsp-trait"><a class="header" href="#plugindsp-trait">PluginDsp Trait</a></h1>
<p>The <code>PluginDsp</code> trait defines the interface for plugin DSP implementations.</p>
<h2 id="definition-1"><a class="header" href="#definition-1">Definition</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait PluginDsp: Default + Send + 'static {
    fn new() -&gt; Self;
    fn prepare(&amp;mut self, context: &amp;DspContext);
    fn reset(&amp;mut self);
    fn apply_parameters(&amp;mut self, params: &amp;[f32]);
    fn process(&amp;mut self, inputs: &amp;[&amp;[f32]], outputs: &amp;mut [&amp;mut [f32]], context: &amp;DspContext);
}
<span class="boring">}</span></code></pre>
<h2 id="trait-bounds-1"><a class="header" href="#trait-bounds-1">Trait Bounds</a></h2>
<ul>
<li><strong><code>Default</code></strong> - Required for FFI instantiation</li>
<li><strong><code>Send</code></strong> - Safe to transfer to audio thread</li>
<li><strong><code>'static</code></strong> - No borrowed references</li>
</ul>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<h3 id="new-1"><a class="header" href="#new-1">new</a></h3>
<p>Create a new instance with default state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new() -&gt; Self {
    Self {
        gain: 0.0,
        filter_state: 0.0,
    }
}
<span class="boring">}</span></code></pre>
<h3 id="prepare-3"><a class="header" href="#prepare-3">prepare</a></h3>
<p>Called when audio specs change:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prepare(&amp;mut self, context: &amp;DspContext) {
    // Update sample-rate dependent calculations
    self.filter_coefficient = calculate_coefficient(
        self.cutoff_hz,
        context.sample_rate,
    );
}
<span class="boring">}</span></code></pre>
<h3 id="reset-3"><a class="header" href="#reset-3">reset</a></h3>
<p>Clear all DSP state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reset(&amp;mut self) {
    self.filter_state = 0.0;
    self.delay_buffer.fill(0.0);
}
<span class="boring">}</span></code></pre>
<h3 id="apply_parameters-1"><a class="header" href="#apply_parameters-1">apply_parameters</a></h3>
<p>Map parameter array to DSP state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_parameters(&amp;mut self, params: &amp;[f32]) {
    if let Some(&amp;gain) = params.get(0) {
        self.gain = gain;
    }
    if let Some(&amp;pan) = params.get(1) {
        self.pan = pan;
    }
}
<span class="boring">}</span></code></pre>
<h3 id="process-2"><a class="header" href="#process-2">process</a></h3>
<p>Process audio buffers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process(
    &amp;mut self,
    inputs: &amp;[&amp;[f32]],
    outputs: &amp;mut [&amp;mut [f32]],
    context: &amp;DspContext,
) {
    for ch in 0..inputs.len().min(outputs.len()) {
        for i in 0..context.buffer_size {
            outputs[ch][i] = inputs[ch][i] * self.gain;
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="implementation-requirements"><a class="header" href="#implementation-requirements">Implementation Requirements</a></h2>
<h3 id="default-implementation"><a class="header" href="#default-implementation">Default Implementation</a></h3>
<p>You must implement <code>Default</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for MyPlugin {
    fn default() -&gt; Self {
        Self::new()
    }
}
<span class="boring">}</span></code></pre>
<h3 id="no-allocations-in-process"><a class="header" href="#no-allocations-in-process">No Allocations in process()</a></h3>
<p>The <code>process</code> method runs on the audio thread. Avoid:</p>
<ul>
<li>Memory allocation (<code>Vec::new()</code>, <code>Box::new()</code>)</li>
<li>Locking (<code>Mutex::lock()</code>)</li>
<li>I/O operations</li>
</ul>
<h3 id="thread-safety-2"><a class="header" href="#thread-safety-2">Thread Safety</a></h3>
<p>The plugin may be moved between threads. Use:</p>
<ul>
<li><code>AtomicF32</code> for cross-thread values</li>
<li>SPSC queues for message passing</li>
<li>No thread-local storage</li>
</ul>
<h2 id="complete-example-3"><a class="header" href="#complete-example-3">Complete Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::{PluginDsp, DspContext, bbx_plugin_ffi};

const PARAM_GAIN: usize = 0;
const PARAM_PAN: usize = 1;

pub struct StereoGain {
    gain: f32,
    pan: f32,
}

impl Default for StereoGain {
    fn default() -&gt; Self { Self::new() }
}

impl PluginDsp for StereoGain {
    fn new() -&gt; Self {
        Self { gain: 1.0, pan: 0.0 }
    }

    fn prepare(&amp;mut self, _context: &amp;DspContext) {
        // Nothing sample-rate dependent
    }

    fn reset(&amp;mut self) {
        // No state to reset
    }

    fn apply_parameters(&amp;mut self, params: &amp;[f32]) {
        self.gain = 10.0_f32.powf(params.get(PARAM_GAIN).copied().unwrap_or(0.0) / 20.0);
        self.pan = params.get(PARAM_PAN).copied().unwrap_or(0.0);
    }

    fn process(
        &amp;mut self,
        inputs: &amp;[&amp;[f32]],
        outputs: &amp;mut [&amp;mut [f32]],
        context: &amp;DspContext,
    ) {
        let pan_rad = self.pan * std::f32::consts::FRAC_PI_4;
        let left_gain = self.gain * (std::f32::consts::FRAC_PI_4 - pan_rad).cos();
        let right_gain = self.gain * (std::f32::consts::FRAC_PI_4 + pan_rad).cos();

        if inputs.len() &gt;= 2 &amp;&amp; outputs.len() &gt;= 2 {
            for i in 0..context.buffer_size {
                outputs[0][i] = inputs[0][i] * left_gain;
                outputs[1][i] = inputs[1][i] * right_gain;
            }
        }
    }
}

bbx_plugin_ffi!(StereoGain);
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ffi-macro"><a class="header" href="#ffi-macro">FFI Macro</a></h1>
<p>The <code>bbx_plugin_ffi!</code> macro generates C FFI exports for a <code>PluginDsp</code> implementation.</p>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::{PluginDsp, bbx_plugin_ffi};

pub struct MyPlugin { /* ... */ }

impl PluginDsp for MyPlugin { /* ... */ }

// Generate all FFI functions
bbx_plugin_ffi!(MyPlugin);
<span class="boring">}</span></code></pre>
<h2 id="generated-functions-1"><a class="header" href="#generated-functions-1">Generated Functions</a></h2>
<p>The macro generates these extern “C” functions:</p>
<h3 id="bbx_graph_create-1"><a class="header" href="#bbx_graph_create-1">bbx_graph_create</a></h3>
<pre><code class="language-c">BbxGraph* bbx_graph_create(void);
</code></pre>
<p>Creates a new DSP instance. Returns NULL on allocation failure.</p>
<h3 id="bbx_graph_destroy-1"><a class="header" href="#bbx_graph_destroy-1">bbx_graph_destroy</a></h3>
<pre><code class="language-c">void bbx_graph_destroy(BbxGraph* handle);
</code></pre>
<p>Destroys the DSP instance. Safe to call with NULL.</p>
<h3 id="bbx_graph_prepare-1"><a class="header" href="#bbx_graph_prepare-1">bbx_graph_prepare</a></h3>
<pre><code class="language-c">BbxError bbx_graph_prepare(
    BbxGraph* handle,
    double sample_rate,
    uint32_t buffer_size,
    uint32_t num_channels
);
</code></pre>
<p>Prepares for playback. Calls <code>PluginDsp::prepare()</code>.</p>
<h3 id="bbx_graph_reset-1"><a class="header" href="#bbx_graph_reset-1">bbx_graph_reset</a></h3>
<pre><code class="language-c">BbxError bbx_graph_reset(BbxGraph* handle);
</code></pre>
<p>Resets DSP state. Calls <code>PluginDsp::reset()</code>.</p>
<h3 id="bbx_graph_process-1"><a class="header" href="#bbx_graph_process-1">bbx_graph_process</a></h3>
<pre><code class="language-c">void bbx_graph_process(
    BbxGraph* handle,
    const float* const* inputs,
    float* const* outputs,
    uint32_t num_channels,
    uint32_t num_samples,
    const float* params,
    uint32_t num_params
);
</code></pre>
<p>Processes audio. Calls <code>PluginDsp::apply_parameters()</code> then <code>PluginDsp::process()</code>.</p>
<h2 id="internal-types"><a class="header" href="#internal-types">Internal Types</a></h2>
<h3 id="bbxgraph-1"><a class="header" href="#bbxgraph-1">BbxGraph</a></h3>
<p>Opaque handle to the Rust DSP:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct BbxGraph {
    _private: [u8; 0],
}
<span class="boring">}</span></code></pre>
<p>Never dereference - it’s a type-erased pointer to <code>GraphInner&lt;T&gt;</code>.</p>
<h3 id="bbxerror-2"><a class="header" href="#bbxerror-2">BbxError</a></h3>
<p>Error codes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub enum BbxError {
    Ok = 0,
    NullPointer = 1,
    InvalidParameter = 2,
    InvalidBufferSize = 3,
    GraphNotPrepared = 4,
    AllocationFailed = 5,
}
<span class="boring">}</span></code></pre>
<h2 id="macro-expansion"><a class="header" href="#macro-expansion">Macro Expansion</a></h2>
<p>The macro expands to roughly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type PluginGraphInner = GraphInner&lt;MyPlugin&gt;;

#[no_mangle]
pub extern "C" fn bbx_graph_create() -&gt; *mut BbxGraph {
    let inner = Box::new(PluginGraphInner::new());
    handle_from_graph(inner)
}

#[no_mangle]
pub extern "C" fn bbx_graph_destroy(handle: *mut BbxGraph) {
    if !handle.is_null() {
        unsafe {
            drop(Box::from_raw(handle as *mut PluginGraphInner));
        }
    }
}

// ... other functions
<span class="boring">}</span></code></pre>
<h2 id="safety"><a class="header" href="#safety">Safety</a></h2>
<p>The macro handles:</p>
<ul>
<li>Null pointer checks</li>
<li>Parameter validation</li>
<li>Safe type conversions</li>
<li>Memory ownership transfer</li>
</ul>
<h2 id="custom-function-names"><a class="header" href="#custom-function-names">Custom Function Names</a></h2>
<p>Currently, function names are fixed (<code>bbx_graph_*</code>). For custom names, you would need to write the FFI layer manually.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="parameter-definitions"><a class="header" href="#parameter-definitions">Parameter Definitions</a></h1>
<p>Utilities for defining plugin parameters and generating code.</p>
<h2 id="overview-12"><a class="header" href="#overview-12">Overview</a></h2>
<p>bbx_plugin provides two approaches:</p>
<ol>
<li><strong>JSON-based</strong> - Parse <code>parameters.json</code></li>
<li><strong>Programmatic</strong> - Define as Rust const arrays</li>
</ol>
<p>Both generate Rust constants and C headers.</p>
<h2 id="json-based-definitions"><a class="header" href="#json-based-definitions">JSON-Based Definitions</a></h2>
<h3 id="paramsfile"><a class="header" href="#paramsfile">ParamsFile</a></h3>
<p>Parse a JSON file:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::ParamsFile;

let json = r#"{
    "parameters": [
        {"id": "GAIN", "name": "Gain", "type": "float", "min": -60.0, "max": 30.0, "defaultValue": 0.0},
        {"id": "MONO", "name": "Mono", "type": "boolean", "defaultValue": false}
    ]
}"#;

let params = ParamsFile::from_json(json)?;
<span class="boring">}</span></code></pre>
<h3 id="jsonparamdef"><a class="header" href="#jsonparamdef">JsonParamDef</a></h3>
<p>Parameter definition from JSON:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct JsonParamDef {
    pub id: String,
    pub name: String,
    pub param_type: String,  // "float", "boolean", "choice"
    pub default_value: Option&lt;serde_json::Value&gt;,
    pub default_value_index: Option&lt;usize&gt;,
    pub min: Option&lt;f64&gt;,
    pub max: Option&lt;f64&gt;,
    pub unit: Option&lt;String&gt;,
    pub midpoint: Option&lt;f64&gt;,
    pub interval: Option&lt;f64&gt;,
    pub fraction_digits: Option&lt;u32&gt;,
    pub choices: Option&lt;Vec&lt;String&gt;&gt;,
}
<span class="boring">}</span></code></pre>
<h3 id="generating-code-1"><a class="header" href="#generating-code-1">Generating Code</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::ParamsFile;

let params = ParamsFile::from_json(json)?;

// Generate Rust constants
let rust_code = params.generate_rust_indices();
// pub const PARAM_GAIN: usize = 0;
// pub const PARAM_MONO: usize = 1;
// pub const PARAM_COUNT: usize = 2;

// Generate C header
let c_header = params.generate_c_header();
// #define PARAM_GAIN 0
// #define PARAM_MONO 1
// #define PARAM_COUNT 2
// static const char* PARAM_IDS[PARAM_COUNT] = { "GAIN", "MONO" };
<span class="boring">}</span></code></pre>
<p>The C header includes a <code>PARAM_IDS</code> array for dynamic iteration over parameters in C++.</p>
<h2 id="programmatic-definitions"><a class="header" href="#programmatic-definitions">Programmatic Definitions</a></h2>
<h3 id="paramdef"><a class="header" href="#paramdef">ParamDef</a></h3>
<p>Define parameters as const:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::{ParamDef, ParamType};

const PARAMETERS: &amp;[ParamDef] = &amp;[
    ParamDef::float("GAIN", "Gain", -60.0, 30.0, 0.0),
    ParamDef::bool("MONO", "Mono", false),
    ParamDef::choice("MODE", "Mode", &amp;["A", "B", "C"], 0),
];
<span class="boring">}</span></code></pre>
<h3 id="constructors"><a class="header" href="#constructors">Constructors</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Boolean
ParamDef::bool("ID", "Name", default)

// Float with range
ParamDef::float("ID", "Name", min, max, default)

// Choice (dropdown)
ParamDef::choice("ID", "Name", &amp;["Option1", "Option2"], default_index)
<span class="boring">}</span></code></pre>
<h3 id="generating-code-1-1"><a class="header" href="#generating-code-1-1">Generating Code</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_plugin::{generate_rust_indices_from_defs, generate_c_header_from_defs};

let rust_code = generate_rust_indices_from_defs(PARAMETERS);
let c_header = generate_c_header_from_defs(PARAMETERS);
<span class="boring">}</span></code></pre>
<h2 id="build-script-integration-1"><a class="header" href="#build-script-integration-1">Build Script Integration</a></h2>
<pre class="playground"><code class="language-rust">// build.rs
use std::fs;

fn main() {
    // Read parameters.json
    let json = fs::read_to_string("parameters.json").unwrap();
    let params = bbx_plugin::ParamsFile::from_json(&amp;json).unwrap();

    // Generate Rust code
    let rust_code = params.generate_rust_indices();
    fs::write(
        format!("{}/params.rs", std::env::var("OUT_DIR").unwrap()),
        rust_code,
    ).unwrap();

    // Generate C header
    let c_header = params.generate_c_header();
    fs::write("include/bbx_params.h", c_header).unwrap();

    println!("cargo:rerun-if-changed=parameters.json");
}</code></pre>
<p>In lib.rs:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>include!(concat!(env!("OUT_DIR"), "/params.rs"));
<span class="boring">}</span></code></pre>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="#parametersjson-format">parameters.json Format</a> - Full JSON schema</li>
<li><a href="#parameter-code-generation">Code Generation</a> - Integration details</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bbx_file"><a class="header" href="#bbx_file">bbx_file</a></h1>
<p>Audio file I/O for the bbx_audio workspace.</p>
<h2 id="overview-13"><a class="header" href="#overview-13">Overview</a></h2>
<p>bbx_file provides:</p>
<ul>
<li>WAV file reading via <code>wavers</code></li>
<li>WAV file writing via <code>hound</code></li>
<li>Integration with bbx_dsp blocks</li>
</ul>
<h2 id="installation-4"><a class="header" href="#installation-4">Installation</a></h2>
<pre><code class="language-toml">[dependencies]
bbx_file = "0.1"
bbx_dsp = "0.1"
</code></pre>
<h2 id="supported-formats-1"><a class="header" href="#supported-formats-1">Supported Formats</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Read</th><th>Write</th></tr>
</thead>
<tbody>
<tr><td>WAV</td><td>Yes</td><td>Yes</td></tr>
</tbody>
</table>
</div>
<h2 id="features-3"><a class="header" href="#features-3">Features</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="#wav-reader">WAV Reader</a></td><td>Load WAV files</td></tr>
<tr><td><a href="#wav-writer">WAV Writer</a></td><td>Create WAV files</td></tr>
</tbody>
</table>
</div>
<h2 id="quick-example-4"><a class="header" href="#quick-example-4">Quick Example</a></h2>
<h3 id="reading"><a class="header" href="#reading">Reading</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_file::readers::wav::WavFileReader;

let reader = WavFileReader::&lt;f32&gt;::from_path("audio.wav")?;

println!("Sample rate: {}", reader.sample_rate());
println!("Channels: {}", reader.num_channels());
println!("Duration: {:.2}s", reader.duration_seconds());

let left_channel = reader.read_channel(0);
<span class="boring">}</span></code></pre>
<h3 id="writing"><a class="header" href="#writing">Writing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_file::writers::wav::WavFileWriter;

let mut writer = WavFileWriter::&lt;f32&gt;::new("output.wav", 44100.0, 2)?;

writer.write_channel(0, &amp;left_samples)?;
writer.write_channel(1, &amp;right_samples)?;

writer.finalize()?;
<span class="boring">}</span></code></pre>
<h3 id="with-bbx_dsp"><a class="header" href="#with-bbx_dsp">With bbx_dsp</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;
use bbx_file::readers::wav::WavFileReader;

let reader = WavFileReader::&lt;f32&gt;::from_path("input.wav")?;
let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let file_in = builder.add_file_input(Box::new(reader));
let gain = builder.add_gain(-6.0);

builder.connect(file_in, 0, gain, 0);

let graph = builder.build();
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wav-reader"><a class="header" href="#wav-reader">WAV Reader</a></h1>
<p>Load WAV files for processing with bbx_dsp.</p>
<h2 id="creating-a-reader"><a class="header" href="#creating-a-reader">Creating a Reader</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_file::readers::wav::WavFileReader;

let reader = WavFileReader::&lt;f32&gt;::from_path("audio.wav")?;
<span class="boring">}</span></code></pre>
<h2 id="file-information"><a class="header" href="#file-information">File Information</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_file::readers::wav::WavFileReader;
use bbx_dsp::reader::Reader;

let reader = WavFileReader::&lt;f32&gt;::from_path("audio.wav")?;

// Sample rate in Hz
let rate = reader.sample_rate();

// Number of channels
let channels = reader.num_channels();

// Total samples per channel
let samples = reader.num_samples();

// Duration
let duration = reader.duration_seconds();
<span class="boring">}</span></code></pre>
<h2 id="reading-audio-data"><a class="header" href="#reading-audio-data">Reading Audio Data</a></h2>
<h3 id="full-channel"><a class="header" href="#full-channel">Full Channel</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let left = reader.read_channel(0);
let right = reader.read_channel(1);
<span class="boring">}</span></code></pre>
<h3 id="partial-read"><a class="header" href="#partial-read">Partial Read</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Read specific range
let data = reader.read_range(0, 1000..2000);
<span class="boring">}</span></code></pre>
<h2 id="reader-trait"><a class="header" href="#reader-trait">Reader Trait</a></h2>
<p><code>WavFileReader</code> implements the <code>Reader</code> trait from bbx_dsp:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Reader&lt;S: Sample&gt;: Send {
    fn sample_rate(&amp;self) -&gt; f64;
    fn num_channels(&amp;self) -&gt; usize;
    fn num_samples(&amp;self) -&gt; usize;
    fn duration_seconds(&amp;self) -&gt; f64;
    fn read_channel(&amp;self, channel: usize) -&gt; Vec&lt;S&gt;;
}
<span class="boring">}</span></code></pre>
<h2 id="usage-with-fileinputblock"><a class="header" href="#usage-with-fileinputblock">Usage with FileInputBlock</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;
use bbx_file::readers::wav::WavFileReader;

let reader = WavFileReader::&lt;f32&gt;::from_path("input.wav")?;

let mut builder = GraphBuilder::&lt;f32&gt;::new(
    reader.sample_rate(),
    512,
    reader.num_channels(),
);

let file_input = builder.add_file_input(Box::new(reader));
<span class="boring">}</span></code></pre>
<h2 id="supported-formats-2"><a class="header" href="#supported-formats-2">Supported Formats</a></h2>
<ul>
<li>PCM 8-bit unsigned</li>
<li>PCM 16-bit signed</li>
<li>PCM 24-bit signed</li>
<li>PCM 32-bit signed</li>
<li>IEEE Float 32-bit</li>
<li>IEEE Float 64-bit</li>
</ul>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_file::readers::wav::WavFileReader;

match WavFileReader::&lt;f32&gt;::from_path("audio.wav") {
    Ok(reader) =&gt; {
        // Use reader
    }
    Err(e) =&gt; {
        eprintln!("Failed to load: {}", e);
    }
}
<span class="boring">}</span></code></pre>
<h2 id="performance-notes"><a class="header" href="#performance-notes">Performance Notes</a></h2>
<ul>
<li>Files are loaded entirely into memory</li>
<li>For large files, consider streaming approaches</li>
<li>Sample type conversion happens on load</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="wav-writer"><a class="header" href="#wav-writer">WAV Writer</a></h1>
<p>Create WAV files from processed audio.</p>
<h2 id="creating-a-writer"><a class="header" href="#creating-a-writer">Creating a Writer</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_file::writers::wav::WavFileWriter;

let writer = WavFileWriter::&lt;f32&gt;::new(
    "output.wav",  // path
    44100.0,       // sample rate
    2,             // channels
)?;
<span class="boring">}</span></code></pre>
<h2 id="writing-audio-data"><a class="header" href="#writing-audio-data">Writing Audio Data</a></h2>
<h3 id="per-channel"><a class="header" href="#per-channel">Per-Channel</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_file::writers::wav::WavFileWriter;
use bbx_dsp::writer::Writer;

let mut writer = WavFileWriter::&lt;f32&gt;::new("output.wav", 44100.0, 2)?;

writer.write_channel(0, &amp;left_samples)?;
writer.write_channel(1, &amp;right_samples)?;

writer.finalize()?;
<span class="boring">}</span></code></pre>
<h3 id="interleaved"><a class="header" href="#interleaved">Interleaved</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Write interleaved samples [L, R, L, R, ...]
writer.write_interleaved(&amp;interleaved_samples)?;
<span class="boring">}</span></code></pre>
<h2 id="finalization-1"><a class="header" href="#finalization-1">Finalization</a></h2>
<p>Always call <code>finalize()</code> to:</p>
<ul>
<li>Flush buffered data</li>
<li>Update WAV header with correct sizes</li>
<li>Close the file</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>writer.finalize()?;
<span class="boring">}</span></code></pre>
<p>Without finalization, the file may be corrupt or truncated.</p>
<h2 id="writer-trait"><a class="header" href="#writer-trait">Writer Trait</a></h2>
<p><code>WavFileWriter</code> implements the <code>Writer</code> trait from bbx_dsp:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Writer&lt;S: Sample&gt;: Send {
    fn sample_rate(&amp;self) -&gt; f64;
    fn num_channels(&amp;self) -&gt; usize;
    fn write_channel(&amp;mut self, channel: usize, samples: &amp;[S]) -&gt; Result&lt;()&gt;;
    fn finalize(&amp;mut self) -&gt; Result&lt;()&gt;;
}
<span class="boring">}</span></code></pre>
<h2 id="usage-with-fileoutputblock"><a class="header" href="#usage-with-fileoutputblock">Usage with FileOutputBlock</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};
use bbx_file::writers::wav::WavFileWriter;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Audio source
let osc = builder.add_oscillator(440.0, Waveform::Sine, None);

// File output
let writer = WavFileWriter::&lt;f32&gt;::new("output.wav", 44100.0, 2)?;
let file_out = builder.add_file_output(Box::new(writer));

builder.connect(osc, 0, file_out, 0);

let mut graph = builder.build();

// Process audio
for _ in 0..1000 {
    let mut left = vec![0.0f32; 512];
    let mut right = vec![0.0f32; 512];
    let mut outputs: [&amp;mut [f32]; 2] = [&amp;mut left, &amp;mut right];
    graph.process_buffers(&amp;mut outputs);
}

// Finalize
graph.finalize();
<span class="boring">}</span></code></pre>
<h2 id="output-format"><a class="header" href="#output-format">Output Format</a></h2>
<p>Default output format:</p>
<ul>
<li>IEEE Float 32-bit</li>
<li>Little-endian</li>
<li>Standard RIFF/WAVE header</li>
</ul>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_file::writers::wav::WavFileWriter;

let writer = WavFileWriter::&lt;f32&gt;::new("output.wav", 44100.0, 2);

match writer {
    Ok(w) =&gt; {
        // Use writer
    }
    Err(e) =&gt; {
        eprintln!("Failed to create writer: {}", e);
    }
}
<span class="boring">}</span></code></pre>
<h2 id="non-blocking-io"><a class="header" href="#non-blocking-io">Non-Blocking I/O</a></h2>
<p><code>FileOutputBlock</code> uses non-blocking I/O internally to avoid blocking the audio thread. Actual disk writes happen on a background thread.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bbx_midi"><a class="header" href="#bbx_midi">bbx_midi</a></h1>
<p>MIDI message parsing and streaming utilities.</p>
<h2 id="overview-14"><a class="header" href="#overview-14">Overview</a></h2>
<p>bbx_midi provides:</p>
<ul>
<li>MIDI message parsing from raw bytes</li>
<li>Message type helpers (note, velocity, CC, etc.)</li>
<li>Real-time message buffer</li>
<li>Input streaming via midir</li>
<li>FFI-compatible types</li>
</ul>
<h2 id="installation-5"><a class="header" href="#installation-5">Installation</a></h2>
<pre><code class="language-toml">[dependencies]
bbx_midi = "0.1"
</code></pre>
<h2 id="features-4"><a class="header" href="#features-4">Features</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="#midi-messages">MIDI Messages</a></td><td>Message parsing and types</td></tr>
<tr><td><a href="#message-buffer-1">Message Buffer</a></td><td>Real-time buffer</td></tr>
</tbody>
</table>
</div>
<h2 id="quick-example-5"><a class="header" href="#quick-example-5">Quick Example</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_midi::{MidiMessage, MidiMessageStatus, MidiMessageBuffer};

// Parse raw MIDI bytes
let msg = MidiMessage::new([0x90, 60, 100]); // Note On, C4, velocity 100

if msg.get_status() == MidiMessageStatus::NoteOn {
    println!("Note: {}", msg.get_note().unwrap());
    println!("Velocity: {}", msg.get_velocity().unwrap());
    println!("Frequency: {:.2} Hz", msg.get_note_frequency().unwrap());
}

// Buffer for real-time use
let mut buffer = MidiMessageBuffer::new(256);
buffer.push(msg);

for message in buffer.iter() {
    // Process...
}

buffer.clear();
<span class="boring">}</span></code></pre>
<h2 id="message-types"><a class="header" href="#message-types">Message Types</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Status</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>NoteOn</td><td>Key pressed</td></tr>
<tr><td>NoteOff</td><td>Key released</td></tr>
<tr><td>ControlChange</td><td>CC (knobs, pedals)</td></tr>
<tr><td>PitchWheel</td><td>Pitch bend</td></tr>
<tr><td>ProgramChange</td><td>Preset change</td></tr>
<tr><td>PolyphonicAftertouch</td><td>Per-note pressure</td></tr>
<tr><td>ChannelAftertouch</td><td>Channel pressure</td></tr>
</tbody>
</table>
</div>
<h2 id="ffi-compatibility"><a class="header" href="#ffi-compatibility">FFI Compatibility</a></h2>
<p>MIDI types use <code>#[repr(C)]</code> for C interop:</p>
<pre><code class="language-c">typedef struct {
    uint8_t data[3];
} MidiMessage;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="midi-messages"><a class="header" href="#midi-messages">MIDI Messages</a></h1>
<p>Parse and work with MIDI messages.</p>
<h2 id="midimessage"><a class="header" href="#midimessage">MidiMessage</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_midi::MidiMessage;

// Create from raw bytes
let msg = MidiMessage::new([0x90, 60, 100]);

// Or from parts
let msg = MidiMessage::note_on(0, 60, 100);  // Channel 0, Note 60, Velocity 100
<span class="boring">}</span></code></pre>
<h2 id="midimessagestatus"><a class="header" href="#midimessagestatus">MidiMessageStatus</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_midi::MidiMessageStatus;

pub enum MidiMessageStatus {
    NoteOff,
    NoteOn,
    PolyphonicAftertouch,
    ControlChange,
    ProgramChange,
    ChannelAftertouch,
    PitchWheel,
    Unknown,
}
<span class="boring">}</span></code></pre>
<h2 id="constructors-1"><a class="header" href="#constructors-1">Constructors</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_midi::MidiMessage;

// Note events
let note_on = MidiMessage::note_on(channel, note, velocity);
let note_off = MidiMessage::note_off(channel, note, velocity);

// Control change
let cc = MidiMessage::control_change(channel, controller, value);

// Pitch bend
let bend = MidiMessage::pitch_bend(channel, value);  // value: 0-16383

// Program change
let program = MidiMessage::program_change(channel, program);
<span class="boring">}</span></code></pre>
<h2 id="accessors"><a class="header" href="#accessors">Accessors</a></h2>
<h3 id="status-and-channel"><a class="header" href="#status-and-channel">Status and Channel</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let msg = MidiMessage::note_on(5, 60, 100);

let status = msg.get_status();  // MidiMessageStatus::NoteOn
let channel = msg.get_channel();  // 5
<span class="boring">}</span></code></pre>
<h3 id="note-events"><a class="header" href="#note-events">Note Events</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let msg = MidiMessage::note_on(0, 60, 100);

let note = msg.get_note().unwrap();           // 60
let velocity = msg.get_velocity().unwrap();   // 100
let frequency = msg.get_note_frequency().unwrap(); // 261.63
<span class="boring">}</span></code></pre>
<h3 id="control-change"><a class="header" href="#control-change">Control Change</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let msg = MidiMessage::control_change(0, 1, 64);

let controller = msg.get_controller().unwrap();  // 1 (mod wheel)
let value = msg.get_value().unwrap();            // 64
<span class="boring">}</span></code></pre>
<h3 id="pitch-bend"><a class="header" href="#pitch-bend">Pitch Bend</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let msg = MidiMessage::pitch_bend(0, 8192);  // Center

let bend = msg.get_pitch_bend().unwrap();  // 8192
// bend range: 0 (full down) - 8192 (center) - 16383 (full up)
<span class="boring">}</span></code></pre>
<h2 id="note-frequency"><a class="header" href="#note-frequency">Note Frequency</a></h2>
<p>Convert MIDI note numbers to Hz:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_midi::MidiMessage;

let msg = MidiMessage::note_on(0, 69, 100);  // A4
let freq = msg.get_note_frequency().unwrap(); // 440.0

let msg = MidiMessage::note_on(0, 60, 100);  // Middle C
let freq = msg.get_note_frequency().unwrap(); // 261.63
<span class="boring">}</span></code></pre>
<h2 id="common-controller-numbers"><a class="header" href="#common-controller-numbers">Common Controller Numbers</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const CC_MOD_WHEEL: u8 = 1;
const CC_BREATH: u8 = 2;
const CC_VOLUME: u8 = 7;
const CC_BALANCE: u8 = 8;
const CC_PAN: u8 = 10;
const CC_EXPRESSION: u8 = 11;
const CC_SUSTAIN: u8 = 64;
const CC_PORTAMENTO: u8 = 65;
const CC_SOSTENUTO: u8 = 66;
const CC_SOFT_PEDAL: u8 = 67;
const CC_ALL_SOUND_OFF: u8 = 120;
const CC_ALL_NOTES_OFF: u8 = 123;
<span class="boring">}</span></code></pre>
<h2 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern Matching</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_midi::{MidiMessage, MidiMessageStatus};

fn handle_midi(msg: &amp;MidiMessage) {
    match msg.get_status() {
        MidiMessageStatus::NoteOn =&gt; {
            if msg.get_velocity().unwrap() &gt; 0 {
                // Note on with velocity
            } else {
                // Note on with velocity 0 = note off
            }
        }
        MidiMessageStatus::NoteOff =&gt; {
            // Note off
        }
        MidiMessageStatus::ControlChange =&gt; {
            // CC message
        }
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="message-buffer-1"><a class="header" href="#message-buffer-1">Message Buffer</a></h1>
<p>A pre-allocated buffer for collecting MIDI messages in real-time audio callbacks.</p>
<h2 id="overview-15"><a class="header" href="#overview-15">Overview</a></h2>
<p><code>MidiMessageBuffer</code> provides:</p>
<ul>
<li>Fixed capacity (no allocations during use)</li>
<li>Push/pop operations</li>
<li>Iteration</li>
<li>Clear without deallocation</li>
</ul>
<h2 id="creating-a-buffer-1"><a class="header" href="#creating-a-buffer-1">Creating a Buffer</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_midi::MidiMessageBuffer;

// Buffer with capacity for 256 messages
let mut buffer = MidiMessageBuffer::new(256);
<span class="boring">}</span></code></pre>
<h2 id="adding-messages"><a class="header" href="#adding-messages">Adding Messages</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_midi::{MidiMessage, MidiMessageBuffer};

let mut buffer = MidiMessageBuffer::new(256);

buffer.push(MidiMessage::note_on(0, 60, 100));
buffer.push(MidiMessage::note_on(0, 64, 100));
buffer.push(MidiMessage::note_on(0, 67, 100));
<span class="boring">}</span></code></pre>
<h2 id="iterating"><a class="header" href="#iterating">Iterating</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for msg in buffer.iter() {
    println!("{:?}", msg.get_status());
}
<span class="boring">}</span></code></pre>
<h2 id="clearing"><a class="header" href="#clearing">Clearing</a></h2>
<p>Clear the buffer for the next audio block:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>buffer.clear();  // Sets length to 0, retains capacity
<span class="boring">}</span></code></pre>
<h2 id="usage-pattern"><a class="header" href="#usage-pattern">Usage Pattern</a></h2>
<p>Typical audio callback pattern:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_midi::{MidiMessage, MidiMessageBuffer};

struct AudioProcessor {
    midi_buffer: MidiMessageBuffer,
}

impl AudioProcessor {
    fn new() -&gt; Self {
        Self {
            midi_buffer: MidiMessageBuffer::new(256),
        }
    }

    // Called from MIDI callback
    fn on_midi_message(&amp;mut self, data: &amp;[u8]) {
        if data.len() &gt;= 3 {
            let msg = MidiMessage::new([data[0], data[1], data[2]]);
            self.midi_buffer.push(msg);
        }
    }

    // Called from audio callback
    fn process_audio(&amp;mut self, output: &amp;mut [f32]) {
        // Process pending MIDI messages
        for msg in self.midi_buffer.iter() {
            self.handle_midi(msg);
        }

        // Clear for next block
        self.midi_buffer.clear();

        // Generate audio...
    }

    fn handle_midi(&amp;mut self, msg: &amp;MidiMessage) {
        // Handle message
    }
}
<span class="boring">}</span></code></pre>
<h2 id="capacity"><a class="header" href="#capacity">Capacity</a></h2>
<p>Check buffer state:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let capacity = buffer.capacity();  // Maximum messages
let len = buffer.len();            // Current count
let is_empty = buffer.is_empty();
let is_full = buffer.len() == buffer.capacity();
<span class="boring">}</span></code></pre>
<h2 id="thread-safety-3"><a class="header" href="#thread-safety-3">Thread Safety</a></h2>
<p><code>MidiMessageBuffer</code> is NOT thread-safe. For cross-thread MIDI:</p>
<ul>
<li>Use SPSC ring buffer for MIDI messages</li>
<li>Or process MIDI on the same thread as audio</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="generators-1"><a class="header" href="#generators-1">Generators</a></h1>
<p>Generator blocks create audio signals from nothing.</p>
<h2 id="available-generators"><a class="header" href="#available-generators">Available Generators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Block</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="#oscillatorblock">OscillatorBlock</a></td><td>Waveform generator</td></tr>
</tbody>
</table>
</div>
<h2 id="characteristics"><a class="header" href="#characteristics">Characteristics</a></h2>
<p>Generators have:</p>
<ul>
<li><strong>0 inputs</strong> - They create signal, not process it</li>
<li><strong>1+ outputs</strong> - Audio signal output</li>
<li><strong>No modulation outputs</strong> - They produce audio, not control signals</li>
</ul>
<h2 id="usage-pattern-1"><a class="header" href="#usage-pattern-1">Usage Pattern</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Add a generator
let osc = builder.add_oscillator(440.0, Waveform::Sine, None);

// Connect to effects or output
let gain = builder.add_gain(-6.0);
builder.connect(osc, 0, gain, 0);
<span class="boring">}</span></code></pre>
<h2 id="polyphony-1"><a class="header" href="#polyphony-1">Polyphony</a></h2>
<p>Create multiple generators for polyphonic sounds:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Three oscillators for a chord
let c4 = builder.add_oscillator(261.63, Waveform::Sine, None);
let e4 = builder.add_oscillator(329.63, Waveform::Sine, None);
let g4 = builder.add_oscillator(392.00, Waveform::Sine, None);

// Mix them
let mixer = builder.add_gain(-9.0);
builder.connect(c4, 0, mixer, 0);
builder.connect(e4, 0, mixer, 0);
builder.connect(g4, 0, mixer, 0);
<span class="boring">}</span></code></pre>
<h2 id="future-generators"><a class="header" href="#future-generators">Future Generators</a></h2>
<p>Potential additions:</p>
<ul>
<li>SamplerBlock - Sample playback</li>
<li>WavetableBlock - Wavetable synthesis</li>
<li>NoiseBlock - Dedicated noise generator</li>
<li>GranularBlock - Granular synthesis</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="oscillatorblock"><a class="header" href="#oscillatorblock">OscillatorBlock</a></h1>
<p>A waveform generator supporting multiple wave shapes.</p>
<h2 id="overview-16"><a class="header" href="#overview-16">Overview</a></h2>
<p><code>OscillatorBlock</code> generates audio waveforms at a specified frequency with optional frequency modulation.</p>
<h2 id="creating-an-oscillator"><a class="header" href="#creating-an-oscillator">Creating an Oscillator</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Basic oscillator
let osc = builder.add_oscillator(
    440.0,           // Frequency in Hz
    Waveform::Sine,  // Waveform type
    None,            // No frequency modulation
);
<span class="boring">}</span></code></pre>
<h2 id="waveforms"><a class="header" href="#waveforms">Waveforms</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::waveform::Waveform;

Waveform::Sine      // Pure sine wave
Waveform::Square    // Square wave (50% duty)
Waveform::Saw       // Sawtooth (ramp up)
Waveform::Triangle  // Triangle wave
Waveform::Pulse     // Pulse with variable width
Waveform::Noise     // White noise
<span class="boring">}</span></code></pre>
<h3 id="waveform-characteristics-1"><a class="header" href="#waveform-characteristics-1">Waveform Characteristics</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Waveform</th><th>Harmonics</th><th>Character</th></tr>
</thead>
<tbody>
<tr><td>Sine</td><td>Fundamental only</td><td>Pure, clean</td></tr>
<tr><td>Square</td><td>Odd harmonics</td><td>Hollow, woody</td></tr>
<tr><td>Saw</td><td>All harmonics</td><td>Bright, buzzy</td></tr>
<tr><td>Triangle</td><td>Odd (weak)</td><td>Soft, flute-like</td></tr>
<tr><td>Pulse</td><td>Variable</td><td>Nasal, reedy</td></tr>
<tr><td>Noise</td><td>All frequencies</td><td>Airy, percussive</td></tr>
</tbody>
</table>
</div>
<h2 id="frequency-modulation-2"><a class="header" href="#frequency-modulation-2">Frequency Modulation</a></h2>
<p>Use an LFO for vibrato:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lfo = builder.add_lfo(5.0, Waveform::Sine);  // 5 Hz vibrato

let osc = builder.add_oscillator(
    440.0,
    Waveform::Sine,
    Some(lfo),  // LFO modulates frequency
);
<span class="boring">}</span></code></pre>
<h2 id="port-layout"><a class="header" href="#port-layout">Port Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Port</th><th>Direction</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Output</td><td>Audio signal</td></tr>
</tbody>
</table>
</div>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Type</th><th>Range</th><th>Default</th></tr>
</thead>
<tbody>
<tr><td>Frequency</td><td>f64</td><td>0.01 - 20000 Hz</td><td>440</td></tr>
<tr><td>Waveform</td><td>enum</td><td>See above</td><td>Sine</td></tr>
</tbody>
</table>
</div>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="basic-tone"><a class="header" href="#basic-tone">Basic Tone</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
<span class="boring">}</span></code></pre>
<h3 id="detuned-oscillators-1"><a class="header" href="#detuned-oscillators-1">Detuned Oscillators</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let osc1 = builder.add_oscillator(440.0, Waveform::Saw, None);
let osc2 = builder.add_oscillator(440.0 * 1.005, Waveform::Saw, None);  // +8.6 cents
let osc3 = builder.add_oscillator(440.0 / 1.005, Waveform::Saw, None);  // -8.6 cents
<span class="boring">}</span></code></pre>
<h3 id="sub-oscillator"><a class="header" href="#sub-oscillator">Sub-Oscillator</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let main = builder.add_oscillator(440.0, Waveform::Saw, None);
let sub = builder.add_oscillator(220.0, Waveform::Sine, None);  // One octave down
<span class="boring">}</span></code></pre>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<ul>
<li>Phase accumulator runs continuously</li>
<li>No anti-aliasing (naive waveforms)</li>
<li>Noise is sample-and-hold (per-sample random)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="effectors-1"><a class="header" href="#effectors-1">Effectors</a></h1>
<p>Effector blocks process and transform audio signals.</p>
<h2 id="available-effectors"><a class="header" href="#available-effectors">Available Effectors</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Block</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="#gainblock-1">GainBlock</a></td><td>Level control in dB</td></tr>
<tr><td><a href="#pannerblock-1">PannerBlock</a></td><td>Stereo panning</td></tr>
<tr><td><a href="#overdriveblock-1">OverdriveBlock</a></td><td>Soft-clipping distortion</td></tr>
<tr><td><a href="#dcblockerblock-1">DcBlockerBlock</a></td><td>DC offset removal</td></tr>
<tr><td><a href="#channelrouterblock">ChannelRouterBlock</a></td><td>Channel routing</td></tr>
</tbody>
</table>
</div>
<h2 id="characteristics-1"><a class="header" href="#characteristics-1">Characteristics</a></h2>
<p>Effectors have:</p>
<ul>
<li><strong>1+ inputs</strong> - Audio to process</li>
<li><strong>1+ outputs</strong> - Processed audio</li>
<li><strong>No modulation outputs</strong> - They produce audio, not control</li>
</ul>
<h2 id="effect-chain-order"><a class="header" href="#effect-chain-order">Effect Chain Order</a></h2>
<p>Order matters for sound quality:</p>
<pre><code>Recommended order:
Source -&gt; Gain (input level)
       -&gt; Distortion
       -&gt; DC Blocker
       -&gt; Filter (when available)
       -&gt; Panning
       -&gt; Gain (output level)
</code></pre>
<h2 id="usage-pattern-2"><a class="header" href="#usage-pattern-2">Usage Pattern</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Source
let osc = builder.add_oscillator(440.0, Waveform::Saw, None);

// Effect chain
let drive = builder.add_overdrive(3.0, 1.0, 0.8, 44100.0);
let dc = builder.add_dc_blocker();
let gain = builder.add_gain(-6.0);

// Connect in series
builder.connect(osc, 0, drive, 0);
builder.connect(drive, 0, dc, 0);
builder.connect(dc, 0, gain, 0);
<span class="boring">}</span></code></pre>
<h2 id="parallel-processing"><a class="header" href="#parallel-processing">Parallel Processing</a></h2>
<p>Split signal to multiple effects:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let source = builder.add_oscillator(440.0, Waveform::Saw, None);

// Dry path
let dry_gain = builder.add_gain(-6.0);

// Wet path (distorted)
let wet_drive = builder.add_overdrive(5.0, 1.0, 0.5, 44100.0);

// Connect source to both
builder.connect(source, 0, dry_gain, 0);
builder.connect(source, 0, wet_drive, 0);

// Mix back together
let mixer = builder.add_gain(-3.0);
builder.connect(dry_gain, 0, mixer, 0);
builder.connect(wet_drive, 0, mixer, 0);
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="gainblock-1"><a class="header" href="#gainblock-1">GainBlock</a></h1>
<p>Level control in decibels.</p>
<h2 id="overview-17"><a class="header" href="#overview-17">Overview</a></h2>
<p><code>GainBlock</code> applies a gain (volume change) to audio signals, specified in decibels.</p>
<h2 id="creating-a-gain-block"><a class="header" href="#creating-a-gain-block">Creating a Gain Block</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let gain = builder.add_gain(-6.0);  // -6 dB (half amplitude)
<span class="boring">}</span></code></pre>
<h2 id="db-to-linear-conversion"><a class="header" href="#db-to-linear-conversion">dB to Linear Conversion</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>dB</th><th>Linear</th><th>Effect</th></tr>
</thead>
<tbody>
<tr><td>+12</td><td>4.0</td><td>4x louder</td></tr>
<tr><td>+6</td><td>2.0</td><td>2x louder</td></tr>
<tr><td>+3</td><td>1.41</td><td>~1.4x louder</td></tr>
<tr><td>0</td><td>1.0</td><td>No change</td></tr>
<tr><td>-3</td><td>0.71</td><td>~0.7x amplitude</td></tr>
<tr><td>-6</td><td>0.5</td><td>Half amplitude</td></tr>
<tr><td>-12</td><td>0.25</td><td>Quarter amplitude</td></tr>
<tr><td>-20</td><td>0.1</td><td>10% amplitude</td></tr>
<tr><td>-inf</td><td>0.0</td><td>Silence</td></tr>
</tbody>
</table>
</div>
<h2 id="port-layout-1"><a class="header" href="#port-layout-1">Port Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Port</th><th>Direction</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Input</td><td>Audio input</td></tr>
<tr><td>0</td><td>Output</td><td>Gained audio</td></tr>
</tbody>
</table>
</div>
<h2 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Type</th><th>Range</th><th>Default</th></tr>
</thead>
<tbody>
<tr><td>Level</td><td>f64</td><td>-inf to +inf dB</td><td>0.0</td></tr>
</tbody>
</table>
</div>
<h2 id="usage-examples-1"><a class="header" href="#usage-examples-1">Usage Examples</a></h2>
<h3 id="volume-control"><a class="header" href="#volume-control">Volume Control</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let source = builder.add_oscillator(440.0, Waveform::Sine, None);
let volume = builder.add_gain(-12.0);  // -12 dB

builder.connect(source, 0, volume, 0);
<span class="boring">}</span></code></pre>
<h3 id="gain-staging"><a class="header" href="#gain-staging">Gain Staging</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Input gain before processing
let input_gain = builder.add_gain(6.0);

// Processing
let effect = builder.add_overdrive(3.0, 1.0, 1.0, 44100.0);

// Output gain after processing
let output_gain = builder.add_gain(-6.0);

builder.connect(source, 0, input_gain, 0);
builder.connect(input_gain, 0, effect, 0);
builder.connect(effect, 0, output_gain, 0);
<span class="boring">}</span></code></pre>
<h3 id="mixing-summing"><a class="header" href="#mixing-summing">Mixing (Summing)</a></h3>
<p>Multiple inputs are summed:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let osc1 = builder.add_oscillator(261.63, Waveform::Sine, None);
let osc2 = builder.add_oscillator(329.63, Waveform::Sine, None);
let osc3 = builder.add_oscillator(392.00, Waveform::Sine, None);

// Mix with headroom
let mixer = builder.add_gain(-9.0);  // -9 dB for 3 sources

builder.connect(osc1, 0, mixer, 0);
builder.connect(osc2, 0, mixer, 0);
builder.connect(osc3, 0, mixer, 0);
<span class="boring">}</span></code></pre>
<h2 id="with-modulation"><a class="header" href="#with-modulation">With Modulation</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// LFO for tremolo
let lfo = builder.add_lfo(6.0, Waveform::Sine);

// Gain with amplitude modulation
let gain = builder.add_gain_with_modulation(-6.0, Some(lfo));
<span class="boring">}</span></code></pre>
<h2 id="implementation-notes-1"><a class="header" href="#implementation-notes-1">Implementation Notes</a></h2>
<ul>
<li>Linear multiplication (no interpolation)</li>
<li>Instant parameter changes (no smoothing)</li>
<li>Handles all channel counts</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pannerblock-1"><a class="header" href="#pannerblock-1">PannerBlock</a></h1>
<p>Stereo panning with constant-power law.</p>
<h2 id="overview-18"><a class="header" href="#overview-18">Overview</a></h2>
<p><code>PannerBlock</code> positions a mono signal in the stereo field, or adjusts the stereo balance of a stereo signal.</p>
<h2 id="creating-a-panner"><a class="header" href="#creating-a-panner">Creating a Panner</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let pan = builder.add_panner(0.0);  // Center
<span class="boring">}</span></code></pre>
<h2 id="pan-values"><a class="header" href="#pan-values">Pan Values</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Position</th></tr>
</thead>
<tbody>
<tr><td>-1.0</td><td>Hard left</td></tr>
<tr><td>-0.5</td><td>Half left</td></tr>
<tr><td>0.0</td><td>Center</td></tr>
<tr><td>+0.5</td><td>Half right</td></tr>
<tr><td>+1.0</td><td>Hard right</td></tr>
</tbody>
</table>
</div>
<h2 id="port-layout-2"><a class="header" href="#port-layout-2">Port Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Port</th><th>Direction</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Input</td><td>Audio input (mono or left)</td></tr>
<tr><td>0</td><td>Output</td><td>Left channel</td></tr>
<tr><td>1</td><td>Output</td><td>Right channel</td></tr>
</tbody>
</table>
</div>
<h2 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Type</th><th>Range</th><th>Default</th></tr>
</thead>
<tbody>
<tr><td>Position</td><td>f32</td><td>-1.0 to 1.0</td><td>0.0</td></tr>
</tbody>
</table>
</div>
<h2 id="constant-power-panning"><a class="header" href="#constant-power-panning">Constant Power Panning</a></h2>
<p>The panner uses a constant-power law (sine/cosine):</p>
<pre><code>Left gain  = cos(pan_angle)
Right gain = sin(pan_angle)
</code></pre>
<p>Where <code>pan_angle = (position + 1) * π/4</code></p>
<p>This maintains perceived loudness as the signal moves across the stereo field.</p>
<h2 id="usage-examples-2"><a class="header" href="#usage-examples-2">Usage Examples</a></h2>
<h3 id="basic-panning"><a class="header" href="#basic-panning">Basic Panning</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let pan = builder.add_panner(0.5);  // Slightly right

builder.connect(osc, 0, pan, 0);
<span class="boring">}</span></code></pre>
<h3 id="auto-pan-with-lfo"><a class="header" href="#auto-pan-with-lfo">Auto-Pan with LFO</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let osc = builder.add_oscillator(440.0, Waveform::Sine, None);

// Slow pan LFO
let lfo = builder.add_lfo(0.25, Waveform::Sine);

// Panner with modulation
let pan = builder.add_panner_with_modulation(0.0, Some(lfo));

builder.connect(osc, 0, pan, 0);
<span class="boring">}</span></code></pre>
<h3 id="stereo-width"><a class="header" href="#stereo-width">Stereo Width</a></h3>
<p>For stereo sources, use two panners:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let left_source = /* ... */;
let right_source = /* ... */;

// Narrow the stereo field
let left_pan = builder.add_panner(-0.3);   // Less extreme left
let right_pan = builder.add_panner(0.3);   // Less extreme right

builder.connect(left_source, 0, left_pan, 0);
builder.connect(right_source, 0, right_pan, 0);
<span class="boring">}</span></code></pre>
<h2 id="implementation-notes-2"><a class="header" href="#implementation-notes-2">Implementation Notes</a></h2>
<ul>
<li>Constant-power pan law prevents center dip</li>
<li>Mono input → stereo output</li>
<li>No interpolation on parameter changes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="overdriveblock-1"><a class="header" href="#overdriveblock-1">OverdriveBlock</a></h1>
<p>Soft-clipping distortion for warmth and saturation.</p>
<h2 id="overview-19"><a class="header" href="#overview-19">Overview</a></h2>
<p><code>OverdriveBlock</code> applies asymmetric soft-clipping distortion, adding harmonics and warmth to audio signals.</p>
<h2 id="creating-an-overdrive"><a class="header" href="#creating-an-overdrive">Creating an Overdrive</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let drive = builder.add_overdrive(
    3.0,      // Drive amount (higher = more distortion)
    1.0,      // Input gain
    0.8,      // Output gain (compensate for level increase)
    44100.0,  // Sample rate
);
<span class="boring">}</span></code></pre>
<h2 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Type</th><th>Range</th><th>Default</th></tr>
</thead>
<tbody>
<tr><td>Drive</td><td>f64</td><td>0.1 - 20.0</td><td>1.0</td></tr>
<tr><td>Input Gain</td><td>f64</td><td>0.0 - 10.0</td><td>1.0</td></tr>
<tr><td>Output Gain</td><td>f64</td><td>0.0 - 2.0</td><td>1.0</td></tr>
</tbody>
</table>
</div>
<h3 id="drive-amount"><a class="header" href="#drive-amount">Drive Amount</a></h3>
<p>Controls distortion intensity:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Drive</th><th>Character</th></tr>
</thead>
<tbody>
<tr><td>1.0</td><td>Subtle warmth</td></tr>
<tr><td>3.0</td><td>Moderate saturation</td></tr>
<tr><td>5.0</td><td>Heavy overdrive</td></tr>
<tr><td>10.0+</td><td>Aggressive distortion</td></tr>
</tbody>
</table>
</div>
<h3 id="inputoutput-gain"><a class="header" href="#inputoutput-gain">Input/Output Gain</a></h3>
<ul>
<li><strong>Input Gain</strong>: Boost signal before clipping (affects distortion character)</li>
<li><strong>Output Gain</strong>: Compensate for level increase from distortion</li>
</ul>
<h2 id="port-layout-3"><a class="header" href="#port-layout-3">Port Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Port</th><th>Direction</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Input</td><td>Audio input</td></tr>
<tr><td>0</td><td>Output</td><td>Distorted audio</td></tr>
</tbody>
</table>
</div>
<h2 id="usage-examples-3"><a class="header" href="#usage-examples-3">Usage Examples</a></h2>
<h3 id="basic-overdrive"><a class="header" href="#basic-overdrive">Basic Overdrive</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let drive = builder.add_overdrive(3.0, 1.0, 0.8, 44100.0);

builder.connect(osc, 0, drive, 0);
<span class="boring">}</span></code></pre>
<h3 id="aggressive-distortion"><a class="header" href="#aggressive-distortion">Aggressive Distortion</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let osc = builder.add_oscillator(110.0, Waveform::Saw, None);
let drive = builder.add_overdrive(
    8.0,   // High drive
    1.5,   // Boost input
    0.5,   // Lower output to compensate
    44100.0,
);

builder.connect(osc, 0, drive, 0);
<span class="boring">}</span></code></pre>
<h3 id="with-dc-blocker"><a class="header" href="#with-dc-blocker">With DC Blocker</a></h3>
<p>Distortion can introduce DC offset:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let drive = builder.add_overdrive(5.0, 1.0, 0.7, 44100.0);
let dc = builder.add_dc_blocker();

builder.connect(osc, 0, drive, 0);
builder.connect(drive, 0, dc, 0);
<span class="boring">}</span></code></pre>
<h2 id="algorithm-1"><a class="header" href="#algorithm-1">Algorithm</a></h2>
<p>The overdrive uses asymmetric soft-clipping:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn soft_clip(x: f32, drive: f32) -&gt; f32 {
    let driven = x * drive;
    driven / (1.0 + driven.abs())
}
<span class="boring">}</span></code></pre>
<p>This produces:</p>
<ul>
<li>Even and odd harmonics</li>
<li>Asymmetric positive/negative response</li>
<li>Gradual compression at high levels</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dcblockerblock-1"><a class="header" href="#dcblockerblock-1">DcBlockerBlock</a></h1>
<p>DC offset removal filter.</p>
<h2 id="overview-20"><a class="header" href="#overview-20">Overview</a></h2>
<p><code>DcBlockerBlock</code> removes DC offset (constant voltage) from audio signals, preventing speaker damage and headroom loss.</p>
<h2 id="creating-a-dc-blocker"><a class="header" href="#creating-a-dc-blocker">Creating a DC Blocker</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let dc = builder.add_dc_blocker();
<span class="boring">}</span></code></pre>
<h2 id="why-dc-blocking"><a class="header" href="#why-dc-blocking">Why DC Blocking?</a></h2>
<p>DC offset occurs when a signal’s average value is not zero:</p>
<ul>
<li>Asymmetric distortion</li>
<li>Some waveforms (e.g., asymmetric pulse)</li>
<li>Sample rate conversion artifacts</li>
<li>External audio input</li>
</ul>
<p>Problems caused by DC offset:</p>
<ul>
<li>Reduced headroom</li>
<li>Asymmetric clipping</li>
<li>Potential speaker damage</li>
<li>Incorrect metering</li>
</ul>
<h2 id="port-layout-4"><a class="header" href="#port-layout-4">Port Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Port</th><th>Direction</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Input</td><td>Audio with DC</td></tr>
<tr><td>0</td><td>Output</td><td>DC-free audio</td></tr>
</tbody>
</table>
</div>
<h2 id="usage-examples-4"><a class="header" href="#usage-examples-4">Usage Examples</a></h2>
<h3 id="after-distortion"><a class="header" href="#after-distortion">After Distortion</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let drive = builder.add_overdrive(5.0, 1.0, 0.7, 44100.0);
let dc = builder.add_dc_blocker();

builder.connect(osc, 0, drive, 0);
builder.connect(drive, 0, dc, 0);
<span class="boring">}</span></code></pre>
<h3 id="on-external-input"><a class="header" href="#on-external-input">On External Input</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// External audio (e.g., from file or interface)
let input = builder.add_file_input(Box::new(reader));
let dc = builder.add_dc_blocker();

builder.connect(input, 0, dc, 0);
<span class="boring">}</span></code></pre>
<h2 id="algorithm-2"><a class="header" href="#algorithm-2">Algorithm</a></h2>
<p>A simple high-pass filter:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Single-pole high-pass at ~5 Hz
fn process(&amp;mut self, input: f32) -&gt; f32 {
    let output = input - self.x1 + self.r * self.y1;
    self.x1 = input;
    self.y1 = output;
    output
}
<span class="boring">}</span></code></pre>
<p>Where <code>r</code> is typically 0.995 (5 Hz cutoff at 44.1 kHz).</p>
<h2 id="characteristics-2"><a class="header" href="#characteristics-2">Characteristics</a></h2>
<ul>
<li>First-order high-pass filter</li>
<li>Very low cutoff frequency (~5 Hz)</li>
<li>Minimal impact on audible frequencies</li>
<li>Introduces tiny phase shift at low frequencies</li>
<li>Needs <code>prepare()</code> when sample rate changes</li>
</ul>
<h2 id="when-to-use"><a class="header" href="#when-to-use">When to Use</a></h2>
<p><strong>Do use</strong> after:</p>
<ul>
<li>Distortion effects</li>
<li>Asymmetric processing</li>
<li>External audio input</li>
<li>Sample rate conversion</li>
</ul>
<p><strong>Don’t use</strong>:</p>
<ul>
<li>On pure sine waves (adds unnecessary processing)</li>
<li>When sub-bass content is critical</li>
<li>In series (one is enough)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="channelrouterblock"><a class="header" href="#channelrouterblock">ChannelRouterBlock</a></h1>
<p>Flexible channel routing and manipulation.</p>
<h2 id="overview-21"><a class="header" href="#overview-21">Overview</a></h2>
<p><code>ChannelRouterBlock</code> provides various channel routing options for stereo audio, including swapping, duplicating, and inverting channels.</p>
<h2 id="creating-a-router"><a class="header" href="#creating-a-router">Creating a Router</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;
use bbx_dsp::blocks::ChannelMode;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let router = builder.add_channel_router(ChannelMode::Stereo);
<span class="boring">}</span></code></pre>
<h2 id="channel-modes"><a class="header" href="#channel-modes">Channel Modes</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::blocks::ChannelMode;

ChannelMode::Stereo    // Pass through unchanged
ChannelMode::Left      // Left channel to both outputs
ChannelMode::Right     // Right channel to both outputs
ChannelMode::Swap      // Swap left and right
<span class="boring">}</span></code></pre>
<h3 id="mode-details"><a class="header" href="#mode-details">Mode Details</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Left Out</th><th>Right Out</th></tr>
</thead>
<tbody>
<tr><td>Stereo</td><td>Left In</td><td>Right In</td></tr>
<tr><td>Left</td><td>Left In</td><td>Left In</td></tr>
<tr><td>Right</td><td>Right In</td><td>Right In</td></tr>
<tr><td>Swap</td><td>Right In</td><td>Left In</td></tr>
</tbody>
</table>
</div>
<h2 id="port-layout-5"><a class="header" href="#port-layout-5">Port Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Port</th><th>Direction</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Input</td><td>Left channel</td></tr>
<tr><td>1</td><td>Input</td><td>Right channel</td></tr>
<tr><td>0</td><td>Output</td><td>Left channel</td></tr>
<tr><td>1</td><td>Output</td><td>Right channel</td></tr>
</tbody>
</table>
</div>
<h2 id="usage-examples-5"><a class="header" href="#usage-examples-5">Usage Examples</a></h2>
<h3 id="mono-summing"><a class="header" href="#mono-summing">Mono Summing</a></h3>
<p>For mono compatibility checking:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Route left to both channels (or right)
let mono = builder.add_channel_router(ChannelMode::Left);
<span class="boring">}</span></code></pre>
<h3 id="swap-channels"><a class="header" href="#swap-channels">Swap Channels</a></h3>
<p>For correcting reversed cables:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let swap = builder.add_channel_router(ChannelMode::Swap);
<span class="boring">}</span></code></pre>
<h3 id="in-effect-chain"><a class="header" href="#in-effect-chain">In Effect Chain</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let stereo_source = /* ... */;
let router = builder.add_channel_router(ChannelMode::Stereo);
let pan = builder.add_panner(0.0);

builder.connect(stereo_source, 0, router, 0);  // Left
builder.connect(stereo_source, 1, router, 1);  // Right
builder.connect(router, 0, pan, 0);
<span class="boring">}</span></code></pre>
<h2 id="extended-features"><a class="header" href="#extended-features">Extended Features</a></h2>
<p>Some implementations support additional options:</p>
<ul>
<li><strong>Invert Phase</strong>: Flip polarity of one or both channels</li>
<li><strong>Mono Sum</strong>: Mix L+R to mono</li>
<li><strong>Mid/Side</strong>: Convert between L/R and M/S</li>
</ul>
<p>Check documentation for available features in your version.</p>
<h2 id="implementation-notes-3"><a class="header" href="#implementation-notes-3">Implementation Notes</a></h2>
<ul>
<li>Zero processing latency</li>
<li>No allocation during process</li>
<li>Simple sample copying/routing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="modulators-1"><a class="header" href="#modulators-1">Modulators</a></h1>
<p>Modulator blocks generate control signals for parameter modulation.</p>
<h2 id="available-modulators"><a class="header" href="#available-modulators">Available Modulators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Block</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="#lfoblock">LfoBlock</a></td><td>Low-frequency oscillator</td></tr>
<tr><td><a href="#envelopeblock">EnvelopeBlock</a></td><td>ADSR envelope</td></tr>
</tbody>
</table>
</div>
<h2 id="characteristics-3"><a class="header" href="#characteristics-3">Characteristics</a></h2>
<p>Modulators have:</p>
<ul>
<li><strong>0 audio inputs</strong> - They generate control signals</li>
<li><strong>0 audio outputs</strong> - Output is via modulation system</li>
<li><strong>1+ modulation outputs</strong> - Control signal outputs</li>
</ul>
<h2 id="modulation-vs-audio"><a class="header" href="#modulation-vs-audio">Modulation vs Audio</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Audio</th><th>Modulation</th></tr>
</thead>
<tbody>
<tr><td>Rate</td><td>Sample rate</td><td>Per-block</td></tr>
<tr><td>Range</td><td>-1.0 to 1.0</td><td>-1.0 to 1.0</td></tr>
<tr><td>Purpose</td><td>Listening</td><td>Parameter control</td></tr>
</tbody>
</table>
</div>
<h2 id="usage-pattern-3"><a class="header" href="#usage-pattern-3">Usage Pattern</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Create modulator
let lfo = builder.add_lfo(5.0, Waveform::Sine);

// Use it to modulate an oscillator
let osc = builder.add_oscillator(440.0, Waveform::Sine, Some(lfo));
<span class="boring">}</span></code></pre>
<h2 id="modulation-routing"><a class="header" href="#modulation-routing">Modulation Routing</a></h2>
<p>Modulators connect differently than audio blocks:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Audio connection
builder.connect(audio_block, output_port, target_block, input_port);

// Modulation is specified at block creation
let osc = builder.add_oscillator(freq, waveform, Some(modulator_id));
let gain = builder.add_gain_with_modulation(level, Some(modulator_id));
<span class="boring">}</span></code></pre>
<h2 id="combining-modulators"><a class="header" href="#combining-modulators">Combining Modulators</a></h2>
<p>Layer multiple modulation sources:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Slow sweep
let slow_lfo = builder.add_lfo(0.1, Waveform::Sine);

// Fast vibrato
let fast_lfo = builder.add_lfo(6.0, Waveform::Sine);

// Use for different parameters
let osc = builder.add_oscillator(440.0, Waveform::Sine, Some(fast_lfo));
let gain = builder.add_gain_with_modulation(-6.0, Some(slow_lfo));
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lfoblock"><a class="header" href="#lfoblock">LfoBlock</a></h1>
<p>Low-frequency oscillator for parameter modulation.</p>
<h2 id="overview-22"><a class="header" href="#overview-22">Overview</a></h2>
<p><code>LfoBlock</code> generates low-frequency control signals for modulating parameters like pitch, amplitude, and filter cutoff.</p>
<h2 id="creating-an-lfo"><a class="header" href="#creating-an-lfo">Creating an LFO</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::{graph::GraphBuilder, waveform::Waveform};

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let lfo = builder.add_lfo(
    5.0,            // Rate in Hz
    Waveform::Sine, // Waveform
);
<span class="boring">}</span></code></pre>
<h2 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Type</th><th>Range</th><th>Default</th></tr>
</thead>
<tbody>
<tr><td>Rate</td><td>f64</td><td>0.01 - 100 Hz</td><td>1.0</td></tr>
<tr><td>Waveform</td><td>enum</td><td>See below</td><td>Sine</td></tr>
</tbody>
</table>
</div>
<h2 id="waveforms-1"><a class="header" href="#waveforms-1">Waveforms</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Waveform</th><th>Output Range</th><th>Character</th></tr>
</thead>
<tbody>
<tr><td>Sine</td><td>-1.0 to 1.0</td><td>Smooth, natural</td></tr>
<tr><td>Triangle</td><td>-1.0 to 1.0</td><td>Linear sweeps</td></tr>
<tr><td>Square</td><td>-1.0 and 1.0</td><td>On/off switching</td></tr>
<tr><td>Saw</td><td>-1.0 to 1.0</td><td>Ramp up, reset</td></tr>
</tbody>
</table>
</div>
<h2 id="port-layout-6"><a class="header" href="#port-layout-6">Port Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Port</th><th>Direction</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Modulation Output</td><td>Control signal</td></tr>
</tbody>
</table>
</div>
<h2 id="usage-examples-6"><a class="header" href="#usage-examples-6">Usage Examples</a></h2>
<h3 id="vibrato-pitch-modulation-1"><a class="header" href="#vibrato-pitch-modulation-1">Vibrato (Pitch Modulation)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lfo = builder.add_lfo(5.0, Waveform::Sine);
let osc = builder.add_oscillator(440.0, Waveform::Sine, Some(lfo));
<span class="boring">}</span></code></pre>
<h3 id="tremolo-amplitude-modulation-1"><a class="header" href="#tremolo-amplitude-modulation-1">Tremolo (Amplitude Modulation)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lfo = builder.add_lfo(6.0, Waveform::Sine);
let gain = builder.add_gain_with_modulation(-6.0, Some(lfo));
<span class="boring">}</span></code></pre>
<h3 id="auto-pan-1"><a class="header" href="#auto-pan-1">Auto-Pan</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lfo = builder.add_lfo(0.25, Waveform::Sine);  // Slow
let pan = builder.add_panner_with_modulation(0.0, Some(lfo));
<span class="boring">}</span></code></pre>
<h2 id="rate-guidelines"><a class="header" href="#rate-guidelines">Rate Guidelines</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Application</th><th>Typical Rate</th></tr>
</thead>
<tbody>
<tr><td>Vibrato</td><td>4-7 Hz</td></tr>
<tr><td>Tremolo</td><td>4-10 Hz</td></tr>
<tr><td>Auto-pan</td><td>0.1-1 Hz</td></tr>
<tr><td>Wobble bass</td><td>1-4 Hz</td></tr>
<tr><td>Sweep</td><td>0.05-0.5 Hz</td></tr>
</tbody>
</table>
</div>
<h2 id="output-scaling"><a class="header" href="#output-scaling">Output Scaling</a></h2>
<p>LFO output is -1.0 to 1.0. The receiving block interprets this:</p>
<ul>
<li><strong>Pitch</strong>: Maps to frequency deviation</li>
<li><strong>Amplitude</strong>: Maps to gain change</li>
<li><strong>Pan</strong>: Maps to position change</li>
</ul>
<h2 id="implementation-notes-4"><a class="header" href="#implementation-notes-4">Implementation Notes</a></h2>
<ul>
<li>Generates per-block (not per-sample)</li>
<li>Phase is continuous across blocks</li>
<li>Rate can be modulated (for complex modulation)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="envelopeblock"><a class="header" href="#envelopeblock">EnvelopeBlock</a></h1>
<p>ADSR envelope generator for amplitude and parameter shaping.</p>
<h2 id="overview-23"><a class="header" href="#overview-23">Overview</a></h2>
<p><code>EnvelopeBlock</code> generates attack-decay-sustain-release envelopes, typically used for controlling amplitude or filter cutoff over time.</p>
<h2 id="creating-an-envelope"><a class="header" href="#creating-an-envelope">Creating an Envelope</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let envelope = builder.add_envelope(
    0.01,   // Attack: 10ms
    0.1,    // Decay: 100ms
    0.7,    // Sustain: 70% level
    0.3,    // Release: 300ms
);
<span class="boring">}</span></code></pre>
<h2 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Type</th><th>Range</th><th>Default</th></tr>
</thead>
<tbody>
<tr><td>Attack</td><td>f64</td><td>0.0 - 10.0 s</td><td>0.01</td></tr>
<tr><td>Decay</td><td>f64</td><td>0.0 - 10.0 s</td><td>0.1</td></tr>
<tr><td>Sustain</td><td>f64</td><td>0.0 - 1.0</td><td>0.5</td></tr>
<tr><td>Release</td><td>f64</td><td>0.0 - 10.0 s</td><td>0.3</td></tr>
</tbody>
</table>
</div>
<h3 id="adsr-stages"><a class="header" href="#adsr-stages">ADSR Stages</a></h3>
<pre><code>Level
  ^
  |    /\
  |   /  \______ Sustain
  |  /          \
  | /            \
  |/              \______
  +--A--D----S----R--&gt; Time
</code></pre>
<ul>
<li><strong>Attack</strong>: Time to reach maximum level</li>
<li><strong>Decay</strong>: Time to fall to sustain level</li>
<li><strong>Sustain</strong>: Level held while note is held</li>
<li><strong>Release</strong>: Time to fall to zero after note off</li>
</ul>
<h2 id="port-layout-7"><a class="header" href="#port-layout-7">Port Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Port</th><th>Direction</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Modulation Output</td><td>Envelope signal (0.0 - 1.0)</td></tr>
</tbody>
</table>
</div>
<h2 id="usage-examples-7"><a class="header" href="#usage-examples-7">Usage Examples</a></h2>
<h3 id="amplitude-envelope"><a class="header" href="#amplitude-envelope">Amplitude Envelope</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = builder.add_envelope(0.01, 0.1, 0.7, 0.3);
let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let gain = builder.add_gain_with_modulation(-6.0, Some(env));

builder.connect(osc, 0, gain, 0);
<span class="boring">}</span></code></pre>
<h3 id="pluck-sound-short-decay"><a class="header" href="#pluck-sound-short-decay">Pluck Sound (Short Decay)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = builder.add_envelope(
    0.001,  // Very fast attack
    0.2,    // Medium decay
    0.0,    // No sustain
    0.1,    // Short release
);
<span class="boring">}</span></code></pre>
<h3 id="pad-sound-long-attack"><a class="header" href="#pad-sound-long-attack">Pad Sound (Long Attack)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = builder.add_envelope(
    0.5,    // Slow attack
    0.3,    // Medium decay
    0.8,    // High sustain
    1.0,    // Long release
);
<span class="boring">}</span></code></pre>
<h3 id="percussive-no-sustain"><a class="header" href="#percussive-no-sustain">Percussive (No Sustain)</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = builder.add_envelope(
    0.002,  // Instant attack
    0.5,    // Decay only
    0.0,    // No sustain
    0.0,    // No release
);
<span class="boring">}</span></code></pre>
<h2 id="envelope-shapes"><a class="header" href="#envelope-shapes">Envelope Shapes</a></h2>
<h3 id="linear"><a class="header" href="#linear">Linear</a></h3>
<p>Constant rate of change:</p>
<pre><code>Attack: level += rate_per_sample
</code></pre>
<h3 id="exponential"><a class="header" href="#exponential">Exponential</a></h3>
<p>More natural-sounding:</p>
<pre><code>Attack: level *= (1.0 - coefficient)
</code></pre>
<h2 id="triggering"><a class="header" href="#triggering">Triggering</a></h2>
<p>Envelopes need a trigger signal:</p>
<ul>
<li>Note On → Start attack stage</li>
<li>Note Off → Start release stage (if sustain &gt; 0)</li>
</ul>
<p>Trigger integration depends on your implementation (MIDI, gate signal, etc.).</p>
<h2 id="output-range"><a class="header" href="#output-range">Output Range</a></h2>
<ul>
<li>Output: 0.0 to 1.0 (unipolar)</li>
<li>Starts at 0.0 (not triggered)</li>
<li>Reaches 1.0 at end of attack</li>
<li>Falls to sustain level during decay</li>
<li>Returns to 0.0 during release</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="io-blocks"><a class="header" href="#io-blocks">I/O Blocks</a></h1>
<p>I/O blocks handle audio input and output for graphs.</p>
<h2 id="available-io-blocks"><a class="header" href="#available-io-blocks">Available I/O Blocks</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Block</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="#fileinputblock">FileInputBlock</a></td><td>Read from audio files</td></tr>
<tr><td><a href="#fileoutputblock">FileOutputBlock</a></td><td>Write to audio files</td></tr>
<tr><td><a href="#outputblock">OutputBlock</a></td><td>Graph audio output</td></tr>
</tbody>
</table>
</div>
<h2 id="block-roles"><a class="header" href="#block-roles">Block Roles</a></h2>
<h3 id="source-fileinputblock"><a class="header" href="#source-fileinputblock">Source (FileInputBlock)</a></h3>
<p>Provides audio from external files:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let reader = WavFileReader::from_path("input.wav")?;
let input = builder.add_file_input(Box::new(reader));
<span class="boring">}</span></code></pre>
<h3 id="sink-fileoutputblock"><a class="header" href="#sink-fileoutputblock">Sink (FileOutputBlock)</a></h3>
<p>Writes audio to external files:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let writer = WavFileWriter::new("output.wav", 44100.0, 2)?;
let output = builder.add_file_output(Box::new(writer));
<span class="boring">}</span></code></pre>
<h3 id="terminal-outputblock"><a class="header" href="#terminal-outputblock">Terminal (OutputBlock)</a></h3>
<p>Collects audio for real-time output or further processing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Automatically added by GraphBuilder when building
let graph = builder.build();
// Output is collected via process_buffers()
<span class="boring">}</span></code></pre>
<h2 id="usage-patterns-2"><a class="header" href="#usage-patterns-2">Usage Patterns</a></h2>
<h3 id="file-processing"><a class="header" href="#file-processing">File Processing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;
use bbx_file::{readers::wav::WavFileReader, writers::wav::WavFileWriter};

// Set up I/O
let reader = WavFileReader::from_path("input.wav")?;
let writer = WavFileWriter::new("output.wav", 44100.0, 2)?;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// Create graph: Input -&gt; Effect -&gt; Output
let file_in = builder.add_file_input(Box::new(reader));
let gain = builder.add_gain(-6.0);
let file_out = builder.add_file_output(Box::new(writer));

builder.connect(file_in, 0, gain, 0);
builder.connect(gain, 0, file_out, 0);

let mut graph = builder.build();

// Process entire file
loop {
    let mut left = vec![0.0f32; 512];
    let mut right = vec![0.0f32; 512];
    let mut outputs: [&amp;mut [f32]; 2] = [&amp;mut left, &amp;mut right];
    graph.process_buffers(&amp;mut outputs);

    // Check for end of file...
}

// Finalize output file
graph.finalize();
<span class="boring">}</span></code></pre>
<h3 id="real-time-processing"><a class="header" href="#real-time-processing">Real-Time Processing</a></h3>
<p>For real-time (plugin, live), use OutputBlock implicitly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
// OutputBlock added automatically

let mut graph = builder.build();

// Audio callback
fn process(graph: &amp;mut Graph, output: &amp;mut AudioBuffer) {
    graph.process_buffers(&amp;mut output.channels());
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fileinputblock"><a class="header" href="#fileinputblock">FileInputBlock</a></h1>
<p>Read audio from files for processing in DSP graphs.</p>
<h2 id="overview-24"><a class="header" href="#overview-24">Overview</a></h2>
<p><code>FileInputBlock</code> wraps a <code>Reader</code> implementation to provide file-based audio input to a DSP graph.</p>
<h2 id="creating-a-file-input"><a class="header" href="#creating-a-file-input">Creating a File Input</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;
use bbx_file::readers::wav::WavFileReader;

let reader = WavFileReader::&lt;f32&gt;::from_path("input.wav")?;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);
let file_in = builder.add_file_input(Box::new(reader));
<span class="boring">}</span></code></pre>
<h2 id="port-layout-8"><a class="header" href="#port-layout-8">Port Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Port</th><th>Direction</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Output</td><td>Left channel</td></tr>
<tr><td>1</td><td>Output</td><td>Right channel (if stereo)</td></tr>
<tr><td>N</td><td>Output</td><td>Channel N</td></tr>
</tbody>
</table>
</div>
<h2 id="usage-examples-8"><a class="header" href="#usage-examples-8">Usage Examples</a></h2>
<h3 id="basic-file-playback"><a class="header" href="#basic-file-playback">Basic File Playback</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let reader = WavFileReader::from_path("audio.wav")?;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);
let file_in = builder.add_file_input(Box::new(reader));

// Process through effects
let gain = builder.add_gain(-6.0);
builder.connect(file_in, 0, gain, 0);
<span class="boring">}</span></code></pre>
<h3 id="stereo-file"><a class="header" href="#stereo-file">Stereo File</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let reader = WavFileReader::from_path("stereo.wav")?;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);
let file_in = builder.add_file_input(Box::new(reader));

// Connect both channels
let gain = builder.add_gain(-6.0);
let pan = builder.add_panner(0.0);

// Left channel
builder.connect(file_in, 0, gain, 0);
// Right channel
builder.connect(file_in, 1, pan, 0);
<span class="boring">}</span></code></pre>
<h3 id="file-to-file-processing"><a class="header" href="#file-to-file-processing">File to File Processing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let reader = WavFileReader::from_path("input.wav")?;
let writer = WavFileWriter::new("output.wav", 44100.0, 2)?;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let file_in = builder.add_file_input(Box::new(reader));
let effect = builder.add_overdrive(3.0, 1.0, 0.8, 44100.0);
let file_out = builder.add_file_output(Box::new(writer));

builder.connect(file_in, 0, effect, 0);
builder.connect(effect, 0, file_out, 0);

let mut graph = builder.build();

// Process all samples...
graph.finalize();
<span class="boring">}</span></code></pre>
<h2 id="implementation-notes-5"><a class="header" href="#implementation-notes-5">Implementation Notes</a></h2>
<ul>
<li>File is loaded into memory on creation</li>
<li>Samples are read from internal buffer during process</li>
<li>Looping behavior depends on implementation</li>
<li>Returns zeros after file ends (no looping by default)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="fileoutputblock"><a class="header" href="#fileoutputblock">FileOutputBlock</a></h1>
<p>Write processed audio to files.</p>
<h2 id="overview-25"><a class="header" href="#overview-25">Overview</a></h2>
<p><code>FileOutputBlock</code> wraps a <code>Writer</code> implementation to save audio from a DSP graph to disk.</p>
<h2 id="creating-a-file-output"><a class="header" href="#creating-a-file-output">Creating a File Output</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_dsp::graph::GraphBuilder;
use bbx_file::writers::wav::WavFileWriter;

let writer = WavFileWriter::&lt;f32&gt;::new("output.wav", 44100.0, 2)?;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);
let file_out = builder.add_file_output(Box::new(writer));
<span class="boring">}</span></code></pre>
<h2 id="port-layout-9"><a class="header" href="#port-layout-9">Port Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Port</th><th>Direction</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Input</td><td>Left channel</td></tr>
<tr><td>1</td><td>Input</td><td>Right channel (if stereo)</td></tr>
<tr><td>N</td><td>Input</td><td>Channel N</td></tr>
</tbody>
</table>
</div>
<h2 id="usage-examples-9"><a class="header" href="#usage-examples-9">Usage Examples</a></h2>
<h3 id="recording-synthesizer-output"><a class="header" href="#recording-synthesizer-output">Recording Synthesizer Output</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let writer = WavFileWriter::new("synth_output.wav", 44100.0, 2)?;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let gain = builder.add_gain(-6.0);
let file_out = builder.add_file_output(Box::new(writer));

builder.connect(osc, 0, gain, 0);
builder.connect(gain, 0, file_out, 0);

let mut graph = builder.build();

// Generate 5 seconds of audio
let samples_per_second = 44100;
let total_samples = samples_per_second * 5;
let buffer_size = 512;
let num_buffers = total_samples / buffer_size;

for _ in 0..num_buffers {
    let mut left = vec![0.0f32; buffer_size];
    let mut right = vec![0.0f32; buffer_size];
    let mut outputs: [&amp;mut [f32]; 2] = [&amp;mut left, &amp;mut right];
    graph.process_buffers(&amp;mut outputs);
}

// Important: finalize to close the file
graph.finalize();
<span class="boring">}</span></code></pre>
<h3 id="stereo-recording"><a class="header" href="#stereo-recording">Stereo Recording</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let writer = WavFileWriter::new("stereo.wav", 44100.0, 2)?;

let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let pan = builder.add_panner(0.25);  // Slightly right
let file_out = builder.add_file_output(Box::new(writer));

builder.connect(osc, 0, pan, 0);
builder.connect(pan, 0, file_out, 0);  // Left
builder.connect(pan, 1, file_out, 1);  // Right

let mut graph = builder.build();
// Process...
graph.finalize();
<span class="boring">}</span></code></pre>
<h2 id="finalization-2"><a class="header" href="#finalization-2">Finalization</a></h2>
<p><strong>Always call <code>finalize()</code></strong> after processing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>graph.finalize();
<span class="boring">}</span></code></pre>
<p>This:</p>
<ul>
<li>Flushes buffered data</li>
<li>Updates file headers (WAV size fields)</li>
<li>Closes the file handle</li>
</ul>
<p>Without finalization, the file may be corrupt.</p>
<h2 id="non-blocking-io-1"><a class="header" href="#non-blocking-io-1">Non-Blocking I/O</a></h2>
<p><code>FileOutputBlock</code> uses non-blocking I/O:</p>
<ul>
<li>Audio thread fills buffers</li>
<li>Background thread writes to disk</li>
<li>No blocking during process()</li>
<li>Buffers are flushed during finalize()</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="outputblock"><a class="header" href="#outputblock">OutputBlock</a></h1>
<p>Terminal output block for collecting processed audio.</p>
<h2 id="overview-26"><a class="header" href="#overview-26">Overview</a></h2>
<p><code>OutputBlock</code> is the graph’s audio output destination. It collects processed audio from connected blocks and provides it via <code>process_buffers()</code>.</p>
<h2 id="automatic-creation"><a class="header" href="#automatic-creation">Automatic Creation</a></h2>
<p><code>OutputBlock</code> is automatically added when building a graph:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);
let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
// OutputBlock added automatically during build()
let graph = builder.build();
<span class="boring">}</span></code></pre>
<h2 id="port-layout-10"><a class="header" href="#port-layout-10">Port Layout</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Port</th><th>Direction</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Input</td><td>Left channel</td></tr>
<tr><td>1</td><td>Input</td><td>Right channel</td></tr>
<tr><td>N</td><td>Input</td><td>Channel N (up to num_channels)</td></tr>
</tbody>
</table>
</div>
<h2 id="usage-5"><a class="header" href="#usage-5">Usage</a></h2>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
// Oscillator automatically connects to output

let mut graph = builder.build();

// Collect processed audio
let mut left = vec![0.0f32; 512];
let mut right = vec![0.0f32; 512];
let mut outputs: [&amp;mut [f32]; 2] = [&amp;mut left, &amp;mut right];
graph.process_buffers(&amp;mut outputs);

// 'left' and 'right' now contain the oscillator output
<span class="boring">}</span></code></pre>
<h3 id="explicit-connection"><a class="header" href="#explicit-connection">Explicit Connection</a></h3>
<p>For complex routing, connect blocks explicitly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
let gain = builder.add_gain(-6.0);
let pan = builder.add_panner(0.0);

builder.connect(osc, 0, gain, 0);
builder.connect(gain, 0, pan, 0);
// pan's outputs will be collected

let graph = builder.build();
<span class="boring">}</span></code></pre>
<h2 id="channel-count"><a class="header" href="#channel-count">Channel Count</a></h2>
<p>The number of output channels is set at graph creation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Mono output
let builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 1);

// Stereo output
let builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);

// 5.1 surround
let builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 6);
<span class="boring">}</span></code></pre>
<h2 id="output-buffer"><a class="header" href="#output-buffer">Output Buffer</a></h2>
<p>The output buffer must match the graph’s configuration:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num_channels = 2;
let buffer_size = 512;

let mut buffers: Vec&lt;Vec&lt;f32&gt;&gt; = (0..num_channels)
    .map(|_| vec![0.0; buffer_size])
    .collect();

let mut outputs: Vec&lt;&amp;mut [f32]&gt; = buffers
    .iter_mut()
    .map(|b| b.as_mut_slice())
    .collect();

graph.process_buffers(&amp;mut outputs);
<span class="boring">}</span></code></pre>
<h2 id="implementation-notes-6"><a class="header" href="#implementation-notes-6">Implementation Notes</a></h2>
<ul>
<li>Terminal block (no outputs)</li>
<li>Collects audio from all connected sources</li>
<li>Multiple connections are summed</li>
<li>Part of the graph’s execution order</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dsp-graph-architecture"><a class="header" href="#dsp-graph-architecture">DSP Graph Architecture</a></h1>
<p>The core design of bbx_audio’s DSP processing system.</p>
<h2 id="overview-27"><a class="header" href="#overview-27">Overview</a></h2>
<p>bbx_audio uses a directed acyclic graph (DAG) architecture where:</p>
<ol>
<li><strong>Blocks</strong> are processing nodes</li>
<li><strong>Connections</strong> define signal flow</li>
<li><strong>Topological sorting</strong> determines execution order</li>
<li><strong>Pre-allocated buffers</strong> enable real-time processing</li>
</ol>
<h2 id="key-components-2"><a class="header" href="#key-components-2">Key Components</a></h2>
<h3 id="graph-1"><a class="header" href="#graph-1">Graph</a></h3>
<p>The <code>Graph</code> struct manages:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Graph&lt;S: Sample&gt; {
    blocks: Vec&lt;BlockType&lt;S&gt;&gt;,           // All DSP blocks
    connections: Vec&lt;Connection&gt;,         // Block connections
    execution_order: Vec&lt;BlockId&gt;,        // Sorted processing order
    output_block: Option&lt;BlockId&gt;,        // Final output
    audio_buffers: Vec&lt;AudioBuffer&lt;S&gt;&gt;,   // Pre-allocated buffers
    modulation_values: Vec&lt;S&gt;,            // Per-block modulation
}
<span class="boring">}</span></code></pre>
<h3 id="graphbuilder-2"><a class="header" href="#graphbuilder-2">GraphBuilder</a></h3>
<p>Fluent API for construction:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let graph = GraphBuilder::new(44100.0, 512, 2)
    .add_oscillator(440.0, Waveform::Sine, None)
    .add_gain(-6.0)
    .connect(0, 0, 1, 0)
    .build();
<span class="boring">}</span></code></pre>
<h3 id="connection"><a class="header" href="#connection">Connection</a></h3>
<p>Describes signal routing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Connection {
    pub from: BlockId,        // Source block
    pub from_output: usize,   // Output port
    pub to: BlockId,          // Destination block
    pub to_input: usize,      // Input port
}
<span class="boring">}</span></code></pre>
<h2 id="processing-pipeline"><a class="header" href="#processing-pipeline">Processing Pipeline</a></h2>
<ol>
<li><strong>Clear buffers</strong> - Zero all audio buffers</li>
<li><strong>Execute blocks</strong> - Process in topological order</li>
<li><strong>Collect modulation</strong> - Gather modulator outputs</li>
<li><strong>Copy output</strong> - Transfer to user buffers</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn process_buffers(&amp;mut self, output_buffers: &amp;mut [&amp;mut [S]]) {
    // Clear all buffers
    for buffer in &amp;mut self.audio_buffers {
        buffer.zeroize();
    }

    // Process blocks in order
    for block_id in &amp;self.execution_order {
        self.process_block(*block_id);
        self.collect_modulation_values(*block_id);
    }

    // Copy to output
    self.copy_to_output_buffer(output_buffers);
}
<span class="boring">}</span></code></pre>
<h2 id="design-decisions"><a class="header" href="#design-decisions">Design Decisions</a></h2>
<h3 id="pre-allocation"><a class="header" href="#pre-allocation">Pre-allocation</a></h3>
<p>All buffers are allocated during <code>prepare_for_playback()</code>:</p>
<ul>
<li>No allocations during processing</li>
<li>Fixed buffer sizes</li>
<li>Predictable memory usage</li>
</ul>
<h3 id="stack-based-io"><a class="header" href="#stack-based-io">Stack-Based I/O</a></h3>
<p>Input/output slices use stack allocation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_BLOCK_INPUTS: usize = 8;
const MAX_BLOCK_OUTPUTS: usize = 8;

let mut input_slices: StackVec&lt;&amp;[S], MAX_BLOCK_INPUTS&gt; = StackVec::new();
<span class="boring">}</span></code></pre>
<h3 id="buffer-indexing"><a class="header" href="#buffer-indexing">Buffer Indexing</a></h3>
<p>Each block has a contiguous range of buffers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_buffer_index(&amp;self, block_id: BlockId, output_index: usize) -&gt; usize {
    self.block_buffer_start[block_id.0] + output_index
}
<span class="boring">}</span></code></pre>
<h2 id="related-topics"><a class="header" href="#related-topics">Related Topics</a></h2>
<ul>
<li><a href="#topological-sorting">Topological Sorting</a> - Execution order algorithm</li>
<li><a href="#buffer-management">Buffer Management</a> - Buffer allocation strategy</li>
<li><a href="#real-time-safety">Real-Time Safety</a> - Audio thread constraints</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="topological-sorting"><a class="header" href="#topological-sorting">Topological Sorting</a></h1>
<p>How block execution order is determined.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>DSP blocks must execute in the correct order:</p>
<pre><code>Oscillator -&gt; Gain -&gt; Output
</code></pre>
<p>The oscillator must run first (it produces audio), then gain (processes it), then output (collects it).</p>
<h2 id="kahns-algorithm"><a class="header" href="#kahns-algorithm">Kahn’s Algorithm</a></h2>
<p>bbx_audio uses Kahn’s algorithm for topological sorting:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn topological_sort(&amp;self) -&gt; Vec&lt;BlockId&gt; {
    let mut in_degree = vec![0; self.blocks.len()];
    let mut adjacency_list: HashMap&lt;BlockId, Vec&lt;BlockId&gt;&gt; = HashMap::new();

    // Build graph
    for connection in &amp;self.connections {
        adjacency_list.entry(connection.from).or_default().push(connection.to);
        in_degree[connection.to.0] += 1;
    }

    // Find blocks with no dependencies
    let mut queue = Vec::new();
    for (i, &amp;degree) in in_degree.iter().enumerate() {
        if degree == 0 {
            queue.push(BlockId(i));
        }
    }

    // Process in dependency order
    let mut result = Vec::new();
    while let Some(block) = queue.pop() {
        result.push(block);
        if let Some(neighbors) = adjacency_list.get(&amp;block) {
            for &amp;neighbor in neighbors {
                in_degree[neighbor.0] -= 1;
                if in_degree[neighbor.0] == 0 {
                    queue.push(neighbor);
                }
            }
        }
    }

    result
}
<span class="boring">}</span></code></pre>
<h2 id="algorithm-steps"><a class="header" href="#algorithm-steps">Algorithm Steps</a></h2>
<ol>
<li><strong>Calculate in-degrees</strong>: Count incoming connections for each block</li>
<li><strong>Initialize queue</strong>: Add blocks with no inputs (sources)</li>
<li><strong>Process queue</strong>:
<ul>
<li>Remove a block from queue</li>
<li>Add to result</li>
<li>Decrement in-degree of connected blocks</li>
<li>Add newly zero-degree blocks to queue</li>
</ul>
</li>
<li><strong>Result</strong>: Blocks in valid execution order</li>
</ol>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Given this graph:</p>
<pre><code>Osc (0) -&gt; Gain (1) -&gt; Output (2)
           ^
LFO (3) --/
</code></pre>
<p>Connections:</p>
<ul>
<li>0 -&gt; 1</li>
<li>3 -&gt; 1</li>
<li>1 -&gt; 2</li>
</ul>
<p>In-degrees:</p>
<ul>
<li>Block 0: 0 (no inputs)</li>
<li>Block 1: 2 (from 0 and 3)</li>
<li>Block 2: 1 (from 1)</li>
<li>Block 3: 0 (no inputs)</li>
</ul>
<p>Processing:</p>
<ol>
<li>Queue: [0, 3] (in-degree 0)</li>
<li>Pop 0, result: [0], decrement block 1</li>
<li>Pop 3, result: [0, 3], decrement block 1 (now 0)</li>
<li>Queue: [1], pop 1, result: [0, 3, 1], decrement block 2 (now 0)</li>
<li>Queue: [2], pop 2, result: [0, 3, 1, 2]</li>
</ol>
<h2 id="cycle-detection"><a class="header" href="#cycle-detection">Cycle Detection</a></h2>
<p>If the result length doesn’t match block count, there’s a cycle:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if result.len() != self.blocks.len() {
    // Graph has a cycle - invalid!
}
<span class="boring">}</span></code></pre>
<p>Cycles are not allowed in DSP graphs (would cause infinite loops).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="buffer-management"><a class="header" href="#buffer-management">Buffer Management</a></h1>
<p>How audio buffers are allocated and managed.</p>
<h2 id="buffer-layout"><a class="header" href="#buffer-layout">Buffer Layout</a></h2>
<p>Each block’s outputs get contiguous buffer indices:</p>
<pre><code>Block 0 (Oscillator): 1 output  -&gt; Buffer 0
Block 1 (Panner):     2 outputs -&gt; Buffers 1, 2
Block 2 (Output):     2 outputs -&gt; Buffers 3, 4
</code></pre>
<h2 id="pre-allocation-1"><a class="header" href="#pre-allocation-1">Pre-Allocation</a></h2>
<p>Buffers are allocated when blocks are added:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_block(&amp;mut self, block: BlockType&lt;S&gt;) -&gt; BlockId {
    let block_id = BlockId(self.blocks.len());

    // Record where this block's buffers start
    self.block_buffer_start.push(self.audio_buffers.len());
    self.blocks.push(block);

    // Allocate buffers for each output
    let output_count = self.blocks[block_id.0].output_count();
    for _ in 0..output_count {
        self.audio_buffers.push(AudioBuffer::new(self.buffer_size));
    }

    block_id
}
<span class="boring">}</span></code></pre>
<h2 id="buffer-indexing-1"><a class="header" href="#buffer-indexing-1">Buffer Indexing</a></h2>
<p>Fast O(1) lookup:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_buffer_index(&amp;self, block_id: BlockId, output_index: usize) -&gt; usize {
    self.block_buffer_start[block_id.0] + output_index
}
<span class="boring">}</span></code></pre>
<h2 id="connection-lookup"><a class="header" href="#connection-lookup">Connection Lookup</a></h2>
<p>Input connections are pre-computed for O(1) access:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pre-computed during prepare_for_playback()
self.block_input_buffers = vec![Vec::new(); self.blocks.len()];
for conn in &amp;self.connections {
    let buffer_idx = self.get_buffer_index(conn.from, conn.from_output);
    self.block_input_buffers[conn.to.0].push(buffer_idx);
}

// During processing - O(1) lookup
let input_indices = &amp;self.block_input_buffers[block_id.0];
<span class="boring">}</span></code></pre>
<h2 id="buffer-clearing"><a class="header" href="#buffer-clearing">Buffer Clearing</a></h2>
<p>All buffers are zeroed at the start of each processing cycle:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for buffer in &amp;mut self.audio_buffers {
    buffer.zeroize();
}
<span class="boring">}</span></code></pre>
<p>This allows multiple connections to the same input (signals are summed).</p>
<h2 id="memory-efficiency"><a class="header" href="#memory-efficiency">Memory Efficiency</a></h2>
<ul>
<li>Buffers are reused across processing cycles</li>
<li>No allocations during <code>process_buffers()</code></li>
<li>Fixed memory footprint based on block count</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="connection-system"><a class="header" href="#connection-system">Connection System</a></h1>
<p>How blocks are connected in the DSP graph.</p>
<h2 id="connection-structure"><a class="header" href="#connection-structure">Connection Structure</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Connection {
    pub from: BlockId,        // Source block
    pub from_output: usize,   // Which output port
    pub to: BlockId,          // Destination block
    pub to_input: usize,      // Which input port
}
<span class="boring">}</span></code></pre>
<h2 id="port-numbering"><a class="header" href="#port-numbering">Port Numbering</a></h2>
<p>Ports are zero-indexed:</p>
<pre><code>OscillatorBlock:
  Outputs: [0] (mono audio)

PannerBlock:
  Inputs:  [0] (mono in)
  Outputs: [0] (left), [1] (right)
</code></pre>
<h2 id="making-connections"><a class="header" href="#making-connections">Making Connections</a></h2>
<p>Via GraphBuilder:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>builder.connect(
    oscillator_id,  // from
    0,              // from_output
    panner_id,      // to
    0,              // to_input
);
<span class="boring">}</span></code></pre>
<h2 id="connection-rules-1"><a class="header" href="#connection-rules-1">Connection Rules</a></h2>
<h3 id="one-to-many"><a class="header" href="#one-to-many">One-to-Many</a></h3>
<p>An output can connect to multiple inputs:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>builder.connect(osc, 0, gain1, 0);
builder.connect(osc, 0, gain2, 0);  // Same output, different targets
<span class="boring">}</span></code></pre>
<h3 id="many-to-one"><a class="header" href="#many-to-one">Many-to-One</a></h3>
<p>Multiple outputs can connect to the same input (summed):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>builder.connect(osc1, 0, mixer, 0);
builder.connect(osc2, 0, mixer, 0);  // Both summed into mixer input
<span class="boring">}</span></code></pre>
<h3 id="no-cycles"><a class="header" href="#no-cycles">No Cycles</a></h3>
<p>Connections must form a DAG (directed acyclic graph):</p>
<pre><code>Valid:    A -&gt; B -&gt; C
Invalid:  A -&gt; B -&gt; A (cycle!)
</code></pre>
<h2 id="signal-summing"><a class="header" href="#signal-summing">Signal Summing</a></h2>
<p>When multiple connections go to the same input:</p>
<ol>
<li>Buffers start zeroed</li>
<li>Each source adds to the buffer</li>
<li>Result is the sum of all inputs</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Conceptually:
output_buffer[sample] += input_buffer[sample];
<span class="boring">}</span></code></pre>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>Connection validity is checked during <code>build()</code>:</p>
<ul>
<li>Source and destination blocks must exist</li>
<li>Port indices must be valid</li>
<li>Graph must be acyclic</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="real-time-safety"><a class="header" href="#real-time-safety">Real-Time Safety</a></h1>
<p>Constraints and patterns for audio thread processing.</p>
<h2 id="what-is-real-time-safe"><a class="header" href="#what-is-real-time-safe">What is Real-Time Safe?</a></h2>
<p>Audio processing must complete within a fixed time budget (buffer duration). Operations that can cause unbounded delays are forbidden.</p>
<h2 id="forbidden-in-audio-thread"><a class="header" href="#forbidden-in-audio-thread">Forbidden in Audio Thread</a></h2>
<h3 id="memory-allocation"><a class="header" href="#memory-allocation">Memory Allocation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD - Heap allocation
let vec = Vec::new();
let boxed = Box::new(value);

// GOOD - Pre-allocated
let mut vec: StackVec&lt;f32, 8&gt; = StackVec::new();
<span class="boring">}</span></code></pre>
<h3 id="locking"><a class="header" href="#locking">Locking</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD - Can block
let guard = mutex.lock().unwrap();

// GOOD - Lock-free
let value = atomic.load(Ordering::Relaxed);
<span class="boring">}</span></code></pre>
<h3 id="system-calls"><a class="header" href="#system-calls">System Calls</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD - Unbounded time
std::fs::read_to_string("file.txt");
std::thread::sleep(duration);

// GOOD - Pre-loaded data
let data = &amp;self.preloaded_buffer[..];
<span class="boring">}</span></code></pre>
<h2 id="bbx_audios-approach"><a class="header" href="#bbx_audios-approach">bbx_audio’s Approach</a></h2>
<h3 id="stack-allocation"><a class="header" href="#stack-allocation">Stack Allocation</a></h3>
<p>Using <code>StackVec</code> for bounded collections:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_BLOCK_INPUTS: usize = 8;
let mut input_slices: StackVec&lt;&amp;[S], MAX_BLOCK_INPUTS&gt; = StackVec::new();
<span class="boring">}</span></code></pre>
<h3 id="pre-computed-lookups"><a class="header" href="#pre-computed-lookups">Pre-computed Lookups</a></h3>
<p>Connection indices computed during prepare:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Computed once in prepare_for_playback()
self.block_input_buffers = vec![Vec::new(); self.blocks.len()];

// O(1) lookup during processing
let input_indices = &amp;self.block_input_buffers[block_id.0];
<span class="boring">}</span></code></pre>
<h3 id="pre-allocated-buffers"><a class="header" href="#pre-allocated-buffers">Pre-allocated Buffers</a></h3>
<p>All audio buffers allocated upfront:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// During add_block()
self.audio_buffers.push(AudioBuffer::new(self.buffer_size));

// During process - just clear
buffer.zeroize();
<span class="boring">}</span></code></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="cache-efficiency-1"><a class="header" href="#cache-efficiency-1">Cache Efficiency</a></h3>
<ul>
<li>Contiguous buffer storage</li>
<li>Sequential processing order</li>
<li>Minimal pointer chasing</li>
</ul>
<h3 id="branch-prediction"><a class="header" href="#branch-prediction">Branch Prediction</a></h3>
<ul>
<li>Consistent code paths</li>
<li>Avoid data-dependent branches</li>
<li>Use branchless algorithms where possible</li>
</ul>
<h3 id="simd-potential"><a class="header" href="#simd-potential">SIMD Potential</a></h3>
<ul>
<li>Buffer alignment</li>
<li>Processing in chunks</li>
<li>Sample-type genericity</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="stack-allocation-strategy"><a class="header" href="#stack-allocation-strategy">Stack Allocation Strategy</a></h1>
<p>How bbx_audio avoids heap allocations during processing.</p>
<h2 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h2>
<p>Audio processing must avoid heap allocation because:</p>
<ul>
<li><code>malloc()</code>/<code>free()</code> can take unbounded time</li>
<li>System allocator may lock</li>
<li>Heap fragmentation over time</li>
</ul>
<h2 id="stackvec-solution"><a class="header" href="#stackvec-solution">StackVec Solution</a></h2>
<p><code>StackVec&lt;T, N&gt;</code> provides vector-like behavior with stack storage:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_BLOCK_INPUTS: usize = 8;
let mut input_slices: StackVec&lt;&amp;[S], MAX_BLOCK_INPUTS&gt; = StackVec::new();

for &amp;index in input_indices {
    input_slices.push_unchecked(/* slice */);
}
<span class="boring">}</span></code></pre>
<h2 id="fixed-capacity-limits"><a class="header" href="#fixed-capacity-limits">Fixed Capacity Limits</a></h2>
<p>Blocks are limited to reasonable I/O counts:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_BLOCK_INPUTS: usize = 8;
const MAX_BLOCK_OUTPUTS: usize = 8;
<span class="boring">}</span></code></pre>
<p>These limits are validated during <code>build()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(
    connected_inputs &lt;= MAX_BLOCK_INPUTS,
    "Block {idx} has too many inputs"
);
<span class="boring">}</span></code></pre>
<h2 id="pre-allocation-pattern"><a class="header" href="#pre-allocation-pattern">Pre-Allocation Pattern</a></h2>
<p>Storage allocated once, reused forever:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In Graph struct
audio_buffers: Vec&lt;AudioBuffer&lt;S&gt;&gt;,
modulation_values: Vec&lt;S&gt;,

// In prepare_for_playback()
self.modulation_values.resize(self.blocks.len(), S::ZERO);

// In process_buffers() - just clear, no resize
for buffer in &amp;mut self.audio_buffers {
    buffer.zeroize();
}
<span class="boring">}</span></code></pre>
<h2 id="trade-offs"><a class="header" href="#trade-offs">Trade-offs</a></h2>
<h3 id="advantages"><a class="header" href="#advantages">Advantages</a></h3>
<ul>
<li>Zero allocations during processing</li>
<li>Predictable memory layout</li>
<li>No allocator contention</li>
</ul>
<h3 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages</a></h3>
<ul>
<li>Fixed maximum I/O counts</li>
<li>Higher upfront memory usage</li>
<li>Must know limits at compile time</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="denormal-prevention"><a class="header" href="#denormal-prevention">Denormal Prevention</a></h1>
<p>How bbx_audio handles denormal floating-point numbers.</p>
<h2 id="what-are-denormals"><a class="header" href="#what-are-denormals">What are Denormals?</a></h2>
<p>Denormal (subnormal) numbers are very small floats near zero:</p>
<pre><code>Normal:   1.0e-38   (exponent &gt; 0)
Denormal: 1.0e-40   (exponent = 0, mantissa != 0)
</code></pre>
<h2 id="the-problem-2"><a class="header" href="#the-problem-2">The Problem</a></h2>
<p>Processing denormals causes severe CPU slowdowns:</p>
<ul>
<li>10-100x slower operations</li>
<li>Unpredictable latency spikes</li>
<li>Common in audio (decaying signals)</li>
</ul>
<h2 id="flush-functions"><a class="header" href="#flush-functions">Flush Functions</a></h2>
<p>bbx_core provides flush utilities:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::{flush_denormal_f32, flush_denormal_f64};

let safe = flush_denormal_f32(maybe_denormal);
<span class="boring">}</span></code></pre>
<h2 id="when-they-occur"><a class="header" href="#when-they-occur">When They Occur</a></h2>
<ul>
<li>Filter feedback paths (decaying)</li>
<li>Reverb/delay tails</li>
<li>After gain reduction</li>
<li>Envelope release phase</li>
</ul>
<h2 id="usage-in-blocks-1"><a class="header" href="#usage-in-blocks-1">Usage in Blocks</a></h2>
<p>Apply in feedback paths:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_filter(&amp;mut self, input: f32) -&gt; f32 {
    let output = input + self.state * self.coefficient;
    self.state = flush_denormal_f32(output);
    output
}
<span class="boring">}</span></code></pre>
<h2 id="alternative-approaches"><a class="header" href="#alternative-approaches">Alternative Approaches</a></h2>
<h3 id="cpu-ftzdaz-mode"><a class="header" href="#cpu-ftzdaz-mode">CPU FTZ/DAZ Mode</a></h3>
<p>bbx_core provides the <code>ftz-daz</code> Cargo feature for hardware-level denormal prevention. When enabled, the <code>enable_ftz_daz()</code> function sets CPU flags to automatically flush denormals to zero.</p>
<p>Enable the feature in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
bbx_core = { version = "...", features = ["ftz-daz"] }

# Or for plugins (recommended):
bbx_plugin = { version = "...", features = ["ftz-daz"] }
</code></pre>
<p>Usage:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::denormal::enable_ftz_daz;

// Call once at the start of each audio thread
enable_ftz_daz();
<span class="boring">}</span></code></pre>
<p>When using <code>bbx_plugin</code> with the <code>ftz-daz</code> feature, this is called automatically during <code>prepare()</code>.</p>
<h4 id="platform-support-1"><a class="header" href="#platform-support-1">Platform Support</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td>x86/x86_64</td><td>Full FTZ + DAZ (inputs and outputs flushed)</td></tr>
<tr><td>AArch64 (ARM64/Apple Silicon)</td><td>FTZ only (outputs flushed)</td></tr>
<tr><td>Other</td><td>No-op (use software flushing)</td></tr>
</tbody>
</table>
</div>
<p><strong>Note:</strong> ARM processors lack a universal DAZ equivalent, so denormal inputs are handled normally. For portable code, use <code>flush_denormal_f32/f64</code> in filter feedback paths as defense-in-depth.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pros</th><th>Cons</th></tr>
</thead>
<tbody>
<tr><td>No per-sample overhead</td><td>Affects all code on the thread</td></tr>
<tr><td>Handles all float operations automatically</td><td>ARM: outputs only (no DAZ)</td></tr>
<tr><td>Recommended for production plugins</td><td></td></tr>
</tbody>
</table>
</div>
<h3 id="dc-offset"><a class="header" href="#dc-offset">DC Offset</a></h3>
<p>Add tiny DC offset to prevent zero crossing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const DC_OFFSET: f32 = 1e-25;
let output = (input + DC_OFFSET) * coefficient;
<span class="boring">}</span></code></pre>
<p>Pros: Simple, portable
Cons: Introduces actual DC offset</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lock-free-patterns"><a class="header" href="#lock-free-patterns">Lock-Free Patterns</a></h1>
<p>Concurrency patterns used in bbx_audio.</p>
<h2 id="why-lock-free"><a class="header" href="#why-lock-free">Why Lock-Free?</a></h2>
<p>Audio threads cannot wait for locks:</p>
<ul>
<li>Fixed time budget per buffer</li>
<li>Priority inversion risks</li>
<li>Unpredictable latency</li>
</ul>
<h2 id="spsc-ring-buffer-1"><a class="header" href="#spsc-ring-buffer-1">SPSC Ring Buffer</a></h2>
<p>For single-producer single-consumer scenarios:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bbx_core::SpscRingBuffer;

let (producer, consumer) = SpscRingBuffer::new::&lt;f32&gt;(1024);

// Producer thread
producer.try_push(sample);

// Consumer thread (audio)
if let Some(sample) = consumer.try_pop() {
    // Process
}
<span class="boring">}</span></code></pre>
<h3 id="memory-ordering-1"><a class="header" href="#memory-ordering-1">Memory Ordering</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simplified concept
impl SpscRingBuffer {
    fn try_push(&amp;self, item: T) -&gt; bool {
        let head = self.head.load(Ordering::Relaxed);
        let tail = self.tail.load(Ordering::Acquire);  // Sync with consumer

        if is_full(head, tail) {
            return false;
        }

        self.buffer[head] = item;
        self.head.store(next(head), Ordering::Release);  // Sync with consumer
        true
    }
}
<span class="boring">}</span></code></pre>
<h2 id="atomic-parameters"><a class="header" href="#atomic-parameters">Atomic Parameters</a></h2>
<p>For real-time parameter updates:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicU32, Ordering};

struct Parameter {
    value: AtomicU32,
}

impl Parameter {
    fn set(&amp;self, value: f32) {
        self.value.store(value.to_bits(), Ordering::Relaxed);
    }

    fn get(&amp;self) -&gt; f32 {
        f32::from_bits(self.value.load(Ordering::Relaxed))
    }
}
<span class="boring">}</span></code></pre>
<h2 id="when-locks-are-ok"><a class="header" href="#when-locks-are-ok">When Locks Are OK</a></h2>
<p>Not all code is audio-critical:</p>
<ul>
<li><strong>Setup/teardown</strong>: Can use locks</li>
<li><strong>UI thread</strong>: Not time-critical</li>
<li><strong>File I/O</strong>: Background threads</li>
</ul>
<p>Only the audio processing path must be lock-free.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="modulation-system"><a class="header" href="#modulation-system">Modulation System</a></h1>
<p>How parameters are modulated in bbx_audio.</p>
<h2 id="overview-28"><a class="header" href="#overview-28">Overview</a></h2>
<p>Modulation allows parameters to change over time:</p>
<ul>
<li>LFO modulating pitch → vibrato</li>
<li>Envelope modulating amplitude → ADSR</li>
<li>LFO modulating filter cutoff → wah effect</li>
</ul>
<h2 id="control-rate-vs-audio-rate"><a class="header" href="#control-rate-vs-audio-rate">Control Rate vs Audio Rate</a></h2>
<p>bbx_audio uses <strong>control rate</strong> modulation:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Audio Rate</th><th>Control Rate</th></tr>
</thead>
<tbody>
<tr><td>Updates</td><td>Per sample</td><td>Per buffer</td></tr>
<tr><td>CPU cost</td><td>High</td><td>Low</td></tr>
<tr><td>Latency</td><td>None</td><td>1 buffer</td></tr>
<tr><td>Precision</td><td>Perfect</td><td>Good enough</td></tr>
</tbody>
</table>
</div>
<p>Most musical modulation is below 20 Hz, well within control rate capabilities.</p>
<h2 id="modulation-flow-1"><a class="header" href="#modulation-flow-1">Modulation Flow</a></h2>
<ol>
<li><strong>Modulator block processes</strong> (LFO, Envelope)</li>
<li><strong>First sample collected</strong> as modulation value</li>
<li><strong>Target block receives</strong> value in modulation array</li>
<li><strong>Block applies</strong> value to parameters</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn collect_modulation_values(&amp;mut self, block_id: BlockId) {
    if has_modulation_outputs(block_id) {
        let buffer_index = self.get_buffer_index(block_id, 0);
        let first_sample = self.audio_buffers[buffer_index][0];
        self.modulation_values[block_id.0] = first_sample;
    }
}
<span class="boring">}</span></code></pre>
<h2 id="parameter-type-1"><a class="header" href="#parameter-type-1">Parameter Type</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Parameter&lt;S: Sample&gt; {
    Static(S),              // Fixed value
    Modulated(BlockId),     // Controlled by modulator
}
<span class="boring">}</span></code></pre>
<h2 id="routing-modulation"><a class="header" href="#routing-modulation">Routing Modulation</a></h2>
<p>Specify during graph construction:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lfo = builder.add_lfo(5.0, Waveform::Sine);
let osc = builder.add_oscillator(440.0, Waveform::Sine, Some(lfo));
<span class="boring">}</span></code></pre>
<p>Or explicitly:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>builder.modulate(lfo, osc, "frequency");
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="parameters-type"><a class="header" href="#parameters-type">Parameter&lt;S&gt; Type</a></h1>
<p>The generic parameter type for static and modulated values.</p>
<h2 id="definition-2"><a class="header" href="#definition-2">Definition</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Parameter&lt;S: Sample&gt; {
    /// Fixed value
    Static(S),

    /// Value controlled by a modulator block
    Modulated(BlockId),
}
<span class="boring">}</span></code></pre>
<h2 id="usage-in-blocks-2"><a class="header" href="#usage-in-blocks-2">Usage in Blocks</a></h2>
<p>Blocks store parameters as <code>Parameter&lt;S&gt;</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OscillatorBlock&lt;S: Sample&gt; {
    frequency: Parameter&lt;S&gt;,
    waveform: Waveform,
    phase: S,
}
<span class="boring">}</span></code></pre>
<h2 id="resolving-values"><a class="header" href="#resolving-values">Resolving Values</a></h2>
<p>During processing, resolve the actual value:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;S: Sample&gt; OscillatorBlock&lt;S&gt; {
    fn get_frequency(&amp;self, modulation: &amp;[S]) -&gt; S {
        match &amp;self.frequency {
            Parameter::Static(value) =&gt; *value,
            Parameter::Modulated(block_id) =&gt; {
                let base = S::from_f64(440.0);
                let mod_value = modulation[block_id.0];
                base * (S::ONE + mod_value * S::from_f64(0.1))  // ±10%
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="static-vs-modulated"><a class="header" href="#static-vs-modulated">Static vs Modulated</a></h2>
<h3 id="static"><a class="header" href="#static">Static</a></h3>
<ul>
<li>Value known at creation</li>
<li>No per-block overhead</li>
<li>Simple and direct</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let gain = Parameter::Static(S::from_f64(-6.0));
<span class="boring">}</span></code></pre>
<h3 id="modulated"><a class="header" href="#modulated">Modulated</a></h3>
<ul>
<li>Value changes each buffer</li>
<li>Requires modulator block</li>
<li>Adds routing complexity</li>
</ul>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let frequency = Parameter::Modulated(lfo_block_id);
<span class="boring">}</span></code></pre>
<h2 id="design-rationale"><a class="header" href="#design-rationale">Design Rationale</a></h2>
<p>The <code>Parameter</code> enum:</p>
<ol>
<li><strong>Unifies static and dynamic</strong> - Same API for both</li>
<li><strong>Type-safe modulation</strong> - Compile-time block ID checking</li>
<li><strong>Zero-cost static</strong> - No indirection for static values</li>
<li><strong>Sample-type generic</strong> - Works with f32 and f64</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="modulation-value-collection-1"><a class="header" href="#modulation-value-collection-1">Modulation Value Collection</a></h1>
<p>How modulation values are collected and distributed.</p>
<h2 id="collection-process"><a class="header" href="#collection-process">Collection Process</a></h2>
<p>After each modulator block processes:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn collect_modulation_values(&amp;mut self, block_id: BlockId) {
    // Skip if block has no modulation outputs
    if self.blocks[block_id.0].modulation_outputs().is_empty() {
        return;
    }

    // Get the first sample as the modulation value
    let buffer_index = self.get_buffer_index(block_id, 0);
    if let Some(&amp;first_sample) = self.audio_buffers[buffer_index].get(0) {
        self.modulation_values[block_id.0] = first_sample;
    }
}
<span class="boring">}</span></code></pre>
<h2 id="why-first-sample"><a class="header" href="#why-first-sample">Why First Sample?</a></h2>
<p>Modulation is control-rate (per-buffer), not audio-rate (per-sample):</p>
<ul>
<li>LFO at 5 Hz with 512-sample buffer at 44.1 kHz</li>
<li>Buffer duration: 512 / 44100 ≈ 11.6 ms</li>
<li>LFO phase change: 5 * 0.0116 ≈ 0.058 cycles</li>
<li>Taking first sample is sufficient</li>
</ul>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<p>Pre-allocated array indexed by block ID:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In Graph
modulation_values: Vec&lt;S&gt;,

// Sized during prepare_for_playback
self.modulation_values.resize(self.blocks.len(), S::ZERO);
<span class="boring">}</span></code></pre>
<h2 id="passing-to-blocks"><a class="header" href="#passing-to-blocks">Passing to Blocks</a></h2>
<p>Blocks receive the full modulation array:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>block.process(
    input_slices.as_slice(),
    output_slices.as_mut_slice(),
    &amp;self.modulation_values,  // All values
    &amp;self.context,
);
<span class="boring">}</span></code></pre>
<p>Blocks index by their modulator’s BlockId:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process(&amp;mut self, ..., modulation: &amp;[S], ...) {
    let mod_value = modulation[self.modulator_id.0];
    // Apply modulation
}
<span class="boring">}</span></code></pre>
<h2 id="timing-considerations"><a class="header" href="#timing-considerations">Timing Considerations</a></h2>
<p>Modulation is applied with 1-buffer latency:</p>
<ol>
<li>Buffer N: LFO generates sample</li>
<li>Buffer N: Value collected</li>
<li>Buffer N: Target block uses value</li>
</ol>
<p>This is acceptable for musical modulation (typically &lt; 20 Hz).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ffi-design"><a class="header" href="#ffi-design">FFI Design</a></h1>
<p>The design of bbx_audio’s C FFI layer.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<ol>
<li><strong>Safety</strong> - Prevent memory errors across language boundary</li>
<li><strong>Simplicity</strong> - Minimal API surface</li>
<li><strong>Performance</strong> - Zero-copy audio processing</li>
<li><strong>Portability</strong> - Works with any C-compatible language</li>
</ol>
<h2 id="opaque-handle-pattern"><a class="header" href="#opaque-handle-pattern">Opaque Handle Pattern</a></h2>
<p>Rust types are hidden behind opaque pointers:</p>
<pre><code class="language-c">typedef struct BbxGraph BbxGraph;  // Opaque - never dereference
</code></pre>
<p>C++ only sees the handle, never the Rust struct:</p>
<pre><code class="language-cpp">BbxGraph* handle = bbx_graph_create();
// handle is a type-erased pointer
</code></pre>
<h2 id="handle-lifecycle"><a class="header" href="#handle-lifecycle">Handle Lifecycle</a></h2>
<h3 id="creation"><a class="header" href="#creation">Creation</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn bbx_graph_create() -&gt; *mut BbxGraph {
    let inner = Box::new(GraphInner::new());
    Box::into_raw(inner) as *mut BbxGraph
}
<span class="boring">}</span></code></pre>
<h3 id="destruction"><a class="header" href="#destruction">Destruction</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn bbx_graph_destroy(handle: *mut BbxGraph) {
    if !handle.is_null() {
        unsafe {
            drop(Box::from_raw(handle as *mut GraphInner));
        }
    }
}
<span class="boring">}</span></code></pre>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<p>Return codes instead of exceptions:</p>
<pre><code class="language-c">typedef enum BbxError {
    BBX_ERROR_OK = 0,
    BBX_ERROR_NULL_POINTER = 1,
    BBX_ERROR_INVALID_PARAMETER = 2,
    // ...
} BbxError;
</code></pre>
<p>Check in C++:</p>
<pre><code class="language-cpp">BbxError err = bbx_graph_prepare(handle, ...);
if (err != BBX_ERROR_OK) {
    // Handle error
}
</code></pre>
<h2 id="zero-copy-processing"><a class="header" href="#zero-copy-processing">Zero-Copy Processing</a></h2>
<p>Audio buffers are passed by pointer:</p>
<pre><code class="language-c">void bbx_graph_process(
    BbxGraph* handle,
    const float* const* inputs,   // Pointer to pointer
    float* const* outputs,
    ...
);
</code></pre>
<p>Rust converts to slices without copying:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    let input_slice = std::slice::from_raw_parts(inputs[ch], num_samples);
    let output_slice = std::slice::from_raw_parts_mut(outputs[ch], num_samples);
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="handle-management"><a class="header" href="#handle-management">Handle Management</a></h1>
<p>How Rust objects are managed across the FFI boundary.</p>
<h2 id="the-box-pattern"><a class="header" href="#the-box-pattern">The Box Pattern</a></h2>
<p>Rust objects are boxed and converted to raw pointers:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create: Rust -&gt; C
let inner = Box::new(GraphInner::new());
let ptr = Box::into_raw(inner);
return ptr as *mut BbxGraph;

// Destroy: C -&gt; Rust
let inner = Box::from_raw(ptr as *mut GraphInner);
drop(inner);  // Automatically called when Box goes out of scope
<span class="boring">}</span></code></pre>
<h2 id="type-erasure"><a class="header" href="#type-erasure">Type Erasure</a></h2>
<p>The C type is opaque:</p>
<pre><code class="language-c">typedef struct BbxGraph BbxGraph;
</code></pre>
<p>Rust knows the actual type:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type PluginGraphInner = GraphInner&lt;PluginGraph&gt;;
<span class="boring">}</span></code></pre>
<p>Conversion is safe because:</p>
<ol>
<li>We control both sides</li>
<li>Types match at compile time via generics</li>
<li>Handle is never dereferenced in C</li>
</ol>
<h2 id="null-safety"><a class="header" href="#null-safety">Null Safety</a></h2>
<p>All functions check for null:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub extern "C" fn bbx_graph_prepare(handle: *mut BbxGraph, ...) -&gt; BbxError {
    if handle.is_null() {
        return BbxError::NullPointer;
    }
    // ...
}
<span class="boring">}</span></code></pre>
<h2 id="ownership-transfer"><a class="header" href="#ownership-transfer">Ownership Transfer</a></h2>
<pre><code>create():  Rust owns -&gt; Box::into_raw -&gt; C owns handle
use():     C passes handle -&gt; Rust borrows -&gt; returns to C
destroy(): C passes handle -&gt; Rust reclaims -&gt; deallocates
</code></pre>
<h3 id="create"><a class="header" href="#create">Create</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Box::into_raw(inner)  // Rust gives up ownership
<span class="boring">}</span></code></pre>
<h3 id="use"><a class="header" href="#use">Use</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let inner = &amp;mut *(handle as *mut GraphInner);  // Borrow, don't take ownership
<span class="boring">}</span></code></pre>
<h3 id="destroy"><a class="header" href="#destroy">Destroy</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Box::from_raw(handle)  // Rust reclaims ownership
// Box dropped, memory freed
<span class="boring">}</span></code></pre>
<h2 id="raii-in-c"><a class="header" href="#raii-in-c">RAII in C++</a></h2>
<p>The C++ wrapper manages the handle:</p>
<pre><code class="language-cpp">class Graph {
public:
    Graph() : m_handle(bbx_graph_create()) {}
    ~Graph() { if (m_handle) bbx_graph_destroy(m_handle); }

private:
    BbxGraph* m_handle;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="memory-safety-across-boundaries"><a class="header" href="#memory-safety-across-boundaries">Memory Safety Across Boundaries</a></h1>
<p>Ensuring memory safety in the FFI layer.</p>
<h2 id="safety-invariants"><a class="header" href="#safety-invariants">Safety Invariants</a></h2>
<h3 id="1-valid-handles"><a class="header" href="#1-valid-handles">1. Valid Handles</a></h3>
<p>Handles are valid from <code>create()</code> to <code>destroy()</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub extern "C" fn bbx_graph_process(handle: *mut BbxGraph, ...) {
    if handle.is_null() {
        return;  // Silent no-op for safety
    }
    // Handle is valid
}
<span class="boring">}</span></code></pre>
<h3 id="2-non-overlapping-buffers"><a class="header" href="#2-non-overlapping-buffers">2. Non-Overlapping Buffers</a></h3>
<p>Input and output buffers never overlap:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SAFETY: Our buffer indexing guarantees:
// 1. Input indices come from other blocks' outputs
// 2. Output indices are unique to this block
// 3. Therefore, input and output NEVER overlap
unsafe {
    let input_slices = /* from input buffers */;
    let output_slices = /* from output buffers */;
    block.process(input_slices, output_slices, ...);
}
<span class="boring">}</span></code></pre>
<h3 id="3-valid-pointer-lengths"><a class="header" href="#3-valid-pointer-lengths">3. Valid Pointer Lengths</a></h3>
<p>Buffer lengths match the provided count:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    let slice = std::slice::from_raw_parts(
        inputs[ch],
        num_samples as usize,  // Must be accurate!
    );
}
<span class="boring">}</span></code></pre>
<h2 id="unsafe-blocks"><a class="header" href="#unsafe-blocks">Unsafe Blocks</a></h2>
<p>All unsafe code is documented:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SAFETY: [explanation of why this is safe]
unsafe {
    // unsafe operation
}
<span class="boring">}</span></code></pre>
<h2 id="c-responsibilities"><a class="header" href="#c-responsibilities">C++ Responsibilities</a></h2>
<p>The C++ side must:</p>
<ol>
<li><strong>Never use handle after destroy</strong></li>
<li><strong>Provide valid buffer pointers</strong></li>
<li><strong>Match buffer sizes to declared counts</strong></li>
<li><strong>Not call from multiple threads simultaneously</strong></li>
</ol>
<h2 id="defense-in-depth"><a class="header" href="#defense-in-depth">Defense in Depth</a></h2>
<p>Multiple layers of protection:</p>
<ol>
<li><strong>Null checks</strong> - Explicit handle validation</li>
<li><strong>Bounds checks</strong> - Array access validation</li>
<li><strong>Type system</strong> - Compile-time generic checking</li>
<li><strong>Debug asserts</strong> - Development-time validation</li>
</ol>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>debug_assert!(
    output_count &lt;= MAX_BLOCK_OUTPUTS,
    "Block output count exceeds limit"
);
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h1>
<p>Optimizing DSP performance in bbx_audio.</p>
<h2 id="key-metrics"><a class="header" href="#key-metrics">Key Metrics</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Metric</th><th>Target</th></tr>
</thead>
<tbody>
<tr><td>Latency</td><td>&lt; 1 buffer</td></tr>
<tr><td>CPU usage</td><td>&lt; 50% of budget</td></tr>
<tr><td>Memory</td><td>Predictable, fixed</td></tr>
<tr><td>Allocation</td><td>Zero during process</td></tr>
</tbody>
</table>
</div>
<h2 id="optimization-strategies"><a class="header" href="#optimization-strategies">Optimization Strategies</a></h2>
<h3 id="pre-computation"><a class="header" href="#pre-computation">Pre-computation</a></h3>
<p>Calculate once, use many times:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In prepare()
self.coefficient = calculate_filter_coeff(self.cutoff, context.sample_rate);

// In process() - just use it
output = input * self.coefficient + self.state;
<span class="boring">}</span></code></pre>
<h3 id="cache-efficiency-2"><a class="header" href="#cache-efficiency-2">Cache Efficiency</a></h3>
<p>Keep hot data together:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Contiguous buffer storage
audio_buffers: Vec&lt;AudioBuffer&lt;S&gt;&gt;

// Good: Sequential processing
for block_id in &amp;self.execution_order {
    self.process_block(*block_id);
}
<span class="boring">}</span></code></pre>
<h3 id="branch-avoidance"><a class="header" href="#branch-avoidance">Branch Avoidance</a></h3>
<p>Prefer branchless code:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Avoid
if condition {
    result = a;
} else {
    result = b;
}

// Prefer
let mask = condition as f32;  // 0.0 or 1.0
result = a * mask + b * (1.0 - mask);
<span class="boring">}</span></code></pre>
<h3 id="simd-potential-1"><a class="header" href="#simd-potential-1">SIMD Potential</a></h3>
<p>Design for SIMD:</p>
<ul>
<li>Process 4+ samples at once</li>
<li>Align buffers to 16/32 bytes</li>
<li>Avoid data-dependent branches</li>
</ul>
<h2 id="profiling"><a class="header" href="#profiling">Profiling</a></h2>
<p>Measure before optimizing:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = "profiling")]
let _span = tracing::span!(tracing::Level::TRACE, "process_block");
<span class="boring">}</span></code></pre>
<h2 id="common-bottlenecks"><a class="header" href="#common-bottlenecks">Common Bottlenecks</a></h2>
<ol>
<li><strong>Memory allocation</strong> in audio thread</li>
<li><strong>Cache misses</strong> from scattered data</li>
<li><strong>Branch misprediction</strong> in complex logic</li>
<li><strong>Function call overhead</strong> for tiny operations</li>
<li><strong>Denormal processing</strong> in filter feedback</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="zero-allocation-processing"><a class="header" href="#zero-allocation-processing">Zero-Allocation Processing</a></h1>
<p>How bbx_audio achieves zero allocations during audio processing.</p>
<h2 id="strategy"><a class="header" href="#strategy">Strategy</a></h2>
<p>All memory allocated upfront:</p>
<ol>
<li><strong>Blocks added</strong> → buffers allocated</li>
<li><strong>Graph prepared</strong> → connection lookups built</li>
<li><strong>Processing</strong> → only use pre-allocated memory</li>
</ol>
<h2 id="pre-allocated-resources"><a class="header" href="#pre-allocated-resources">Pre-Allocated Resources</a></h2>
<h3 id="audio-buffers"><a class="header" href="#audio-buffers">Audio Buffers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Allocated when block is added
for _ in 0..output_count {
    self.audio_buffers.push(AudioBuffer::new(self.buffer_size));
}

// During processing - just clear
buffer.zeroize();
<span class="boring">}</span></code></pre>
<h3 id="modulation-values-1"><a class="header" href="#modulation-values-1">Modulation Values</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Allocated during prepare
self.modulation_values.resize(self.blocks.len(), S::ZERO);

// During processing - just write
self.modulation_values[block_id.0] = value;
<span class="boring">}</span></code></pre>
<h3 id="connection-lookups"><a class="header" href="#connection-lookups">Connection Lookups</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Computed during prepare
self.block_input_buffers = vec![Vec::new(); self.blocks.len()];
for conn in &amp;self.connections {
    self.block_input_buffers[conn.to.0].push(buffer_idx);
}

// During processing - O(1) read
let inputs = &amp;self.block_input_buffers[block_id.0];
<span class="boring">}</span></code></pre>
<h2 id="stack-allocation-1"><a class="header" href="#stack-allocation-1">Stack Allocation</a></h2>
<p>Temporary collections use stack memory:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_BLOCK_INPUTS: usize = 8;

// No heap allocation
let mut input_slices: StackVec&lt;&amp;[S], MAX_BLOCK_INPUTS&gt; = StackVec::new();
<span class="boring">}</span></code></pre>
<h2 id="verification-1"><a class="header" href="#verification-1">Verification</a></h2>
<p>Check with a global allocator hook:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
#[global_allocator]
static ALLOC: dhat::Alloc = dhat::Alloc;

#[test]
fn test_no_allocations_during_process() {
    // Setup...
    let before = dhat::total_allocations();
    graph.process_buffers(&amp;mut outputs);
    let after = dhat::total_allocations();
    assert_eq!(before, after, "Allocations during process!");
}
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cache-efficiency-3"><a class="header" href="#cache-efficiency-3">Cache Efficiency</a></h1>
<p>Optimizing for CPU cache performance.</p>
<h2 id="cache-hierarchy"><a class="header" href="#cache-hierarchy">Cache Hierarchy</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Level</th><th>Size</th><th>Latency</th></tr>
</thead>
<tbody>
<tr><td>L1</td><td>32-64 KB</td><td>~4 cycles</td></tr>
<tr><td>L2</td><td>256-512 KB</td><td>~12 cycles</td></tr>
<tr><td>L3</td><td>4-32 MB</td><td>~40 cycles</td></tr>
<tr><td>RAM</td><td>GBs</td><td>~200+ cycles</td></tr>
</tbody>
</table>
</div>
<h2 id="strategies"><a class="header" href="#strategies">Strategies</a></h2>
<h3 id="contiguous-storage"><a class="header" href="#contiguous-storage">Contiguous Storage</a></h3>
<p>Keep related data together:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Single contiguous allocation
audio_buffers: Vec&lt;AudioBuffer&lt;S&gt;&gt;

// Each buffer is contiguous
samples: [S; BUFFER_SIZE]
<span class="boring">}</span></code></pre>
<h3 id="sequential-access"><a class="header" href="#sequential-access">Sequential Access</a></h3>
<p>Process in order:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Sequential iteration
for sample in buffer.iter_mut() {
    *sample = process(*sample);
}

// Avoid: Random access
for i in random_order {
    buffer[i] = process(buffer[i]);
}
<span class="boring">}</span></code></pre>
<h3 id="hotcold-separation"><a class="header" href="#hotcold-separation">Hot/Cold Separation</a></h3>
<p>Separate frequently from rarely used data:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Block&lt;S&gt; {
    // Hot path (processing)
    state: S,
    coefficient: S,

    // Cold path (setup)
    name: String,  // Rarely accessed
}
<span class="boring">}</span></code></pre>
<h3 id="avoid-pointer-chasing"><a class="header" href="#avoid-pointer-chasing">Avoid Pointer Chasing</a></h3>
<p>Minimize indirection:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Less ideal: Vec of trait objects
blocks: Vec&lt;Box&lt;dyn Block&gt;&gt;

// Better: Enum of concrete types
blocks: Vec&lt;BlockType&lt;S&gt;&gt;
<span class="boring">}</span></code></pre>
<h2 id="buffer-layout-1"><a class="header" href="#buffer-layout-1">Buffer Layout</a></h2>
<p>Interleaved vs non-interleaved:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Non-interleaved (better for processing)
left:  [L0, L1, L2, L3, ...]
right: [R0, R1, R2, R3, ...]

// Interleaved (worse for SIMD)
data: [L0, R0, L1, R1, L2, R2, ...]
<span class="boring">}</span></code></pre>
<p>bbx_audio uses non-interleaved buffers.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="simd-opportunities"><a class="header" href="#simd-opportunities">SIMD Opportunities</a></h1>
<p>Single Instruction Multiple Data optimization potential.</p>
<h2 id="what-is-simd"><a class="header" href="#what-is-simd">What is SIMD?</a></h2>
<p>Process multiple samples simultaneously:</p>
<pre><code>Scalar: a[0]*b[0], a[1]*b[1], a[2]*b[2], a[3]*b[3]  (4 ops)
SIMD:   a[0:3] * b[0:3]                              (1 op)
</code></pre>
<h2 id="current-state"><a class="header" href="#current-state">Current State</a></h2>
<p>bbx_audio currently uses scalar processing. SIMD optimizations are future work.</p>
<h2 id="optimization-targets"><a class="header" href="#optimization-targets">Optimization Targets</a></h2>
<h3 id="sample-processing"><a class="header" href="#sample-processing">Sample Processing</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Current (scalar)
for sample in buffer {
    *sample *= gain;
}

// SIMD potential
use std::simd::f32x4;
for chunk in buffer.chunks_exact_mut(4) {
    let v = f32x4::from_slice(chunk);
    let result = v * gain_vec;
    result.copy_to_slice(chunk);
}
<span class="boring">}</span></code></pre>
<h3 id="filter-processing"><a class="header" href="#filter-processing">Filter Processing</a></h3>
<p>IIR filters can use SIMD for parallel samples:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Process 4 independent samples simultaneously
// Requires restructuring state variables
<span class="boring">}</span></code></pre>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<h3 id="data-alignment"><a class="header" href="#data-alignment">Data Alignment</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(align(32))]
struct AlignedBuffer {
    data: [f32; 1024],
}
<span class="boring">}</span></code></pre>
<h3 id="buffer-size"><a class="header" href="#buffer-size">Buffer Size</a></h3>
<p>Buffer size should be multiple of SIMD width:</p>
<pre><code>SSE:  4 floats (128-bit)
AVX:  8 floats (256-bit)
AVX-512: 16 floats (512-bit)
</code></pre>
<h3 id="portable-simd"><a class="header" href="#portable-simd">Portable SIMD</a></h3>
<p>Use Rust’s portable SIMD (nightly):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(portable_simd)]
<span class="boring">fn main() {
</span>use std::simd::f32x4;
<span class="boring">}</span></code></pre>
<p>Or crates like <code>wide</code> for stable Rust.</p>
<h2 id="trade-offs-1"><a class="header" href="#trade-offs-1">Trade-offs</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Scalar</th><th>SIMD</th></tr>
</thead>
<tbody>
<tr><td>Complexity</td><td>Simple</td><td>Complex</td></tr>
<tr><td>Portability</td><td>Universal</td><td>Platform-specific</td></tr>
<tr><td>Debugging</td><td>Easy</td><td>Harder</td></tr>
<tr><td>Performance</td><td>Baseline</td><td>2-8x faster</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h1>
<p>Set up your environment for contributing to bbx_audio.</p>
<h2 id="prerequisites-5"><a class="header" href="#prerequisites-5">Prerequisites</a></h2>
<h3 id="rust-toolchain-1"><a class="header" href="#rust-toolchain-1">Rust Toolchain</a></h3>
<pre><code class="language-bash"># Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Add nightly toolchain (required for fmt and clippy)
rustup toolchain install nightly
</code></pre>
<h3 id="platform-dependencies-1"><a class="header" href="#platform-dependencies-1">Platform Dependencies</a></h3>
<p><strong>Linux:</strong></p>
<pre><code class="language-bash">sudo apt install alsa libasound2-dev libssl-dev pkg-config
</code></pre>
<p><strong>macOS/Windows:</strong> No additional dependencies.</p>
<h2 id="clone-and-build-1"><a class="header" href="#clone-and-build-1">Clone and Build</a></h2>
<pre><code class="language-bash"># Clone repository
git clone https://github.com/blackboxaudio/bbx_audio.git
cd bbx_audio

# Build all crates
cargo build --workspace

# Run tests
cargo test --workspace --release
</code></pre>
<h2 id="ide-setup"><a class="header" href="#ide-setup">IDE Setup</a></h2>
<h3 id="vs-code"><a class="header" href="#vs-code">VS Code</a></h3>
<p>Recommended extensions:</p>
<ul>
<li>rust-analyzer</li>
<li>Even Better TOML</li>
<li>CodeLLDB (debugging)</li>
</ul>
<p>Settings (<code>.vscode/settings.json</code>):</p>
<pre><code class="language-json">{
    "rust-analyzer.cargo.features": "all",
    "rust-analyzer.check.command": "clippy"
}
</code></pre>
<h3 id="other-ides"><a class="header" href="#other-ides">Other IDEs</a></h3>
<ul>
<li><strong>IntelliJ IDEA</strong> - Use Rust plugin</li>
<li><strong>Vim/Neovim</strong> - Use rust-analyzer LSP</li>
<li><strong>Emacs</strong> - Use rustic-mode</li>
</ul>
<h2 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h2>
<pre><code class="language-bash"># Format code
cargo +nightly fmt

# Run lints
cargo +nightly clippy

# Run tests
cargo test --workspace --release

# Run an example
cargo run --release --example 01_sine_wave -p bbx_sandbox
</code></pre>
<h2 id="common-tasks"><a class="header" href="#common-tasks">Common Tasks</a></h2>
<h3 id="adding-a-new-block"><a class="header" href="#adding-a-new-block">Adding a New Block</a></h3>
<ol>
<li>Create block in appropriate <code>blocks/</code> subdirectory</li>
<li>Add to <code>BlockType</code> enum</li>
<li>Add builder method to <code>GraphBuilder</code></li>
<li>Write tests</li>
<li>Update documentation</li>
</ol>
<h3 id="modifying-ffi"><a class="header" href="#modifying-ffi">Modifying FFI</a></h3>
<ol>
<li>Update Rust code in <code>bbx_plugin</code></li>
<li>Regenerate header with cbindgen</li>
<li>Update <code>bbx_graph.h</code> if needed</li>
<li>Test with JUCE project</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="code-style"><a class="header" href="#code-style">Code Style</a></h1>
<p>Coding conventions for bbx_audio.</p>
<h2 id="formatting-1"><a class="header" href="#formatting-1">Formatting</a></h2>
<p>Use nightly rustfmt:</p>
<pre><code class="language-bash">cargo +nightly fmt
</code></pre>
<p>Configuration is in <code>rustfmt.toml</code>.</p>
<h2 id="linting-1"><a class="header" href="#linting-1">Linting</a></h2>
<p>Use nightly clippy:</p>
<pre><code class="language-bash">cargo +nightly clippy
</code></pre>
<p>Fix all warnings before submitting.</p>
<h2 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h2>
<h3 id="types-1"><a class="header" href="#types-1">Types</a></h3>
<ul>
<li><strong>Structs</strong>: PascalCase (<code>OscillatorBlock</code>)</li>
<li><strong>Enums</strong>: PascalCase (<code>Waveform</code>)</li>
<li><strong>Traits</strong>: PascalCase (<code>Block</code>, <code>Sample</code>)</li>
</ul>
<h3 id="functions-and-methods"><a class="header" href="#functions-and-methods">Functions and Methods</a></h3>
<ul>
<li><strong>Functions</strong>: snake_case (<code>process_buffers</code>)</li>
<li><strong>Methods</strong>: snake_case (<code>add_oscillator</code>)</li>
<li><strong>Constructors</strong>: <code>new()</code> or <code>from_*()</code> / <code>with_*()</code></li>
</ul>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<ul>
<li><strong>Local</strong>: snake_case (<code>buffer_size</code>)</li>
<li><strong>Constants</strong>: SCREAMING_SNAKE_CASE (<code>MAX_BLOCK_INPUTS</code>)</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<h3 id="public-items"><a class="header" href="#public-items">Public Items</a></h3>
<p>All public items must have documentation:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A block that generates waveforms.
///
/// # Example
///
/// ```
/// let osc = OscillatorBlock::new(440.0, Waveform::Sine);
/// ```
pub struct OscillatorBlock&lt;S: Sample&gt; {
    // ...
}
<span class="boring">}</span></code></pre>
<h3 id="module-documentation"><a class="header" href="#module-documentation">Module Documentation</a></h3>
<p>Each module should have a top-level doc comment:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! DSP graph system.
//!
//! This module provides [`Graph`] for managing connected DSP blocks.
<span class="boring">}</span></code></pre>
<h2 id="safety-comments"><a class="header" href="#safety-comments">Safety Comments</a></h2>
<p>All unsafe blocks must have a <code>SAFETY:</code> comment:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SAFETY: The buffer indices are pre-computed and validated
// during prepare_for_playback(), guaranteeing valid access.
unsafe {
    let slice = std::slice::from_raw_parts(ptr, len);
}
<span class="boring">}</span></code></pre>
<h2 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h2>
<ul>
<li>Use <code>Result&lt;T, BbxError&gt;</code> for fallible operations</li>
<li>Use <code>Option&lt;T&gt;</code> for optional values</li>
<li>Avoid <code>unwrap()</code> in library code</li>
<li>Use <code>expect()</code> with clear messages for invariants</li>
</ul>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<ul>
<li>Unit tests in <code>#[cfg(test)]</code> modules</li>
<li>Integration tests in <code>tests/</code> directory</li>
<li>Document test coverage for new features</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="adding-new-blocks"><a class="header" href="#adding-new-blocks">Adding New Blocks</a></h1>
<p>Guide to implementing new DSP blocks.</p>
<h2 id="block-structure"><a class="header" href="#block-structure">Block Structure</a></h2>
<p>Create a new file in the appropriate category:</p>
<pre><code>bbx_dsp/src/blocks/
├── generators/
│   └── my_generator.rs
├── effectors/
│   └── my_effect.rs
└── modulators/
    └── my_modulator.rs
</code></pre>
<h2 id="implement-the-block-trait"><a class="header" href="#implement-the-block-trait">Implement the Block Trait</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::{block::Block, context::DspContext, sample::Sample};

pub struct MyEffectBlock&lt;S: Sample&gt; {
    // Block state
    gain: S,
    state: S,
}

impl&lt;S: Sample&gt; MyEffectBlock&lt;S&gt; {
    pub fn new(gain: f64) -&gt; Self {
        Self {
            gain: S::from_f64(gain),
            state: S::ZERO,
        }
    }
}

impl&lt;S: Sample&gt; Block&lt;S&gt; for MyEffectBlock&lt;S&gt; {
    fn process(
        &amp;mut self,
        inputs: &amp;[&amp;[S]],
        outputs: &amp;mut [&amp;mut [S]],
        context: &amp;DspContext,
        _modulation: &amp;[S],
    ) {
        for ch in 0..inputs.len().min(outputs.len()) {
            for i in 0..context.buffer_size {
                outputs[ch][i] = inputs[ch][i] * self.gain;
            }
        }
    }

    fn num_inputs(&amp;self) -&gt; usize { 1 }
    fn num_outputs(&amp;self) -&gt; usize { 1 }

    fn prepare(&amp;mut self, _context: &amp;DspContext) {
        // Recalculate coefficients if needed
    }

    fn reset(&amp;mut self) {
        self.state = S::ZERO;
    }
}
<span class="boring">}</span></code></pre>
<h2 id="add-to-blocktype"><a class="header" href="#add-to-blocktype">Add to BlockType</a></h2>
<p>In <code>bbx_dsp/src/block.rs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum BlockType&lt;S: Sample&gt; {
    // Existing variants...
    MyEffect(MyEffectBlock&lt;S&gt;),
}
<span class="boring">}</span></code></pre>
<p>Update all match arms in <code>BlockType</code>’s <code>Block</code> implementation.</p>
<h2 id="add-builder-method"><a class="header" href="#add-builder-method">Add Builder Method</a></h2>
<p>In <code>bbx_dsp/src/graph.rs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;S: Sample&gt; GraphBuilder&lt;S&gt; {
    /// Add a MyEffectBlock to the graph.
    pub fn add_my_effect(&amp;mut self, gain: f64) -&gt; BlockId {
        let block = BlockType::MyEffect(MyEffectBlock::new(gain));
        self.graph.add_block(block)
    }
}
<span class="boring">}</span></code></pre>
<h2 id="write-tests"><a class="header" href="#write-tests">Write Tests</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_my_effect_basic() {
        let mut block = MyEffectBlock::&lt;f32&gt;::new(0.5);
        let context = DspContext::new(44100.0, 4, 1);

        let input = [1.0, 0.5, 0.25, 0.0];
        let mut output = [0.0; 4];

        block.process(&amp;[&amp;input], &amp;mut [&amp;mut output], &amp;context, &amp;[]);

        assert_eq!(output, [0.5, 0.25, 0.125, 0.0]);
    }
}
<span class="boring">}</span></code></pre>
<h2 id="update-documentation"><a class="header" href="#update-documentation">Update Documentation</a></h2>
<ol>
<li>Add to blocks reference in docs</li>
<li>Update README if significant</li>
<li>Add examples in bbx_sandbox</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing-1"><a class="header" href="#testing-1">Testing</a></h1>
<p>Testing strategies for bbx_audio.</p>
<h2 id="running-tests-1"><a class="header" href="#running-tests-1">Running Tests</a></h2>
<pre><code class="language-bash"># All tests
cargo test --workspace --release

# Specific crate
cargo test -p bbx_dsp --release

# Specific test
cargo test test_oscillator --release
</code></pre>
<h2 id="test-categories"><a class="header" href="#test-categories">Test Categories</a></h2>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<p>In-module tests for individual components:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_gain_calculation() {
        let block = GainBlock::&lt;f32&gt;::new(-6.0);
        let expected = 0.5; // -6 dB ≈ 0.5
        assert!((block.multiplier() - expected).abs() &lt; 0.01);
    }
}
<span class="boring">}</span></code></pre>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<p>Cross-module tests in <code>tests/</code> directory:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tests/graph_tests.rs
use bbx_dsp::{GraphBuilder, Waveform};

#[test]
fn test_simple_graph() {
    let mut builder = GraphBuilder::&lt;f32&gt;::new(44100.0, 512, 2);
    let osc = builder.add_oscillator(440.0, Waveform::Sine, None);
    let graph = builder.build();

    // Test processing...
}
<span class="boring">}</span></code></pre>
<h2 id="audio-testing-challenges"><a class="header" href="#audio-testing-challenges">Audio Testing Challenges</a></h2>
<p>Audio tests are inherently approximate:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_sine_output() {
    // Generate one cycle of 1 Hz at 4 samples/second
    // Expected: [0, 1, 0, -1]

    let output = generate_sine(4);

    // Use epsilon comparison
    assert!((output[0] - 0.0).abs() &lt; 0.001);
    assert!((output[1] - 1.0).abs() &lt; 0.001);
}
<span class="boring">}</span></code></pre>
<h2 id="test-utilities"><a class="header" href="#test-utilities">Test Utilities</a></h2>
<h3 id="dspcontext-for-tests"><a class="header" href="#dspcontext-for-tests">DspContext for Tests</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test_context() -&gt; DspContext {
    DspContext::new(44100.0, 512, 2)
}
<span class="boring">}</span></code></pre>
<h3 id="buffer-helpers"><a class="header" href="#buffer-helpers">Buffer Helpers</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_test_buffers(size: usize) -&gt; (Vec&lt;f32&gt;, Vec&lt;f32&gt;) {
    (vec![0.0; size], vec![0.0; size])
}
<span class="boring">}</span></code></pre>
<h2 id="what-to-test"><a class="header" href="#what-to-test">What to Test</a></h2>
<ol>
<li><strong>Edge cases</strong> - Zero input, maximum values</li>
<li><strong>Parameter ranges</strong> - Valid and invalid values</li>
<li><strong>Sample types</strong> - Both f32 and f64</li>
<li><strong>Processing correctness</strong> - Expected output values</li>
<li><strong>State management</strong> - Reset behavior</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="release-process"><a class="header" href="#release-process">Release Process</a></h1>
<p>How to release new versions of bbx_audio.</p>
<h2 id="prerequisites-6"><a class="header" href="#prerequisites-6">Prerequisites</a></h2>
<ul>
<li>Push access to the repository</li>
<li><code>CARGO_REGISTRY_TOKEN</code> configured in GitHub secrets</li>
</ul>
<h2 id="version-bump"><a class="header" href="#version-bump">Version Bump</a></h2>
<ol>
<li>Update version in all <code>Cargo.toml</code> files</li>
<li>Update <code>CHANGELOG.md</code></li>
<li>Commit changes</li>
</ol>
<pre><code class="language-bash"># Example: bumping to 0.2.0
# Edit Cargo.toml files...
git add -A
git commit -m "Bump version to 0.2.0"
</code></pre>
<h2 id="creating-a-release"><a class="header" href="#creating-a-release">Creating a Release</a></h2>
<ol>
<li>Create and push a version tag:</li>
</ol>
<pre><code class="language-bash">git tag v0.2.0
git push origin v0.2.0
</code></pre>
<ol start="2">
<li>GitHub Actions will:
<ul>
<li>Run tests</li>
<li>Publish to crates.io</li>
<li>Create GitHub release</li>
</ul>
</li>
</ol>
<h2 id="crate-publishing-order"><a class="header" href="#crate-publishing-order">Crate Publishing Order</a></h2>
<p>Crates must be published in dependency order:</p>
<ol>
<li><code>bbx_core</code> (no dependencies)</li>
<li><code>bbx_midi</code> (no internal dependencies)</li>
<li><code>bbx_dsp</code> (depends on bbx_core)</li>
<li><code>bbx_file</code> (depends on bbx_dsp)</li>
<li><code>bbx_plugin</code> (depends on bbx_dsp)</li>
</ol>
<h2 id="manual-publishing"><a class="header" href="#manual-publishing">Manual Publishing</a></h2>
<p>If needed:</p>
<pre><code class="language-bash">cargo publish -p bbx_core
# Wait for crates.io index update (~1 minute)
cargo publish -p bbx_midi
cargo publish -p bbx_dsp
cargo publish -p bbx_file
cargo publish -p bbx_plugin
</code></pre>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="publish-failure"><a class="header" href="#publish-failure">Publish Failure</a></h3>
<p>If publishing fails mid-way:</p>
<ol>
<li>Fix the issue</li>
<li>Bump patch version</li>
<li>Retry publishing remaining crates</li>
</ol>
<h3 id="version-conflicts"><a class="header" href="#version-conflicts">Version Conflicts</a></h3>
<p>Ensure all workspace crates use the same version in dependencies.</p>
<p>See <code>RELEASING.md</code> in the repository root for detailed instructions.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>All notable changes to bbx_audio.</p>
<p>The format is based on <a href="https://keepachangelog.com/">Keep a Changelog</a>, and this project adheres to <a href="https://semver.org/">Semantic Versioning</a>.</p>
<h2 id="unreleased"><a class="header" href="#unreleased">[Unreleased]</a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<ul>
<li>mdBook documentation with comprehensive guides</li>
<li>Denormal handling support for Apple Silicon (AArch64)</li>
<li><code>ftz-daz</code> feature flag for flush-to-zero / denormals-are-zero mode</li>
</ul>
<h3 id="changed"><a class="header" href="#changed">Changed</a></h3>
<ul>
<li>Improved parameter initialization with dynamic approach</li>
<li>GraphBuilder now connects all terminal blocks to output (fixes multi-oscillator graphs)</li>
</ul>
<h3 id="fixed"><a class="header" href="#fixed">Fixed</a></h3>
<ul>
<li>Removed duplicate parameter index definitions</li>
<li>Removed unnecessary PhantomData from GainBlock, OverdriveBlock, PannerBlock</li>
</ul>
<h2 id="010---initial-release"><a class="header" href="#010---initial-release">[0.1.0] - Initial Release</a></h2>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<ul>
<li>
<p><strong>bbx_core</strong>: Foundational utilities</p>
<ul>
<li>Denormal handling</li>
<li>SPSC ring buffer</li>
<li>Stack-allocated vector</li>
<li>XorShift RNG</li>
<li>Error types</li>
</ul>
</li>
<li>
<p><strong>bbx_dsp</strong>: DSP graph system</p>
<ul>
<li>Block trait and BlockType enum</li>
<li>Graph and GraphBuilder</li>
<li>Topological sorting</li>
<li>Parameter modulation</li>
<li>Blocks: Oscillator, Gain, Panner, Overdrive, DC Blocker, Channel Router, LFO, Envelope, File I/O, Output</li>
</ul>
</li>
<li>
<p><strong>bbx_file</strong>: Audio file I/O</p>
<ul>
<li>WAV reading via wavers</li>
<li>WAV writing via hound</li>
</ul>
</li>
<li>
<p><strong>bbx_midi</strong>: MIDI utilities</p>
<ul>
<li>Message parsing</li>
<li>Message buffer</li>
<li>Input streaming</li>
</ul>
</li>
<li>
<p><strong>bbx_plugin</strong>: Plugin integration</p>
<ul>
<li>PluginDsp trait</li>
<li>FFI macro</li>
<li>Parameter definitions</li>
<li>C/C++ headers</li>
</ul>
</li>
<li>
<p><strong>bbx_sandbox</strong>: Examples</p>
<ul>
<li>Sine wave generation</li>
<li>PWM synthesis</li>
<li>Overdrive effect</li>
<li>WAV file I/O</li>
<li>MIDI input</li>
</ul>
</li>
</ul>
<hr>
<p>For the full changelog, see <a href="https://github.com/blackboxaudio/bbx_audio/blob/develop/CHANGELOG.md">CHANGELOG.md</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="migration-guide"><a class="header" href="#migration-guide">Migration Guide</a></h1>
<p>Upgrading between bbx_audio versions.</p>
<h2 id="01x-to-02x"><a class="header" href="#01x-to-02x">0.1.x to 0.2.x</a></h2>
<p><em>(Placeholder for future breaking changes)</em></p>
<h3 id="api-changes"><a class="header" href="#api-changes">API Changes</a></h3>
<p>When breaking changes occur, they will be documented here with:</p>
<ul>
<li>What changed</li>
<li>Why it changed</li>
<li>How to update your code</li>
</ul>
<h3 id="example-migration"><a class="header" href="#example-migration">Example Migration</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Old API (0.1.x)
let graph = GraphBuilder::new(44100.0, 512, 2).build();

// New API (0.2.x) - hypothetical
let graph = GraphBuilder::new()
    .sample_rate(44100.0)
    .buffer_size(512)
    .channels(2)
    .build();
<span class="boring">}</span></code></pre>
<h2 id="general-upgrade-process"><a class="header" href="#general-upgrade-process">General Upgrade Process</a></h2>
<ol>
<li><strong>Read the changelog</strong> - Understand what changed</li>
<li><strong>Update dependencies</strong> - Bump version in <code>Cargo.toml</code></li>
<li><strong>Run tests</strong> - Identify breaking changes</li>
<li><strong>Fix compilation errors</strong> - Update API calls</li>
<li><strong>Test thoroughly</strong> - Verify audio output</li>
</ol>
<h2 id="deprecation-policy"><a class="header" href="#deprecation-policy">Deprecation Policy</a></h2>
<ul>
<li>Deprecated APIs are marked with <code>#[deprecated]</code></li>
<li>Deprecated APIs remain for at least one minor version</li>
<li>Removal happens in the next major version</li>
</ul>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you encounter migration issues:</p>
<ol>
<li>Check the <a href="#changelog">changelog</a></li>
<li>Search <a href="https://github.com/blackboxaudio/bbx_audio/issues">GitHub issues</a></li>
<li>Open a new issue if needed</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h1>
<p>Common issues and solutions.</p>
<h2 id="build-issues"><a class="header" href="#build-issues">Build Issues</a></h2>
<h3 id="toolchain-not-found"><a class="header" href="#toolchain-not-found">“toolchain not found”</a></h3>
<p>Install the nightly toolchain:</p>
<pre><code class="language-bash">rustup toolchain install nightly
</code></pre>
<h3 id="linux-audio-errors"><a class="header" href="#linux-audio-errors">Linux Audio Errors</a></h3>
<p>Install ALSA development packages:</p>
<pre><code class="language-bash">sudo apt install alsa libasound2-dev
</code></pre>
<h3 id="slow-compilation"><a class="header" href="#slow-compilation">Slow Compilation</a></h3>
<p>Use release mode for faster runtime:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<h2 id="runtime-issues"><a class="header" href="#runtime-issues">Runtime Issues</a></h2>
<h3 id="no-audio-output"><a class="header" href="#no-audio-output">No Audio Output</a></h3>
<ol>
<li>Check audio device is available</li>
<li>Verify sample rate matches system</li>
<li>Ensure output block is connected</li>
</ol>
<h3 id="cracklingglitches"><a class="header" href="#cracklingglitches">Crackling/Glitches</a></h3>
<ol>
<li>Increase buffer size</li>
<li>Check CPU usage</li>
<li>Avoid allocations in audio thread</li>
<li>Profile for bottlenecks</li>
</ol>
<h3 id="silence"><a class="header" href="#silence">Silence</a></h3>
<ol>
<li>Verify block connections</li>
<li>Check gain levels (not -inf dB)</li>
<li>Ensure <code>prepare()</code> was called</li>
</ol>
<h2 id="ffi-issues"><a class="header" href="#ffi-issues">FFI Issues</a></h2>
<h3 id="cannot-find--ldsp-1"><a class="header" href="#cannot-find--ldsp-1">“Cannot find -ldsp”</a></h3>
<ol>
<li>Ensure Rust crate builds successfully</li>
<li>Check Corrosion configuration</li>
<li>Verify <code>staticlib</code> crate type</li>
</ol>
<h3 id="header-not-found-1"><a class="header" href="#header-not-found-1">Header Not Found</a></h3>
<p>Verify <code>target_include_directories</code> in CMake:</p>
<pre><code class="language-cmake">target_include_directories(${TARGET} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/dsp/include)
</code></pre>
<h3 id="linking-errors-1"><a class="header" href="#linking-errors-1">Linking Errors</a></h3>
<p>Check crate type in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[lib]
crate-type = ["staticlib"]
</code></pre>
<h2 id="parameter-issues"><a class="header" href="#parameter-issues">Parameter Issues</a></h2>
<h3 id="parameters-not-updating"><a class="header" href="#parameters-not-updating">Parameters Not Updating</a></h3>
<ol>
<li>Verify parameter indices match</li>
<li>Check <code>apply_parameters()</code> implementation</li>
<li>Ensure JUCE is calling <code>Process()</code> with params</li>
</ol>
<h3 id="wrong-parameter-values"><a class="header" href="#wrong-parameter-values">Wrong Parameter Values</a></h3>
<ol>
<li>Verify JSON/code generation sync</li>
<li>Check parameter count matches</li>
<li>Debug print received values</li>
</ol>
<h2 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h2>
<ol>
<li>Check <a href="https://github.com/blackboxaudio/bbx_audio/issues">GitHub Issues</a></li>
<li>Search existing discussions</li>
<li>Open a new issue with:
<ul>
<li>bbx_audio version</li>
<li>Platform and OS</li>
<li>Minimal reproduction</li>
<li>Error messages</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>Audio DSP and bbx_audio terminology.</p>
<h2 id="a"><a class="header" href="#a">A</a></h2>
<p><strong>ADSR</strong>: Attack-Decay-Sustain-Release. An envelope shape for amplitude or parameter control.</p>
<p><strong>Audio Thread</strong>: The high-priority thread that processes audio. Must be real-time safe.</p>
<h2 id="b"><a class="header" href="#b">B</a></h2>
<p><strong>Block</strong>: A DSP processing unit in bbx_audio. Implements the <code>Block</code> trait.</p>
<p><strong>Buffer</strong>: A fixed-size array of audio samples, typically 256-2048 samples.</p>
<p><strong>Buffer Size</strong>: Number of samples processed per audio callback.</p>
<h2 id="c"><a class="header" href="#c">C</a></h2>
<p><strong>Control Rate</strong>: Updating values once per buffer, not per sample. Used for modulation.</p>
<p><strong>Cycle</strong>: An illegal loop in a DSP graph where a block’s output feeds back to its input.</p>
<h2 id="d"><a class="header" href="#d">D</a></h2>
<p><strong>DAG</strong>: Directed Acyclic Graph. The structure of a DSP graph with no cycles.</p>
<p><strong>Denormal</strong>: Very small floating-point numbers that cause CPU slowdowns.</p>
<p><strong>DSP</strong>: Digital Signal Processing. Mathematical operations on audio samples.</p>
<h2 id="e"><a class="header" href="#e">E</a></h2>
<p><strong>Effector</strong>: A block that processes audio (gain, filter, distortion).</p>
<p><strong>Envelope</strong>: A time-varying control signal, typically ADSR.</p>
<h2 id="f"><a class="header" href="#f">F</a></h2>
<p><strong>FFI</strong>: Foreign Function Interface. How Rust code is called from C/C++.</p>
<h2 id="g"><a class="header" href="#g">G</a></h2>
<p><strong>Generator</strong>: A block that creates audio from nothing (oscillator, noise).</p>
<p><strong>Graph</strong>: A connected set of DSP blocks with defined signal flow.</p>
<h2 id="l"><a class="header" href="#l">L</a></h2>
<p><strong>Latency</strong>: Delay between input and output, measured in samples or milliseconds.</p>
<p><strong>LFO</strong>: Low-Frequency Oscillator. A slow oscillator for modulation.</p>
<h2 id="m"><a class="header" href="#m">M</a></h2>
<p><strong>Modulation</strong>: Varying a parameter over time using a control signal.</p>
<p><strong>Modulator</strong>: A block that generates control signals (LFO, envelope).</p>
<h2 id="o"><a class="header" href="#o">O</a></h2>
<p><strong>Oscillator</strong>: A block that generates periodic waveforms.</p>
<h2 id="p"><a class="header" href="#p">P</a></h2>
<p><strong>Port</strong>: An input or output connection point on a block.</p>
<h2 id="r"><a class="header" href="#r">R</a></h2>
<p><strong>Real-Time Safe</strong>: Code that completes in bounded time without blocking.</p>
<h2 id="s"><a class="header" href="#s">S</a></h2>
<p><strong>Sample</strong>: A single audio value at a point in time.</p>
<p><strong>Sample Rate</strong>: Samples per second, typically 44100 or 48000 Hz.</p>
<p><strong>SIMD</strong>: Single Instruction Multiple Data. Processing multiple samples at once.</p>
<p><strong>SPSC</strong>: Single-Producer Single-Consumer. A lock-free queue pattern.</p>
<h2 id="t"><a class="header" href="#t">T</a></h2>
<p><strong>Topological Sort</strong>: Algorithm that orders blocks so dependencies run first.</p>
<h2 id="w"><a class="header" href="#w">W</a></h2>
<p><strong>Waveform</strong>: The shape of a periodic signal (sine, square, saw, triangle).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
